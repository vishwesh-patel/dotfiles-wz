import * as vscode from 'vscode';
import { TypeScriptServiceConfiguration } from '../configuration/configuration';
import { TelemetryReporter } from '../logging/telemetry';
import Tracer from '../logging/tracer';
import { ServerResponse, ServerType, TypeScriptRequests } from '../typescriptService';
import { Disposable } from '../utils/dispose';
import { OngoingRequestCanceller } from './cancellation';
import type * as Proto from './protocol/protocol';
import { TypeScriptVersionManager } from './versionManager';
import { TypeScriptVersion } from './versionProvider';
import { NodeVersionManager } from './nodeManager';
export declare enum ExecutionTarget {
    Semantic = 0,
    Syntax = 1
}
export interface TypeScriptServerExitEvent {
    readonly code: number | null;
    readonly signal: string | null;
}
export type TsServerLog = {
    readonly type: 'file';
    readonly uri: vscode.Uri;
} | {
    readonly type: 'output';
    readonly output: vscode.OutputChannel;
};
export interface ITypeScriptServer {
    readonly onEvent: vscode.Event<Proto.Event>;
    readonly onExit: vscode.Event<TypeScriptServerExitEvent>;
    readonly onError: vscode.Event<any>;
    readonly tsServerLog: TsServerLog | undefined;
    kill(): void;
    /**
     * @return A list of all execute requests. If there are multiple entries, the first item is the primary
     * request while the rest are secondary ones.
     */
    executeImpl(command: keyof TypeScriptRequests, args: any, executeInfo: {
        isAsync: boolean;
        token?: vscode.CancellationToken;
        expectsResult: boolean;
        lowPriority?: boolean;
        executionTarget?: ExecutionTarget;
    }): Array<Promise<ServerResponse.Response<Proto.Response>> | undefined>;
    dispose(): void;
}
export interface TsServerDelegate {
    onFatalError(command: string, error: Error): void;
}
export declare const enum TsServerProcessKind {
    Main = "main",
    Syntax = "syntax",
    Semantic = "semantic",
    Diagnostics = "diagnostics"
}
export interface TsServerProcessFactory {
    fork(version: TypeScriptVersion, args: readonly string[], kind: TsServerProcessKind, configuration: TypeScriptServiceConfiguration, versionManager: TypeScriptVersionManager, nodeVersionManager: NodeVersionManager, tsServerLog: TsServerLog | undefined): TsServerProcess;
}
export interface TsServerProcess {
    write(serverRequest: Proto.Request): void;
    onData(handler: (data: Proto.Response) => void): void;
    onExit(handler: (code: number | null, signal: string | null) => void): void;
    onError(handler: (error: Error) => void): void;
    kill(): void;
}
export declare class SingleTsServer extends Disposable implements ITypeScriptServer {
    private readonly _serverId;
    private readonly _serverSource;
    private readonly _process;
    private readonly _tsServerLog;
    private readonly _requestCanceller;
    private readonly _version;
    private readonly _telemetryReporter;
    private readonly _tracer;
    private readonly _requestQueue;
    private readonly _callbacks;
    private readonly _pendingResponses;
    constructor(_serverId: string, _serverSource: ServerType, _process: TsServerProcess, _tsServerLog: TsServerLog | undefined, _requestCanceller: OngoingRequestCanceller, _version: TypeScriptVersion, _telemetryReporter: TelemetryReporter, _tracer: Tracer);
    private readonly _onEvent;
    readonly onEvent: vscode.Event<Proto.Event>;
    private readonly _onExit;
    readonly onExit: vscode.Event<TypeScriptServerExitEvent>;
    private readonly _onError;
    readonly onError: vscode.Event<any>;
    get tsServerLog(): TsServerLog | undefined;
    private write;
    dispose(): void;
    kill(): void;
    private dispatchMessage;
    private tryCancelRequest;
    private dispatchResponse;
    executeImpl(command: keyof TypeScriptRequests, args: any, executeInfo: {
        isAsync: boolean;
        token?: vscode.CancellationToken;
        expectsResult: boolean;
        lowPriority?: boolean;
        executionTarget?: ExecutionTarget;
    }): Array<Promise<ServerResponse.Response<Proto.Response>> | undefined>;
    private sendNextRequests;
    private sendRequest;
    private fetchCallback;
    private logTrace;
    private static readonly fenceCommands;
    private static getQueueingType;
}
export declare class GetErrRoutingTsServer extends Disposable implements ITypeScriptServer {
    private static readonly diagnosticEvents;
    private readonly getErrServer;
    private readonly mainServer;
    private readonly router;
    constructor(servers: {
        getErr: ITypeScriptServer;
        primary: ITypeScriptServer;
    }, delegate: TsServerDelegate);
    private readonly _onEvent;
    readonly onEvent: vscode.Event<Proto.Event>;
    private readonly _onExit;
    readonly onExit: vscode.Event<TypeScriptServerExitEvent>;
    private readonly _onError;
    readonly onError: vscode.Event<any>;
    get tsServerLog(): TsServerLog | undefined;
    kill(): void;
    executeImpl(command: keyof TypeScriptRequests, args: any, executeInfo: {
        isAsync: boolean;
        token?: vscode.CancellationToken;
        expectsResult: boolean;
        lowPriority?: boolean;
        executionTarget?: ExecutionTarget;
    }): Array<Promise<ServerResponse.Response<Proto.Response>> | undefined>;
}
export declare class SyntaxRoutingTsServer extends Disposable implements ITypeScriptServer {
    /**
     * Commands that should always be run on the syntax server.
     */
    private static readonly syntaxAlwaysCommands;
    /**
     * Commands that should always be run on the semantic server.
     */
    private static readonly semanticCommands;
    /**
     * Commands that can be run on the syntax server but would benefit from being upgraded to the semantic server.
     */
    private static readonly syntaxAllowedCommands;
    private readonly syntaxServer;
    private readonly semanticServer;
    private readonly router;
    private _projectLoading;
    constructor(servers: {
        syntax: ITypeScriptServer;
        semantic: ITypeScriptServer;
    }, delegate: TsServerDelegate, enableDynamicRouting: boolean);
    private get projectLoading();
    private readonly _onEvent;
    readonly onEvent: vscode.Event<Proto.Event>;
    private readonly _onExit;
    readonly onExit: vscode.Event<any>;
    private readonly _onError;
    readonly onError: vscode.Event<any>;
    get tsServerLog(): TsServerLog | undefined;
    kill(): void;
    executeImpl(command: keyof TypeScriptRequests, args: any, executeInfo: {
        isAsync: boolean;
        token?: vscode.CancellationToken;
        expectsResult: boolean;
        lowPriority?: boolean;
        executionTarget?: ExecutionTarget;
    }): Array<Promise<ServerResponse.Response<Proto.Response>> | undefined>;
}
//# sourceMappingURL=server.d.ts.map