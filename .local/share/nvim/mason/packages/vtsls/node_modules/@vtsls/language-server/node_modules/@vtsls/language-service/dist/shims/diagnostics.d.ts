import type * as vscode from "vscode";
import * as lsp from "vscode-languageserver-protocol";
import { URI } from "vscode-uri";
import { DebouncedEmitter } from "../utils/debouncedEmitter";
import { Disposable } from "../utils/dispose";
export declare class DiagnosticsShimService extends Disposable {
    private diagnosticsCollections;
    readonly onDidChangeDiagnostics: DebouncedEmitter<vscode.DiagnosticChangeEvent>;
    dispose(): void;
    createDiagnosticCollection(name?: string): DiagnosticCollection;
    getDiagnostics(resource: URI): vscode.Diagnostic[];
    getDiagnostics(resource?: URI): (vscode.Diagnostic | [URI, vscode.Diagnostic[]])[];
    private _geteAllDiagnostics;
}
export declare class DiagnosticCollection implements vscode.DiagnosticCollection {
    private readonly _name;
    private readonly _onDidChangeDiagnostics;
    private readonly _data;
    private _isDisposed;
    constructor(_name: string, onCaseInsensitiveFileSystem: boolean, onDidChangeDiagnostics: lsp.Emitter<vscode.DiagnosticChangeEvent>);
    dispose(): void;
    get name(): string;
    set(uri: vscode.Uri, diagnostics: ReadonlyArray<vscode.Diagnostic>): void;
    set(entries: ReadonlyArray<[vscode.Uri, ReadonlyArray<vscode.Diagnostic>]>): void;
    delete(uri: vscode.Uri): void;
    clear(): void;
    forEach(callback: (uri: URI, diagnostics: ReadonlyArray<vscode.Diagnostic>, collection: DiagnosticCollection) => any, thisArg?: any): void;
    [Symbol.iterator](): IterableIterator<[
        uri: vscode.Uri,
        diagnostics: readonly vscode.Diagnostic[]
    ]>;
    get(uri: URI): ReadonlyArray<vscode.Diagnostic>;
    has(uri: URI): boolean;
    private _checkDisposed;
    private keys;
    private static _compareIndexedTuplesByUri;
}
//# sourceMappingURL=diagnostics.d.ts.map