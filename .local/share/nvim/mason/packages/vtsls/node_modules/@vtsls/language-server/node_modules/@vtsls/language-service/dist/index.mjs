var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/share/commandsConverter.ts
import * as lsp from "vscode-languageserver-protocol";
import { URI } from "vscode-uri";
function createCommandsConverter(converter, workspaceService) {
  function getOpenedDoc(uri) {
    return workspaceService.$getOpenedDocThrow(uri);
  }
  return {
    // NOTE: from getCommand in languageFeatures/codeLens/implementationsCodeLens.ts
    "editor.action.showReferences": {
      toArgs: (document, codeLensStart, locations) => [
        document.toString(),
        converter.convertPositionToLsp(codeLensStart),
        locations.map(converter.convertLocation)
      ]
    },
    "editor.action.rename": {
      toArgs: (...renamings) => renamings.map(([uri, position]) => [
        uri.toString(),
        converter.convertPositionToLsp(position)
      ])
    },
    "typescript.goToSourceDefinition": {
      fromArgs: (uri, position) => [
        getOpenedDoc(uri),
        converter.convertPositionFromLsp(position)
      ],
      toRes: (locations) => locations.map(converter.convertLocation)
    },
    "typescript.findAllFileReferences": {
      fromArgs: (uri) => [URI.parse(uri)],
      toRes: (locations) => locations.map(converter.convertLocation)
    },
    "_typescript.moveToFileRefactoring": {
      toArgs: ({
        action,
        document,
        range
      }) => [action, document.uri.toString(), converter.convertRangeToLsp(range)],
      fromArgs: (action, uri, range, targetFile) => [
        {
          action,
          document: getOpenedDoc(uri),
          range: converter.convertRangeFromLsp(range),
          targetFile,
          trigger: lsp.CodeActionTriggerKind.Invoked
        }
      ]
    },
    "_typescript.selectRefactoring": {
      toArgs: ({
        document,
        refactor,
        rangeOrSelection,
        trigger
      }) => [
        document.uri.toString(),
        refactor,
        converter.convertRangeToLsp(rangeOrSelection),
        trigger
      ],
      fromArgs: (uri, refactor, range, trigger) => [
        {
          document: getOpenedDoc(uri),
          refactor,
          rangeOrSelection: converter.convertRangeFromLsp(range),
          trigger
        }
      ]
    },
    "_typescript.applyCodeActionCommand": {
      toArgs: ({
        action,
        diagnostic,
        document
      }) => [action, converter.convertDiagnosticToLsp(diagnostic), document.uri.toString()],
      fromArgs: (action, diagnostic, uri) => [
        {
          action,
          diagnostic: converter.convertDiagnosticFromLsp(diagnostic),
          document: getOpenedDoc(uri)
        }
      ]
    }
  };
}
var init_commandsConverter = __esm({
  "src/share/commandsConverter.ts"() {
    "use strict";
  }
});

// src/share/index.ts
function initializeShareMod(converter, workspaceService) {
  commandsConverter = createCommandsConverter(converter, workspaceService);
  return { commandsConverter };
}
var commandsConverter;
var init_share = __esm({
  "src/share/index.ts"() {
    "use strict";
    init_commandsConverter();
  }
});

// src/shims/chat.ts
function createChatShim() {
  return {
    registerMappedEditsProvider() {
    }
  };
}
var init_chat = __esm({
  "src/shims/chat.ts"() {
    "use strict";
  }
});

// src/typescript-language-features/src/utils/dispose.ts
function disposeAll(disposables) {
  const errors = [];
  for (const disposable of disposables) {
    try {
      disposable.dispose();
    } catch (e) {
      errors.push(e);
    }
  }
  if (errors.length === 1) {
    throw errors[0];
  } else if (errors.length > 1) {
    throw new AggregateError(errors, "Encountered errors while disposing of store");
  }
}
var Disposable, DisposableStore;
var init_dispose = __esm({
  "src/typescript-language-features/src/utils/dispose.ts"() {
    "use strict";
    Disposable = class {
      constructor() {
        this._isDisposed = false;
        this._disposables = [];
      }
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        disposeAll(this._disposables);
      }
      _register(value) {
        if (this._isDisposed) {
          value.dispose();
        } else {
          this._disposables.push(value);
        }
        return value;
      }
      get isDisposed() {
        return this._isDisposed;
      }
    };
    DisposableStore = class extends Disposable {
      add(disposable) {
        this._register(disposable);
        return disposable;
      }
    };
  }
});

// src/utils/dispose.ts
var _DisposableStore, DisposableStore2;
var init_dispose2 = __esm({
  "src/utils/dispose.ts"() {
    "use strict";
    init_dispose();
    _DisposableStore = class _DisposableStore {
      constructor() {
        this._toDispose = /* @__PURE__ */ new Set();
        this._isDisposed = false;
      }
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this.clear();
      }
      get isDisposed() {
        return this._isDisposed;
      }
      clear() {
        if (this._toDispose.size === 0) {
          return;
        }
        try {
          this._toDispose.forEach((d) => d.dispose());
        } finally {
          this._toDispose.clear();
        }
      }
      add(o) {
        if (!o) {
          return o;
        }
        if (o === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        if (this._isDisposed) {
          if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
            console.warn(
              new Error(
                "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!"
              ).stack
            );
          }
        } else {
          this._toDispose.add(o);
        }
        return o;
      }
    };
    _DisposableStore.DISABLE_DISPOSED_WARNING = false;
    DisposableStore2 = _DisposableStore;
  }
});

// src/shims/commands.ts
import * as lsp2 from "vscode-languageserver-protocol";
var CommandsShimService;
var init_commands = __esm({
  "src/shims/commands.ts"() {
    "use strict";
    init_dispose2();
    CommandsShimService = class extends Disposable {
      constructor(delegate) {
        super();
        this.delegate = delegate;
        this._commands = /* @__PURE__ */ new Map();
        this._onDidRegisterCommand = this._register(new lsp2.Emitter());
        this.onDidRegisterCommand = this._onDidRegisterCommand.event;
        this._register(this.registerCommand("setContext", () => {
        }));
      }
      async getCommands(filterInternal = false) {
        const result = [];
        for (const id of this._commands.keys()) {
          if (filterInternal && !id.startsWith("_")) {
            result.push(id);
          }
        }
        return result;
      }
      registerCommand(id, callback, thisArg) {
        if (!id.trim().length) {
          throw new Error("invalid id");
        }
        if (this._commands.has(id)) {
          throw new Error(`command '${id}' already exists`);
        }
        this._commands.set(id, { id, callback, thisArg });
        return this._register(
          lsp2.Disposable.create(() => {
            this._commands.delete(id);
          })
        );
      }
      async executeCommand(id, ...args) {
        if (id.startsWith("editor.")) {
          this.delegate.logMessage(
            lsp2.MessageType.Error,
            `Command ${id} is an client side command and should not be sent to server for execution`
          );
          return;
        }
        const command = this._commands.get(id);
        if (!command) {
          this.delegate.logMessage(lsp2.MessageType.Error, `Command ${id} not found`);
          return;
        }
        const { callback, thisArg } = command;
        try {
          return await callback.apply(thisArg, args);
        } catch (e) {
          this.delegate.logMessage(lsp2.MessageType.Error, `Execute command ${id} failed: ${String(e)}`);
        }
      }
      dispose() {
        this._commands.clear();
        super.dispose();
      }
    };
  }
});

// src/typescript-language-features/src/utils/arrays.ts
function equals(a, b, itemEquals = (a2, b2) => a2 === b2) {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  return a.every((x, i) => itemEquals(x, b[i]));
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
var empty;
var init_arrays = __esm({
  "src/typescript-language-features/src/utils/arrays.ts"() {
    "use strict";
    empty = Object.freeze([]);
  }
});

// src/typescript-language-features/src/utils/objects.ts
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  if (Array.isArray(one)) {
    return equals(one, other, equals2);
  } else {
    const oneKeys = [];
    for (const key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (const key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    return oneKeys.every((key) => equals2(one[key], other[key]));
  }
}
var init_objects = __esm({
  "src/typescript-language-features/src/utils/objects.ts"() {
    "use strict";
    init_arrays();
  }
});

// src/utils/objects.ts
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.entries(obj).forEach(([key, value]) => {
    result[key] = value && typeof value === "object" ? deepClone(value) : value;
  });
  return result;
}
var init_objects2 = __esm({
  "src/utils/objects.ts"() {
    "use strict";
    init_objects();
  }
});

// src/utils/types.ts
function isNil(val) {
  return val === void 0 || val === null;
}
function isPrimitive(val) {
  return val === null || typeof val === "boolean" || typeof val === "number" || typeof val === "string" || typeof val === "symbol" || // ES6 symbol
  typeof val === "undefined";
}
var init_types = __esm({
  "src/utils/types.ts"() {
    "use strict";
  }
});

// src/shims/configuration.ts
import { Emitter as Emitter2 } from "vscode-languageserver-protocol";
function lookUp(tree, key) {
  if (key) {
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && !isPrimitive(node) && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
function update(tree, key, val) {
  const parts = key.split(".");
  let node = tree;
  for (let i = 0; node && !isPrimitive(node) && i < parts.length - 1; i++) {
    if (!node[parts[i]]) {
      node[parts[i]] = {};
    }
    node = node[parts[i]];
  }
  if (node && !isPrimitive(node) && parts.length) {
    node[parts[parts.length - 1]] = val;
  }
}
function recursiveUpdate(cur, value) {
  if (Array.isArray(value) || typeof value !== "object" || value === null) {
    return value;
  }
  for (const [k, v] of Object.entries(value)) {
    if (!cur[k]) {
      cur[k] = v;
    } else {
      cur[k] = recursiveUpdate(cur[k], v);
    }
  }
  return cur;
}
var ConfigurationShimService;
var init_configuration = __esm({
  "src/shims/configuration.ts"() {
    "use strict";
    init_dispose2();
    init_objects2();
    init_types();
    ConfigurationShimService = class extends Disposable {
      constructor(defaultConfig) {
        super();
        this.workspaceConfig = {};
        this._onDidChangeConfiguration = this._register(
          new Emitter2()
        );
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.defaultConfig = deepClone(defaultConfig);
      }
      getConfiguration(section) {
        const provider = this;
        const vscConfig = {
          has(key) {
            key = section ? `${section}.${key}` : key;
            return typeof lookUp(provider.workspaceConfig, key) !== "undefined" || typeof lookUp(provider.defaultConfig, key) !== "undefined";
          },
          get(key, defaultValue) {
            key = section ? `${section}.${key}` : key;
            let result = lookUp(provider.workspaceConfig, key);
            if (typeof result === "undefined") {
              result = lookUp(provider.defaultConfig, key);
            }
            if (typeof result === "undefined") {
              return defaultValue;
            }
            return result;
          },
          inspect(key) {
            if (this.has(key)) {
              key = section ? `${section}.${key}` : key;
              return {
                key,
                defaultValue: lookUp(provider.defaultConfig, key),
                workspaceValue: lookUp(provider.workspaceConfig, key)
              };
            }
          },
          update(key, value) {
            key = section ? `${section}.${key}` : key;
            update(provider.workspaceConfig, key, value);
            provider._onDidChangeConfiguration.fire({
              affectsConfiguration(sec) {
                return key.startsWith(sec);
              }
            });
            return Promise.resolve();
          }
        };
        return vscConfig;
      }
      $changeConfiguration(config3) {
        recursiveUpdate(this.workspaceConfig, config3);
        this._onDidChangeConfiguration.fire({
          affectsConfiguration(sec) {
            return !!lookUp(config3, sec);
          }
        });
      }
    };
  }
});

// src/shims/memento.ts
var Memento;
var init_memento = __esm({
  "src/shims/memento.ts"() {
    "use strict";
    Memento = class {
      constructor() {
        this._storage = {};
      }
      keys() {
        return Object.keys(this._storage);
      }
      get(key, defaultValue) {
        return this._storage[key] ?? defaultValue;
      }
      update(key, value) {
        this._storage[key] = value;
        return Promise.resolve();
      }
      setKeysForSync() {
        throw new Error("not implmented");
      }
    };
  }
});

// src/shims/context.ts
import { URI as URI2 } from "vscode-uri";
function createContextShim(logPath, hostInfo) {
  return {
    logPath,
    hostInfo,
    subscriptions: [],
    workspaceState: new Memento(),
    globalState: new Memento(),
    extensionUri: URI2.from({ scheme: "virtual" })
  };
}
var init_context = __esm({
  "src/shims/context.ts"() {
    "use strict";
    init_memento();
  }
});

// src/utils/debouncedEmitter.ts
import { Emitter as Emitter3 } from "vscode-languageserver-protocol";
var DebouncedEmitter;
var init_debouncedEmitter = __esm({
  "src/utils/debouncedEmitter.ts"() {
    "use strict";
    DebouncedEmitter = class extends Emitter3 {
      constructor(delay) {
        super();
        this._cancelCount = 0;
        this._eventBuffer = [];
        this._delay = delay ?? 100;
      }
      addCancel() {
        this._cancelCount++;
      }
      tryFlush() {
        if (this._cancelCount !== 0 && --this._cancelCount === 0) {
          const consumed = this._eventBuffer;
          this._eventBuffer = [];
          for (const event of consumed) {
            super.fire(event);
          }
        }
      }
      fire(event) {
        this._eventBuffer.push(event);
        this.addCancel();
        setTimeout(() => {
          this.tryFlush();
        }, this._delay);
      }
    };
  }
});

// src/typescript-language-features/src/utils/lazy.ts
function lazy(getValue) {
  return new LazyValue(getValue);
}
var LazyValue;
var init_lazy = __esm({
  "src/typescript-language-features/src/utils/lazy.ts"() {
    "use strict";
    LazyValue = class _LazyValue {
      constructor(_getValue) {
        this._getValue = _getValue;
        this._hasValue = false;
      }
      get value() {
        if (!this._hasValue) {
          this._hasValue = true;
          this._value = this._getValue();
        }
        return this._value;
      }
      get hasValue() {
        return this._hasValue;
      }
      map(f) {
        return new _LazyValue(() => f(this.value));
      }
    };
  }
});

// src/typescript-language-features/src/utils/temp.electron.ts
import * as fs from "fs";
import * as os from "os";
import * as path from "path";
function makeRandomHexString(length) {
  const chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  let result = "";
  for (let i = 0; i < length; i++) {
    const idx = Math.floor(chars.length * Math.random());
    result += chars[idx];
  }
  return result;
}
function getTempFile(prefix) {
  return path.join(instanceTempDir.value, `${prefix}-${makeRandomHexString(20)}.tmp`);
}
var rootTempDir, instanceTempDir;
var init_temp_electron = __esm({
  "src/typescript-language-features/src/utils/temp.electron.ts"() {
    "use strict";
    init_lazy();
    rootTempDir = lazy(() => {
      const filename = `vscode-typescript${process.platform !== "win32" && process.getuid ? process.getuid() : ""}`;
      return path.join(os.tmpdir(), filename);
    });
    instanceTempDir = lazy(() => {
      const dir = path.join(rootTempDir.value, makeRandomHexString(20));
      fs.mkdirSync(dir, { recursive: true });
      return dir;
    });
  }
});

// src/typescript-language-features/src/utils/fs.electron.ts
import * as fs2 from "fs";
var onCaseInsensitiveFileSystem;
var init_fs_electron = __esm({
  "src/typescript-language-features/src/utils/fs.electron.ts"() {
    "use strict";
    init_temp_electron();
    onCaseInsensitiveFileSystem = /* @__PURE__ */ (() => {
      let value;
      return () => {
        if (typeof value === "undefined") {
          if (process.platform === "win32") {
            value = true;
          } else if (process.platform !== "darwin") {
            value = false;
          } else {
            const temp = getTempFile("typescript-case-check");
            fs2.writeFileSync(temp, "");
            value = fs2.existsSync(temp.toUpperCase());
          }
        }
        return value;
      };
    })();
  }
});

// src/utils/fs.ts
var init_fs = __esm({
  "src/utils/fs.ts"() {
    "use strict";
    init_fs_electron();
  }
});

// src/typescript-language-features/src/utils/platform.ts
function isWeb() {
  return "navigator" in globalThis && env.uiKind === 2 /* Web */;
}
function isWebAndHasSharedArrayBuffers() {
  return isWeb() && globalThis["crossOriginIsolated"];
}
function supportsReadableByteStreams() {
  return isWeb() && "ReadableByteStreamController" in globalThis;
}
var init_platform = __esm({
  "src/typescript-language-features/src/utils/platform.ts"() {
    "use strict";
    init_shims();
  }
});

// src/typescript-language-features/src/configuration/fileSchemes.ts
function getSemanticSupportedSchemes() {
  const alwaysSupportedSchemes = [
    untitled,
    walkThroughSnippet,
    vscodeNotebookCell,
    chatCodeBlock,
    zipfile
  ];
  if (isWeb()) {
    return [
      ...(workspace.workspaceFolders ?? []).map((folder) => folder.uri.scheme),
      ...alwaysSupportedSchemes
    ];
  }
  return [
    file,
    ...alwaysSupportedSchemes
  ];
}
function isOfScheme(uri, ...schemes) {
  const normalizedUriScheme = uri.scheme.toLowerCase();
  return schemes.some((scheme) => normalizedUriScheme === scheme);
}
var file, untitled, git, github, azurerepos, vsls, walkThroughSnippet, vscodeNotebookCell, officeScript, chatCodeBlock, zipfile, disabledSchemes;
var init_fileSchemes = __esm({
  "src/typescript-language-features/src/configuration/fileSchemes.ts"() {
    "use strict";
    init_shims();
    init_platform();
    file = "file";
    untitled = "untitled";
    git = "git";
    github = "github";
    azurerepos = "azurerepos";
    vsls = "vsls";
    walkThroughSnippet = "walkThroughSnippet";
    vscodeNotebookCell = "vscode-notebook-cell";
    officeScript = "office-script";
    chatCodeBlock = "vscode-chat-code-block";
    zipfile = "zipfile";
    disabledSchemes = /* @__PURE__ */ new Set([
      git,
      vsls,
      github,
      azurerepos
    ]);
  }
});

// src/typescript-language-features/src/utils/fs.ts
function looksLikeAbsoluteWindowsPath(path15) {
  return /^[a-zA-Z]:[\/\\]/.test(path15);
}
var init_fs2 = __esm({
  "src/typescript-language-features/src/utils/fs.ts"() {
    "use strict";
    init_shims();
  }
});

// src/typescript-language-features/src/utils/resourceMap.ts
var _ResourceMap, ResourceMap;
var init_resourceMap = __esm({
  "src/typescript-language-features/src/utils/resourceMap.ts"() {
    "use strict";
    init_fileSchemes();
    init_fs2();
    _ResourceMap = class _ResourceMap {
      constructor(_normalizePath = _ResourceMap.defaultPathNormalizer, config3) {
        this._normalizePath = _normalizePath;
        this.config = config3;
        this._map = /* @__PURE__ */ new Map();
      }
      get size() {
        return this._map.size;
      }
      has(resource) {
        const file2 = this.toKey(resource);
        return !!file2 && this._map.has(file2);
      }
      get(resource) {
        const file2 = this.toKey(resource);
        if (!file2) {
          return void 0;
        }
        const entry = this._map.get(file2);
        return entry ? entry.value : void 0;
      }
      set(resource, value) {
        const file2 = this.toKey(resource);
        if (!file2) {
          return;
        }
        const entry = this._map.get(file2);
        if (entry) {
          entry.value = value;
        } else {
          this._map.set(file2, { resource, value });
        }
      }
      delete(resource) {
        const file2 = this.toKey(resource);
        if (file2) {
          this._map.delete(file2);
        }
      }
      clear() {
        this._map.clear();
      }
      values() {
        return Array.from(this._map.values(), (x) => x.value);
      }
      entries() {
        return this._map.values();
      }
      toKey(resource) {
        const key = this._normalizePath(resource);
        if (!key) {
          return key;
        }
        return this.isCaseInsensitivePath(key) ? key.toLowerCase() : key;
      }
      isCaseInsensitivePath(path15) {
        if (looksLikeAbsoluteWindowsPath(path15)) {
          return true;
        }
        return path15[0] === "/" && this.config.onCaseInsensitiveFileSystem;
      }
    };
    _ResourceMap.defaultPathNormalizer = (resource) => {
      if (resource.scheme === file) {
        return resource.fsPath;
      }
      return resource.toString(true);
    };
    ResourceMap = _ResourceMap;
  }
});

// src/utils/resourceMap.ts
var init_resourceMap2 = __esm({
  "src/utils/resourceMap.ts"() {
    "use strict";
    init_resourceMap();
  }
});

// src/utils/uuid.ts
import * as crypto from "crypto";
var generateUuid;
var init_uuid = __esm({
  "src/utils/uuid.ts"() {
    "use strict";
    generateUuid = function() {
      if (typeof crypto === "object" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID.bind(crypto);
      }
      let getRandomValues2;
      if (typeof crypto === "object" && "getRandomValues" in crypto && typeof crypto.getRandomValues === "function") {
        getRandomValues2 = crypto.getRandomValues.bind(crypto);
      } else {
        getRandomValues2 = function(bucket) {
          for (let i = 0; i < bucket.length; i++) {
            bucket[i] = Math.floor(Math.random() * 256);
          }
          return bucket;
        };
      }
      const _data = new Uint8Array(16);
      const _hex = [];
      for (let i = 0; i < 256; i++) {
        _hex.push(i.toString(16).padStart(2, "0"));
      }
      return function generateUuid2() {
        getRandomValues2(_data);
        _data[6] = _data[6] & 15 | 64;
        _data[8] = _data[8] & 63 | 128;
        let i = 0;
        let result = "";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        return result;
      };
    }();
  }
});

// src/shims/diagnostics.ts
import { URI as URI3 } from "vscode-uri";
var DiagnosticsShimService, DiagnosticCollection;
var init_diagnostics = __esm({
  "src/shims/diagnostics.ts"() {
    "use strict";
    init_debouncedEmitter();
    init_dispose2();
    init_fs();
    init_resourceMap2();
    init_uuid();
    DiagnosticsShimService = class extends Disposable {
      constructor() {
        super(...arguments);
        this.diagnosticsCollections = /* @__PURE__ */ new Map();
        this.onDidChangeDiagnostics = this._register(
          new DebouncedEmitter()
        );
      }
      dispose() {
        super.dispose();
        this.diagnosticsCollections.clear();
      }
      createDiagnosticCollection(name) {
        const collectionName = name ?? generateUuid();
        const collection = this._register(
          new DiagnosticCollection(
            collectionName,
            onCaseInsensitiveFileSystem(),
            this.onDidChangeDiagnostics
          )
        );
        this.diagnosticsCollections.set(collectionName, collection);
        return collection;
      }
      getDiagnostics(resource) {
        if (resource) {
          let result = [];
          for (const collection of this.diagnosticsCollections.values()) {
            if (collection.has(resource)) {
              result = result.concat(collection.get(resource));
            }
          }
          return result;
        } else {
          return this._geteAllDiagnostics();
        }
      }
      _geteAllDiagnostics() {
        const result = [];
        const uriIndex = /* @__PURE__ */ new Map();
        for (const collection of this.diagnosticsCollections.values()) {
          collection.forEach((uri, diagnostics) => {
            let idx = uriIndex.get(uri.toString());
            if (typeof idx === "undefined") {
              idx = result.length;
              uriIndex.set(uri.toString(), idx);
              result.push([uri, []]);
            }
            result[idx][1] = result[idx][1].concat(...diagnostics);
          });
        }
        return result;
      }
    };
    DiagnosticCollection = class _DiagnosticCollection {
      constructor(_name, onCaseInsensitiveFileSystem2, onDidChangeDiagnostics) {
        this._name = _name;
        this._isDisposed = false;
        this._data = new ResourceMap(void 0, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 });
        this._onDidChangeDiagnostics = onDidChangeDiagnostics;
      }
      dispose() {
        if (!this._isDisposed) {
          this._onDidChangeDiagnostics.fire({ uris: [...this.keys()] });
          this._data.clear();
          this._isDisposed = true;
        }
      }
      get name() {
        this._checkDisposed();
        return this._name;
      }
      set(first, diagnostics) {
        if (!first) {
          this.clear();
          return;
        }
        this._checkDisposed();
        let toSync = [];
        if (URI3.isUri(first)) {
          if (!diagnostics) {
            this.delete(first);
            return;
          }
          this._data.set(first, diagnostics.slice());
          toSync = [first];
        } else if (Array.isArray(first)) {
          toSync = [];
          let lastUri;
          first = [...first].sort(_DiagnosticCollection._compareIndexedTuplesByUri);
          for (const tuple of first) {
            const [uri, diagnostics2] = tuple;
            if (!lastUri || uri.toString() !== lastUri.toString()) {
              if (lastUri && this._data.get(lastUri).length === 0) {
                this._data.delete(lastUri);
              }
              lastUri = uri;
              toSync.push(uri);
              this._data.set(uri, []);
            }
            if (!diagnostics2) {
              const currentDiagnostics = this._data.get(uri);
              if (currentDiagnostics) {
                currentDiagnostics.length = 0;
              }
            } else {
              const currentDiagnostics = this._data.get(uri);
              currentDiagnostics == null ? void 0 : currentDiagnostics.push(...diagnostics2);
            }
          }
        }
        this._onDidChangeDiagnostics.fire({ uris: toSync });
      }
      delete(uri) {
        this._checkDisposed();
        this._onDidChangeDiagnostics.fire({ uris: [uri] });
        this._data.delete(uri);
      }
      clear() {
        this._checkDisposed();
        this._onDidChangeDiagnostics.fire({ uris: [...this.keys()] });
        this._data.clear();
      }
      forEach(callback, thisArg) {
        this._checkDisposed();
        for (const [uri, values] of this) {
          callback.call(thisArg, uri, values, this);
        }
      }
      *[Symbol.iterator]() {
        this._checkDisposed();
        for (const uri of this.keys()) {
          yield [uri, this.get(uri)];
        }
      }
      get(uri) {
        this._checkDisposed();
        const result = this._data.get(uri);
        if (Array.isArray(result)) {
          return Object.freeze(result.slice(0));
        }
        return [];
      }
      has(uri) {
        this._checkDisposed();
        return Array.isArray(this._data.get(uri));
      }
      _checkDisposed() {
        if (this._isDisposed) {
          throw new Error("illegal state - object is disposed");
        }
      }
      keys() {
        const keys = [];
        for (const { resource } of this._data.entries()) {
          keys.push(resource);
        }
        return keys;
      }
      static _compareIndexedTuplesByUri(a, b) {
        if (a[0].toString() < b[0].toString()) {
          return -1;
        } else if (a[0].toString() > b[0].toString()) {
          return 1;
        } else {
          return 0;
        }
      }
    };
  }
});

// src/shims/extensions.ts
import { Emitter as Emitter4 } from "vscode-languageserver-protocol";
function createExtensionsShim() {
  return {
    onDidChange: new Emitter4().event,
    all: [],
    getExtension() {
      return void 0;
    }
  };
}
var init_extensions = __esm({
  "src/shims/extensions.ts"() {
    "use strict";
  }
});

// src/utils/barrier.ts
var Barrier;
var init_barrier = __esm({
  "src/utils/barrier.ts"() {
    "use strict";
    Barrier = class {
      constructor() {
        this._isOpen = false;
        this._promise = new Promise((v) => {
          this._completePromise = v;
        });
      }
      isOpen() {
        return this._isOpen;
      }
      open(value) {
        this._isOpen = true;
        this._completePromise(value);
      }
      wait() {
        return this._promise;
      }
    };
  }
});

// src/shims/selector.ts
function score(selector, document) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter of selector) {
      const value = score(filter, document);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === document.languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    const { language, scheme } = selector;
    let ret = 0;
    if (scheme) {
      if (scheme === document.uri.scheme) {
        ret = 10;
      } else if (scheme === "*") {
        ret = 5;
      } else {
        return 0;
      }
    }
    if (language) {
      if (language === document.languageId) {
        ret = 10;
      } else if (language === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
var init_selector = __esm({
  "src/shims/selector.ts"() {
    "use strict";
  }
});

// src/shims/languageFeatures.ts
import * as lsp3 from "vscode-languageserver-protocol";
var LanguageFeatureRegistry, CodeActionProviderRegistry, CompletionProviderRegistry, ProviderNotFoundError, LanguageFeaturesRegistryStore, LanguageFeaturesShimService;
var init_languageFeatures = __esm({
  "src/shims/languageFeatures.ts"() {
    "use strict";
    init_barrier();
    init_dispose2();
    init_selector();
    LanguageFeatureRegistry = class extends Disposable {
      constructor(featureId) {
        super();
        this.featureId = featureId;
        this.entries = /* @__PURE__ */ new Map();
      }
      register(id, registry) {
        this.entries.set(id, registry);
        return this._register(lsp3.Disposable.create(() => this.entries.delete(id)));
      }
      [Symbol.iterator]() {
        return this.entries[Symbol.iterator]();
      }
    };
    CodeActionProviderRegistry = class extends LanguageFeatureRegistry {
      constructor() {
        super("codeAction");
      }
    };
    CompletionProviderRegistry = class extends LanguageFeatureRegistry {
      constructor() {
        super("completion");
      }
    };
    ProviderNotFoundError = class extends Error {
      constructor(providerFeature) {
        super(
          `Cannot find provider for ${providerFeature}, the feature is possibly not supported by the current TypeScript version or disabled by settings.`
        );
        this.providerFeature = providerFeature;
      }
    };
    LanguageFeaturesRegistryStore = class extends Disposable {
      constructor() {
        super(...arguments);
        this.callHierarchy = this._register(
          new LanguageFeatureRegistry("callHierarchy")
        );
        this.codeActions = this._register(new CodeActionProviderRegistry());
        this.codeLens = this._register(
          new LanguageFeatureRegistry("codeLens")
        );
        this.completionItem = this._register(new CompletionProviderRegistry());
        this.declaration = this._register(
          new LanguageFeatureRegistry("declaration")
        );
        this.definition = this._register(
          new LanguageFeatureRegistry("definition")
        );
        this.documentFormattingEdit = this._register(
          new LanguageFeatureRegistry("documentFormatting")
        );
        this.documentHighlight = this._register(
          new LanguageFeatureRegistry("documentHighlight")
        );
        this.documentLink = this._register(
          new LanguageFeatureRegistry("documentLink")
        );
        this.documentRangeFormattingEdit = this._register(
          new LanguageFeatureRegistry(
            "documentRangeFormatting"
          )
        );
        this.documentRangeSemanticTokens = this._register(
          new LanguageFeatureRegistry(
            "documentRangeSemanticTokens"
          )
        );
        this.documentSymbol = this._register(
          new LanguageFeatureRegistry("documentSymbol")
        );
        this.documentSemanticTokens = this._register(
          new LanguageFeatureRegistry("documentSemanticTokens")
        );
        this.foldingRange = this._register(
          new LanguageFeatureRegistry("foldingRange")
        );
        this.hover = this._register(new LanguageFeatureRegistry("hover"));
        this.implementation = this._register(
          new LanguageFeatureRegistry("implementation")
        );
        this.inlayHints = this._register(
          new LanguageFeatureRegistry("inlayHints")
        );
        this.onTypeFormatting = this._register(
          new LanguageFeatureRegistry("onTypeFormatting")
        );
        this.linkedEditingRange = this._register(
          new LanguageFeatureRegistry("linkedEditingRange")
        );
        this.reference = this._register(
          new LanguageFeatureRegistry("reference")
        );
        this.rename = this._register(new LanguageFeatureRegistry("rename"));
        this.selectionRange = this._register(
          new LanguageFeatureRegistry("selectionRange")
        );
        this.signatureHelp = this._register(
          new LanguageFeatureRegistry(
            "signatureHelp"
          )
        );
        this.typeDefinition = this._register(
          new LanguageFeatureRegistry("typeDefinition")
        );
        this.typeHierarchy = this._register(
          new LanguageFeatureRegistry("typeHierarchy")
        );
        this.workspaceSymbol = this._register(
          new LanguageFeatureRegistry("workspaceSymbol")
        );
      }
      $getProviders(doc, providers) {
        const scoreWithProviders = [];
        for (const [id, reg] of providers) {
          const { provider, selector, ...args } = reg;
          scoreWithProviders.push({
            id,
            score: score(selector, doc),
            provider,
            args
          });
        }
        return scoreWithProviders.filter(({ score: score2 }) => score2 > 0).sort(({ score: a }, { score: b }) => a - b);
      }
      $getHighestProvider(doc, providers) {
        const all = this.$getProviders(doc, providers);
        if (!Array.isArray(all) || all.length === 0) {
          throw new ProviderNotFoundError(providers.featureId);
        }
        return all[0];
      }
      $getProviderById(id, providers) {
        for (const [providerId, entry] of providers) {
          if (id === providerId) {
            return entry;
          }
        }
        throw new ProviderNotFoundError(providers.featureId);
      }
      $getProviderWithoutSelector(providers) {
        for (const [id, entry] of providers) {
          return { id, ...entry };
        }
        throw new ProviderNotFoundError(providers.featureId);
      }
      $withRegistry(registry) {
        const store = this;
        return {
          getProviders(doc) {
            return store.$getProviders(doc, registry);
          },
          getProviderById(id) {
            return store.$getProviderById(id, registry);
          },
          getHighestProvider(doc) {
            return store.$getHighestProvider(doc, registry);
          }
        };
      }
    };
    LanguageFeaturesShimService = class extends Disposable {
      constructor(delegate, diagnostics) {
        super();
        this.diagnostics = diagnostics;
        this._registryStore = this._register(new LanguageFeaturesRegistryStore());
        this.onDidChangeDiagnostics = this.diagnostics.onDidChangeDiagnostics.event;
        // only for capturing registration timing for initialization
        // ref: patches/020-trigger-features-registered-event.patch
        this.$staticFeaturesRegistered = new Barrier();
        this._idGen = 0;
        this._register(
          this.onDidChangeDiagnostics((e) => {
            for (const uri of e.uris) {
              const diagnostics2 = this.getDiagnostics(uri);
              if (Array.isArray(diagnostics2)) {
                delegate.publishDiagnostics(
                  uri.toString(),
                  diagnostics2.map(delegate.converter.convertDiagnosticToLsp)
                );
              }
            }
          })
        );
      }
      $triggerStaticFeaturesRegistered() {
        this.$staticFeaturesRegistered.open();
      }
      createDiagnosticCollection(name) {
        return this.diagnostics.createDiagnosticCollection(name);
      }
      getDiagnostics(resource) {
        return this.diagnostics.getDiagnostics(resource);
      }
      get $providers() {
        return this._registryStore;
      }
      registerProvider(collection, entry) {
        const id = this._idGen++;
        return collection.register(id, entry);
      }
      registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
        return this.registerProvider(this._registryStore.completionItem, {
          selector,
          provider,
          triggerCharacters
        });
      }
      registerCodeActionsProvider(selector, provider, metadata) {
        return this.registerProvider(this._registryStore.codeActions, {
          selector,
          provider,
          metadata
        });
      }
      registerCodeLensProvider(selector, provider) {
        return this.registerProvider(this._registryStore.codeLens, {
          selector,
          provider
        });
      }
      registerDefinitionProvider(selector, provider) {
        return this.registerProvider(this._registryStore.definition, {
          selector,
          provider
        });
      }
      registerImplementationProvider(selector, provider) {
        return this.registerProvider(this._registryStore.implementation, {
          selector,
          provider
        });
      }
      registerTypeDefinitionProvider(selector, provider) {
        return this.registerProvider(this._registryStore.typeDefinition, {
          selector,
          provider
        });
      }
      registerDeclarationProvider(selector, provider) {
        return this.registerProvider(this._registryStore.declaration, { selector, provider });
      }
      registerHoverProvider(selector, provider) {
        return this.registerProvider(this._registryStore.hover, { selector, provider });
      }
      registerDocumentHighlightProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentHighlight, {
          selector,
          provider
        });
      }
      // TODO: not available in LSP yet
      registerMultiDocumentHighlightProvider() {
      }
      registerDocumentSymbolProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentSymbol, {
          selector,
          provider
        });
      }
      registerWorkspaceSymbolProvider(provider) {
        return this.registerProvider(this._registryStore.workspaceSymbol, { provider, selector: "*" });
      }
      registerReferenceProvider(selector, provider) {
        return this.registerProvider(this._registryStore.reference, { selector, provider });
      }
      registerRenameProvider(selector, provider) {
        return this.registerProvider(this._registryStore.rename, { selector, provider });
      }
      registerDocumentSemanticTokensProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentSemanticTokens, {
          selector,
          provider
        });
      }
      registerDocumentRangeSemanticTokensProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentRangeSemanticTokens, {
          selector,
          provider
        });
      }
      registerDocumentFormattingEditProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentFormattingEdit, {
          selector,
          provider
        });
      }
      registerDocumentRangeFormattingEditProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentRangeFormattingEdit, {
          selector,
          provider
        });
      }
      registerSignatureHelpProvider(selector, provider, metadata) {
        return this.registerProvider(this._registryStore.signatureHelp, {
          selector,
          provider,
          ...metadata
        });
      }
      registerDocumentLinkProvider(selector, provider) {
        return this.registerProvider(this._registryStore.documentLink, { selector, provider });
      }
      registerInlayHintsProvider(selector, provider) {
        return this.registerProvider(this._registryStore.inlayHints, { selector, provider });
      }
      registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacter) {
        return this.registerProvider(this._registryStore.onTypeFormatting, {
          selector,
          provider,
          firstTriggerCharacter,
          moreTriggerCharacter
        });
      }
      registerFoldingRangeProvider(selector, provider) {
        return this.registerProvider(this._registryStore.foldingRange, { selector, provider });
      }
      registerSelectionRangeProvider(selector, provider) {
        return this.registerProvider(this._registryStore.selectionRange, {
          selector,
          provider
        });
      }
      registerCallHierarchyProvider(selector, provider) {
        return this.registerProvider(this._registryStore.callHierarchy, {
          selector,
          provider
        });
      }
      registerTypeHierarchyProvider(selector, provider) {
        return this.registerProvider(this._registryStore.typeHierarchy, {
          selector,
          provider
        });
      }
      registerLinkedEditingRangeProvider(selector, provider) {
        return this.registerProvider(this._registryStore.linkedEditingRange, {
          selector,
          provider
        });
      }
      match(selector, doc) {
        return score(selector, doc);
      }
    };
  }
});

// src/shims/types.ts
import { URI as URI4 } from "vscode-uri";
function escapeMarkdownSyntaxTokens(text) {
  return text.replace(/[\\`*_{}[\]()#+\-!]/g, "\\$&");
}
function isStrArrayOrUndefined(arg) {
  return typeof arg === "undefined" || !arg.some((s) => s ? typeof s !== "string" : false);
}
function illegalArgument(name) {
  if (name) {
    return new Error(`Illegal argument: ${name}`);
  } else {
    return new Error("Illegal argument");
  }
}
function coalesceInPlace(array) {
  let to = 0;
  for (let i = 0; i < array.length; i++) {
    if (!!array[i]) {
      array[to] = array[i];
      to += 1;
    }
  }
  array.length = to;
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
var Disposable4, Position, Range, Selection, TextEdit, SnippetTextEdit, WorkspaceEdit, SnippetString, DiagnosticSeverity, Location, DiagnosticRelatedInformation, Diagnostic, Hover, VerboseHover, DocumentHighlightKind, DocumentHighlight, MultiDocumentHighlight, SymbolKind, SymbolInformation, DocumentSymbol, CodeAction, _CodeActionKind, CodeActionKind, SelectionRange, CallHierarchyItem, CallHierarchyIncomingCall, CallHierarchyOutgoingCall, CodeLens, BaseMarkdownString, MarkdownString, ParameterInformation, SignatureInformation, SignatureHelp, InlayHintLabelPart, InlayHint, CompletionItemKind, CompletionItem, CompletionList, TextEditorSelectionChangeKind, DataTransferItem, _DocumentDropOrPasteEditKind, DocumentDropOrPasteEditKind, DocumentPasteEdit, RelativePattern, FoldingRange, SemanticTokensLegend, SemanticTokensBuilder, SemanticTokens, LinkedEditingRanges, TabInputText, TabInputTextDiff, TabInputNotebook, CancellationError;
var init_types2 = __esm({
  "src/shims/types.ts"() {
    "use strict";
    init_fs();
    init_objects2();
    init_resourceMap2();
    init_uuid();
    Disposable4 = class _Disposable {
      static from(...inDisposables) {
        let disposables = inDisposables;
        return new _Disposable(function() {
          if (disposables) {
            for (const disposable of disposables) {
              if (disposable && typeof disposable.dispose === "function") {
                disposable.dispose();
              }
            }
            disposables = void 0;
          }
        });
      }
      #callOnDispose;
      constructor(callOnDispose) {
        this.#callOnDispose = callOnDispose;
      }
      dispose() {
        if (typeof this.#callOnDispose === "function") {
          this.#callOnDispose();
          this.#callOnDispose = void 0;
        }
      }
    };
    Position = class _Position {
      static Min(...positions) {
        if (positions.length === 0) {
          throw new TypeError();
        }
        let result = positions[0];
        for (let i = 1; i < positions.length; i++) {
          const p = positions[i];
          if (p.isBefore(result)) {
            result = p;
          }
        }
        return result;
      }
      static Max(...positions) {
        if (positions.length === 0) {
          throw new TypeError();
        }
        let result = positions[0];
        for (let i = 1; i < positions.length; i++) {
          const p = positions[i];
          if (p.isAfter(result)) {
            result = p;
          }
        }
        return result;
      }
      static isPosition(other) {
        if (!other) {
          return false;
        }
        if (other instanceof _Position) {
          return true;
        }
        const { line, character } = other;
        if (typeof line === "number" && typeof character === "number") {
          return true;
        }
        return false;
      }
      static of(obj) {
        if (obj instanceof _Position) {
          return obj;
        } else if (this.isPosition(obj)) {
          return new _Position(obj.line, obj.character);
        }
        throw new Error("Invalid argument, is NOT a position-like object");
      }
      get line() {
        return this._line;
      }
      get character() {
        return this._character;
      }
      constructor(line, character) {
        if (line < 0) {
          throw illegalArgument("line must be non-negative");
        }
        if (character < 0) {
          throw illegalArgument("character must be non-negative");
        }
        this._line = line;
        this._character = character;
      }
      isBefore(other) {
        if (this._line < other._line) {
          return true;
        }
        if (other._line < this._line) {
          return false;
        }
        return this._character < other._character;
      }
      isBeforeOrEqual(other) {
        if (this._line < other._line) {
          return true;
        }
        if (other._line < this._line) {
          return false;
        }
        return this._character <= other._character;
      }
      isAfter(other) {
        return !this.isBeforeOrEqual(other);
      }
      isAfterOrEqual(other) {
        return !this.isBefore(other);
      }
      isEqual(other) {
        return this._line === other._line && this._character === other._character;
      }
      compareTo(other) {
        if (this._line < other._line) {
          return -1;
        } else if (this._line > other.line) {
          return 1;
        } else {
          if (this._character < other._character) {
            return -1;
          } else if (this._character > other._character) {
            return 1;
          } else {
            return 0;
          }
        }
      }
      translate(lineDeltaOrChange, characterDelta = 0) {
        if (lineDeltaOrChange === null || characterDelta === null) {
          throw illegalArgument();
        }
        let lineDelta;
        if (typeof lineDeltaOrChange === "undefined") {
          lineDelta = 0;
        } else if (typeof lineDeltaOrChange === "number") {
          lineDelta = lineDeltaOrChange;
        } else {
          lineDelta = typeof lineDeltaOrChange.lineDelta === "number" ? lineDeltaOrChange.lineDelta : 0;
          characterDelta = typeof lineDeltaOrChange.characterDelta === "number" ? lineDeltaOrChange.characterDelta : 0;
        }
        if (lineDelta === 0 && characterDelta === 0) {
          return this;
        }
        return new _Position(this.line + lineDelta, this.character + characterDelta);
      }
      with(lineOrChange, character = this.character) {
        if (lineOrChange === null || character === null) {
          throw illegalArgument();
        }
        let line;
        if (typeof lineOrChange === "undefined") {
          line = this.line;
        } else if (typeof lineOrChange === "number") {
          line = lineOrChange;
        } else {
          line = typeof lineOrChange.line === "number" ? lineOrChange.line : this.line;
          character = typeof lineOrChange.character === "number" ? lineOrChange.character : this.character;
        }
        if (line === this.line && character === this.character) {
          return this;
        }
        return new _Position(line, character);
      }
      toJSON() {
        return { line: this.line, character: this.character };
      }
    };
    Range = class _Range {
      static isRange(thing) {
        if (thing instanceof _Range) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return Position.isPosition(thing.start) && Position.isPosition(thing.end);
      }
      static of(obj) {
        if (obj instanceof _Range) {
          return obj;
        }
        if (this.isRange(obj)) {
          return new _Range(obj.start, obj.end);
        }
        throw new Error("Invalid argument, is NOT a range-like object");
      }
      get start() {
        return this._start;
      }
      get end() {
        return this._end;
      }
      constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
        let start;
        let end;
        if (typeof startLineOrStart === "number" && typeof startColumnOrEnd === "number" && typeof endLine === "number" && typeof endColumn === "number") {
          start = new Position(startLineOrStart, startColumnOrEnd);
          end = new Position(endLine, endColumn);
        } else if (Position.isPosition(startLineOrStart) && Position.isPosition(startColumnOrEnd)) {
          start = Position.of(startLineOrStart);
          end = Position.of(startColumnOrEnd);
        }
        if (!start || !end) {
          throw new Error("Invalid arguments");
        }
        if (start.isBefore(end)) {
          this._start = start;
          this._end = end;
        } else {
          this._start = end;
          this._end = start;
        }
      }
      contains(positionOrRange) {
        if (_Range.isRange(positionOrRange)) {
          return this.contains(positionOrRange.start) && this.contains(positionOrRange.end);
        } else if (Position.isPosition(positionOrRange)) {
          if (Position.of(positionOrRange).isBefore(this._start)) {
            return false;
          }
          if (this._end.isBefore(positionOrRange)) {
            return false;
          }
          return true;
        }
        return false;
      }
      isEqual(other) {
        return this._start.isEqual(other._start) && this._end.isEqual(other._end);
      }
      intersection(other) {
        const start = Position.Max(other.start, this._start);
        const end = Position.Min(other.end, this._end);
        if (start.isAfter(end)) {
          return void 0;
        }
        return new _Range(start, end);
      }
      union(other) {
        if (this.contains(other)) {
          return this;
        } else if (other.contains(this)) {
          return other;
        }
        const start = Position.Min(other.start, this._start);
        const end = Position.Max(other.end, this.end);
        return new _Range(start, end);
      }
      get isEmpty() {
        return this._start.isEqual(this._end);
      }
      get isSingleLine() {
        return this._start.line === this._end.line;
      }
      with(startOrChange, end = this.end) {
        if (startOrChange === null || end === null) {
          throw illegalArgument();
        }
        let start;
        if (!startOrChange) {
          start = this.start;
        } else if (Position.isPosition(startOrChange)) {
          start = startOrChange;
        } else {
          start = startOrChange.start || this.start;
          end = startOrChange.end || this.end;
        }
        if (start.isEqual(this._start) && end.isEqual(this.end)) {
          return this;
        }
        return new _Range(start, end);
      }
      toJSON() {
        return [this.start, this.end];
      }
    };
    Selection = class _Selection extends Range {
      static isSelection(thing) {
        if (thing instanceof _Selection) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return Range.isRange(thing) && Position.isPosition(thing.anchor) && Position.isPosition(thing.active) && typeof thing.isReversed === "boolean";
      }
      get anchor() {
        return this._anchor;
      }
      get active() {
        return this._active;
      }
      constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
        let anchor;
        let active;
        if (typeof anchorLineOrAnchor === "number" && typeof anchorColumnOrActive === "number" && typeof activeLine === "number" && typeof activeColumn === "number") {
          anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
          active = new Position(activeLine, activeColumn);
        } else if (Position.isPosition(anchorLineOrAnchor) && Position.isPosition(anchorColumnOrActive)) {
          anchor = Position.of(anchorLineOrAnchor);
          active = Position.of(anchorColumnOrActive);
        }
        if (!anchor || !active) {
          throw new Error("Invalid arguments");
        }
        super(anchor, active);
        this._anchor = anchor;
        this._active = active;
      }
      get isReversed() {
        return this._anchor === this._end;
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end,
          active: this.active,
          anchor: this.anchor
        };
      }
    };
    TextEdit = class _TextEdit {
      static isTextEdit(thing) {
        if (thing instanceof _TextEdit) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return Range.isRange(thing) && typeof thing.newText === "string";
      }
      static replace(range, newText) {
        return new _TextEdit(range, newText);
      }
      static insert(position, newText) {
        return _TextEdit.replace(new Range(position, position), newText);
      }
      static delete(range) {
        return _TextEdit.replace(range, "");
      }
      static setEndOfLine(eol) {
        const ret = new _TextEdit(new Range(new Position(0, 0), new Position(0, 0)), "");
        ret.newEol = eol;
        return ret;
      }
      get range() {
        return this._range;
      }
      set range(value) {
        if (value && !Range.isRange(value)) {
          throw illegalArgument("range");
        }
        this._range = value;
      }
      get newText() {
        return this._newText || "";
      }
      set newText(value) {
        if (value && typeof value !== "string") {
          throw illegalArgument("newText");
        }
        this._newText = value;
      }
      get newEol() {
        return this._newEol;
      }
      set newEol(value) {
        if (value && typeof value !== "number") {
          throw illegalArgument("newEol");
        }
        this._newEol = value;
      }
      constructor(range, newText) {
        this._range = range;
        this._newText = newText;
      }
      toJSON() {
        return {
          range: this.range,
          newText: this.newText,
          newEol: this._newEol
        };
      }
    };
    SnippetTextEdit = class _SnippetTextEdit {
      static isSnippetTextEdit(thing) {
        if (thing instanceof _SnippetTextEdit) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return Range.isRange(thing.range) && SnippetString.isSnippetString(thing.snippet);
      }
      static replace(range, snippet) {
        return new _SnippetTextEdit(range, snippet);
      }
      static insert(position, snippet) {
        return _SnippetTextEdit.replace(new Range(position, position), snippet);
      }
      constructor(range, snippet) {
        this.range = range;
        this.snippet = snippet;
      }
    };
    WorkspaceEdit = class {
      constructor() {
        this._edits = [];
      }
      _allEntries() {
        return this._edits;
      }
      // --- file
      renameFile(from, to, options, metadata) {
        this._edits.push({ _type: 1 /* File */, from, to, options, metadata });
      }
      createFile(uri, options, metadata) {
        this._edits.push({ _type: 1 /* File */, from: void 0, to: uri, options, metadata });
      }
      deleteFile(uri, options, metadata) {
        this._edits.push({ _type: 1 /* File */, from: uri, to: void 0, options, metadata });
      }
      // --- text
      replace(uri, range, newText, metadata) {
        this._edits.push({ _type: 2 /* Text */, uri, edit: new TextEdit(range, newText), metadata });
      }
      insert(resource, position, newText, metadata) {
        this.replace(resource, new Range(position, position), newText, metadata);
      }
      delete(resource, range, metadata) {
        this.replace(resource, range, "", metadata);
      }
      // --- text (Maplike)
      has(uri) {
        return this._edits.some((edit) => edit._type === 2 /* Text */ && edit.uri.toString() === uri.toString());
      }
      set(uri, edits) {
        if (!edits) {
          for (let i = 0; i < this._edits.length; i++) {
            const element = this._edits[i];
            switch (element._type) {
              case 2 /* Text */:
              case 6 /* Snippet */:
              case 3 /* Cell */:
              case 5 /* CellReplace */:
                if (element.uri.toString() === uri.toString()) {
                  this._edits[i] = void 0;
                }
                break;
            }
          }
          coalesceInPlace(this._edits);
        } else {
          for (const editOrTuple of edits) {
            if (!editOrTuple) {
              continue;
            }
            let edit;
            let metadata;
            if (Array.isArray(editOrTuple)) {
              edit = editOrTuple[0];
              metadata = editOrTuple[1];
            } else {
              edit = editOrTuple;
            }
            if (SnippetTextEdit.isSnippetTextEdit(edit)) {
              this._edits.push({ _type: 6 /* Snippet */, uri, range: edit.range, edit: edit.snippet, metadata });
            } else {
              this._edits.push({ _type: 2 /* Text */, uri, edit, metadata });
            }
          }
        }
      }
      get(uri) {
        const res = [];
        for (const candidate of this._edits) {
          if (candidate._type === 2 /* Text */ && candidate.uri.toString() === uri.toString()) {
            res.push(candidate.edit);
          }
        }
        return res;
      }
      entries() {
        const textEdits = new ResourceMap(void 0, {
          onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem()
        });
        for (const candidate of this._edits) {
          if (candidate._type === 2 /* Text */) {
            let textEdit = textEdits.get(candidate.uri);
            if (!textEdit) {
              textEdit = [candidate.uri, []];
              textEdits.set(candidate.uri, textEdit);
            }
            textEdit[1].push(candidate.edit);
          }
        }
        return [...textEdits.values()];
      }
      get size() {
        return this.entries().length;
      }
      toJSON() {
        return this.entries();
      }
    };
    SnippetString = class _SnippetString {
      constructor(value) {
        this._tabstop = 1;
        this.value = value || "";
      }
      static isSnippetString(thing) {
        if (thing instanceof _SnippetString) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.value === "string";
      }
      static _escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      appendText(string) {
        this.value += _SnippetString._escape(string);
        return this;
      }
      appendTabstop(number = this._tabstop++) {
        this.value += "$";
        this.value += number;
        return this;
      }
      appendPlaceholder(value, number = this._tabstop++) {
        if (typeof value === "function") {
          const nested = new _SnippetString();
          nested._tabstop = this._tabstop;
          value(nested);
          this._tabstop = nested._tabstop;
          value = nested.value;
        } else {
          value = _SnippetString._escape(value);
        }
        this.value += "${";
        this.value += number;
        this.value += ":";
        this.value += value;
        this.value += "}";
        return this;
      }
      appendChoice(values, number = this._tabstop++) {
        const value = values.map((s) => s.replace(/\$|}|\\|,/g, "\\$&")).join(",");
        this.value += "${";
        this.value += number;
        this.value += "|";
        this.value += value;
        this.value += "|}";
        return this;
      }
      appendVariable(name, defaultValue) {
        if (typeof defaultValue === "function") {
          const nested = new _SnippetString();
          nested._tabstop = this._tabstop;
          defaultValue(nested);
          this._tabstop = nested._tabstop;
          defaultValue = nested.value;
        } else if (typeof defaultValue === "string") {
          defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
        }
        this.value += "${";
        this.value += name;
        if (defaultValue) {
          this.value += ":";
          this.value += defaultValue;
        }
        this.value += "}";
        return this;
      }
    };
    DiagnosticSeverity = /* @__PURE__ */ ((DiagnosticSeverity2) => {
      DiagnosticSeverity2[DiagnosticSeverity2["Hint"] = 3] = "Hint";
      DiagnosticSeverity2[DiagnosticSeverity2["Information"] = 2] = "Information";
      DiagnosticSeverity2[DiagnosticSeverity2["Warning"] = 1] = "Warning";
      DiagnosticSeverity2[DiagnosticSeverity2["Error"] = 0] = "Error";
      return DiagnosticSeverity2;
    })(DiagnosticSeverity || {});
    Location = class _Location {
      static isLocation(thing) {
        if (thing instanceof _Location) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return Range.isRange(thing.range) && URI4.isUri(thing.uri);
      }
      constructor(uri, rangeOrPosition) {
        this.uri = uri;
        if (!rangeOrPosition) {
        } else if (Range.isRange(rangeOrPosition)) {
          this.range = Range.of(rangeOrPosition);
        } else if (Position.isPosition(rangeOrPosition)) {
          this.range = new Range(rangeOrPosition, rangeOrPosition);
        } else {
          throw new Error("Illegal argument");
        }
      }
      toJSON() {
        return {
          uri: this.uri,
          range: this.range
        };
      }
    };
    DiagnosticRelatedInformation = class {
      static is(thing) {
        if (!thing) {
          return false;
        }
        return typeof thing.message === "string" && thing.location && Range.isRange(thing.location.range) && URI4.isUri(thing.location.uri);
      }
      constructor(location, message) {
        this.location = location;
        this.message = message;
      }
      static isEqual(a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return a.message === b.message && a.location.range.isEqual(b.location.range) && a.location.uri.toString() === b.location.uri.toString();
      }
    };
    Diagnostic = class {
      constructor(range, message, severity = 0 /* Error */) {
        if (!Range.isRange(range)) {
          throw new TypeError("range must be set");
        }
        if (!message) {
          throw new TypeError("message must be set");
        }
        this.range = range;
        this.message = message;
        this.severity = severity;
      }
      toJSON() {
        return {
          severity: DiagnosticSeverity[this.severity],
          message: this.message,
          range: this.range,
          source: this.source,
          code: this.code
        };
      }
      static isEqual(a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return a.message === b.message && a.severity === b.severity && a.code === b.code && a.severity === b.severity && a.source === b.source && a.range.isEqual(b.range) && equals2(a.tags, b.tags) && equals2(a.relatedInformation, b.relatedInformation);
      }
    };
    Hover = class {
      constructor(contents, range) {
        if (!contents) {
          throw new Error("Illegal argument, contents must be defined");
        }
        if (Array.isArray(contents)) {
          this.contents = contents;
        } else {
          this.contents = [contents];
        }
        this.range = range;
      }
    };
    VerboseHover = class extends Hover {
      constructor(contents, range, canIncreaseVerbosity, canDecreaseVerbosity) {
        super(contents, range);
        this.canIncreaseVerbosity = canIncreaseVerbosity;
        this.canDecreaseVerbosity = canDecreaseVerbosity;
      }
    };
    DocumentHighlightKind = /* @__PURE__ */ ((DocumentHighlightKind2) => {
      DocumentHighlightKind2[DocumentHighlightKind2["Text"] = 0] = "Text";
      DocumentHighlightKind2[DocumentHighlightKind2["Read"] = 1] = "Read";
      DocumentHighlightKind2[DocumentHighlightKind2["Write"] = 2] = "Write";
      return DocumentHighlightKind2;
    })(DocumentHighlightKind || {});
    DocumentHighlight = class {
      constructor(range, kind = 0 /* Text */) {
        this.range = range;
        this.kind = kind;
      }
      toJSON() {
        return {
          range: this.range,
          kind: DocumentHighlightKind[this.kind]
        };
      }
    };
    MultiDocumentHighlight = class {
      constructor(uri, highlights) {
        this.uri = uri;
        this.highlights = highlights;
      }
      toJSON() {
        return {
          uri: this.uri,
          highlights: this.highlights.map((h) => h.toJSON())
        };
      }
    };
    SymbolKind = /* @__PURE__ */ ((SymbolKind3) => {
      SymbolKind3[SymbolKind3["File"] = 0] = "File";
      SymbolKind3[SymbolKind3["Module"] = 1] = "Module";
      SymbolKind3[SymbolKind3["Namespace"] = 2] = "Namespace";
      SymbolKind3[SymbolKind3["Package"] = 3] = "Package";
      SymbolKind3[SymbolKind3["Class"] = 4] = "Class";
      SymbolKind3[SymbolKind3["Method"] = 5] = "Method";
      SymbolKind3[SymbolKind3["Property"] = 6] = "Property";
      SymbolKind3[SymbolKind3["Field"] = 7] = "Field";
      SymbolKind3[SymbolKind3["Constructor"] = 8] = "Constructor";
      SymbolKind3[SymbolKind3["Enum"] = 9] = "Enum";
      SymbolKind3[SymbolKind3["Interface"] = 10] = "Interface";
      SymbolKind3[SymbolKind3["Function"] = 11] = "Function";
      SymbolKind3[SymbolKind3["Variable"] = 12] = "Variable";
      SymbolKind3[SymbolKind3["Constant"] = 13] = "Constant";
      SymbolKind3[SymbolKind3["String"] = 14] = "String";
      SymbolKind3[SymbolKind3["Number"] = 15] = "Number";
      SymbolKind3[SymbolKind3["Boolean"] = 16] = "Boolean";
      SymbolKind3[SymbolKind3["Array"] = 17] = "Array";
      SymbolKind3[SymbolKind3["Object"] = 18] = "Object";
      SymbolKind3[SymbolKind3["Key"] = 19] = "Key";
      SymbolKind3[SymbolKind3["Null"] = 20] = "Null";
      SymbolKind3[SymbolKind3["EnumMember"] = 21] = "EnumMember";
      SymbolKind3[SymbolKind3["Struct"] = 22] = "Struct";
      SymbolKind3[SymbolKind3["Event"] = 23] = "Event";
      SymbolKind3[SymbolKind3["Operator"] = 24] = "Operator";
      SymbolKind3[SymbolKind3["TypeParameter"] = 25] = "TypeParameter";
      return SymbolKind3;
    })(SymbolKind || {});
    SymbolInformation = class _SymbolInformation {
      static validate(candidate) {
        if (!candidate.name) {
          throw new Error("name must not be falsy");
        }
      }
      constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {
        this.name = name;
        this.kind = kind;
        this.containerName = containerName;
        if (typeof rangeOrContainer === "string") {
          this.containerName = rangeOrContainer;
        }
        if (locationOrUri instanceof Location) {
          this.location = locationOrUri;
        } else if (rangeOrContainer instanceof Range) {
          this.location = new Location(locationOrUri, rangeOrContainer);
        }
        _SymbolInformation.validate(this);
      }
      toJSON() {
        return {
          name: this.name,
          kind: SymbolKind[this.kind],
          location: this.location,
          containerName: this.containerName
        };
      }
    };
    DocumentSymbol = class _DocumentSymbol {
      static validate(candidate) {
        var _a;
        if (!candidate.name) {
          throw new Error("name must not be falsy");
        }
        if (!candidate.range.contains(candidate.selectionRange)) {
          throw new Error("selectionRange must be contained in fullRange");
        }
        (_a = candidate.children) == null ? void 0 : _a.forEach(_DocumentSymbol.validate);
      }
      constructor(name, detail, kind, range, selectionRange) {
        this.name = name;
        this.detail = detail;
        this.kind = kind;
        this.range = range;
        this.selectionRange = selectionRange;
        this.children = [];
        _DocumentSymbol.validate(this);
      }
    };
    CodeAction = class {
      constructor(title, kind) {
        this.title = title;
        this.kind = kind;
      }
    };
    _CodeActionKind = class _CodeActionKind {
      constructor(value) {
        this.value = value;
      }
      append(parts) {
        return new _CodeActionKind(this.value ? this.value + _CodeActionKind.sep + parts : parts);
      }
      intersects(other) {
        return this.contains(other) || other.contains(this);
      }
      contains(other) {
        return this.value === other.value || other.value.startsWith(this.value + _CodeActionKind.sep);
      }
    };
    _CodeActionKind.sep = ".";
    CodeActionKind = _CodeActionKind;
    CodeActionKind.Empty = new CodeActionKind("");
    CodeActionKind.QuickFix = CodeActionKind.Empty.append("quickfix");
    CodeActionKind.Refactor = CodeActionKind.Empty.append("refactor");
    CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append("extract");
    CodeActionKind.RefactorInline = CodeActionKind.Refactor.append("inline");
    CodeActionKind.RefactorMove = CodeActionKind.Refactor.append("move");
    CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append("rewrite");
    CodeActionKind.Source = CodeActionKind.Empty.append("source");
    CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
    CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
    SelectionRange = class {
      constructor(range, parent) {
        this.range = range;
        this.parent = parent;
        if (parent && !parent.range.contains(this.range)) {
          throw new Error("Invalid argument: parent must contain this range");
        }
      }
    };
    CallHierarchyItem = class {
      constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
      }
    };
    CallHierarchyIncomingCall = class {
      constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.from = item;
      }
    };
    CallHierarchyOutgoingCall = class {
      constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.to = item;
      }
    };
    CodeLens = class {
      constructor(range, command) {
        this.range = range;
        this.command = command;
      }
      get isResolved() {
        return !!this.command;
      }
    };
    BaseMarkdownString = class {
      constructor(value = "") {
        this.value = value;
        if (typeof this.value !== "string") {
          throw illegalArgument("value");
        }
        this.supportThemeIcons = false;
        this.supportHtml = true;
      }
      appendText(value, newlineStyle = 0 /* Paragraph */) {
        this.value += escapeMarkdownSyntaxTokens(value).replace(/([ \t]+)/g, (_match, g1) => "&nbsp;".repeat(g1.length)).replace(/\>/gm, "\\>").replace(/\n/g, newlineStyle === 1 /* Break */ ? "\\\n" : "\n\n");
        return this;
      }
      appendMarkdown(value) {
        this.value += value;
        return this;
      }
      appendCodeblock(langId, code) {
        this.value += "\n```";
        this.value += langId;
        this.value += "\n";
        this.value += code;
        this.value += "\n```\n";
        return this;
      }
      appendLink(target, label, title) {
        this.value += "[";
        this.value += this._escape(label, "]");
        this.value += "](";
        this.value += this._escape(String(target), ")");
        if (title) {
          this.value += ` "${this._escape(this._escape(title, '"'), ")")}"`;
        }
        this.value += ")";
        return this;
      }
      _escape(value, ch) {
        const r = new RegExp(escapeRegExpCharacters(ch), "g");
        return value.replace(r, (match, offset) => {
          if (value.charAt(offset - 1) !== "\\") {
            return `\\${match}`;
          } else {
            return match;
          }
        });
      }
    };
    MarkdownString = class _MarkdownString {
      #delegate;
      static isMarkdownString(thing) {
        if (thing instanceof _MarkdownString) {
          return true;
        }
        return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && thing.value !== void 0;
      }
      constructor(value) {
        this.#delegate = new BaseMarkdownString(value);
      }
      get value() {
        return this.#delegate.value;
      }
      set value(value) {
        this.#delegate.value = value;
      }
      get isTrusted() {
        return;
      }
      set isTrusted(value) {
        return;
      }
      get supportThemeIcons() {
        return this.#delegate.supportThemeIcons;
      }
      set supportThemeIcons(value) {
        this.#delegate.supportThemeIcons = value;
      }
      get supportHtml() {
        return this.#delegate.supportHtml;
      }
      set supportHtml(value) {
        this.#delegate.supportHtml = value;
      }
      get baseUri() {
        return this.#delegate.baseUri;
      }
      set baseUri(value) {
        this.#delegate.baseUri = value;
      }
      appendText(value) {
        this.#delegate.appendText(value);
        return this;
      }
      appendMarkdown(value) {
        this.#delegate.appendMarkdown(value);
        return this;
      }
      appendCodeblock(value, language) {
        this.#delegate.appendCodeblock(language ?? "", value);
        return this;
      }
    };
    ParameterInformation = class {
      constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
      }
    };
    SignatureInformation = class {
      constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
        this.parameters = [];
      }
    };
    SignatureHelp = class {
      constructor() {
        this.activeSignature = 0;
        this.activeParameter = 0;
        this.signatures = [];
      }
    };
    InlayHintLabelPart = class {
      constructor(value) {
        this.value = value;
      }
    };
    InlayHint = class {
      constructor(position, label, kind) {
        this.position = position;
        this.label = label;
        this.kind = kind;
      }
    };
    CompletionItemKind = /* @__PURE__ */ ((CompletionItemKind2) => {
      CompletionItemKind2[CompletionItemKind2["Text"] = 0] = "Text";
      CompletionItemKind2[CompletionItemKind2["Method"] = 1] = "Method";
      CompletionItemKind2[CompletionItemKind2["Function"] = 2] = "Function";
      CompletionItemKind2[CompletionItemKind2["Constructor"] = 3] = "Constructor";
      CompletionItemKind2[CompletionItemKind2["Field"] = 4] = "Field";
      CompletionItemKind2[CompletionItemKind2["Variable"] = 5] = "Variable";
      CompletionItemKind2[CompletionItemKind2["Class"] = 6] = "Class";
      CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
      CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
      CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
      CompletionItemKind2[CompletionItemKind2["Unit"] = 10] = "Unit";
      CompletionItemKind2[CompletionItemKind2["Value"] = 11] = "Value";
      CompletionItemKind2[CompletionItemKind2["Enum"] = 12] = "Enum";
      CompletionItemKind2[CompletionItemKind2["Keyword"] = 13] = "Keyword";
      CompletionItemKind2[CompletionItemKind2["Snippet"] = 14] = "Snippet";
      CompletionItemKind2[CompletionItemKind2["Color"] = 15] = "Color";
      CompletionItemKind2[CompletionItemKind2["File"] = 16] = "File";
      CompletionItemKind2[CompletionItemKind2["Reference"] = 17] = "Reference";
      CompletionItemKind2[CompletionItemKind2["Folder"] = 18] = "Folder";
      CompletionItemKind2[CompletionItemKind2["EnumMember"] = 19] = "EnumMember";
      CompletionItemKind2[CompletionItemKind2["Constant"] = 20] = "Constant";
      CompletionItemKind2[CompletionItemKind2["Struct"] = 21] = "Struct";
      CompletionItemKind2[CompletionItemKind2["Event"] = 22] = "Event";
      CompletionItemKind2[CompletionItemKind2["Operator"] = 23] = "Operator";
      CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
      CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
      CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
      return CompletionItemKind2;
    })(CompletionItemKind || {});
    CompletionItem = class {
      constructor(label, kind) {
        this.label = label;
        this.kind = kind;
      }
      toJSON() {
        return {
          label: this.label,
          kind: this.kind && CompletionItemKind[this.kind],
          detail: this.detail,
          documentation: this.documentation,
          sortText: this.sortText,
          filterText: this.filterText,
          preselect: this.preselect,
          insertText: this.insertText,
          textEdit: this.textEdit
        };
      }
    };
    CompletionList = class {
      constructor(items = [], isIncomplete = false) {
        this.items = items;
        this.isIncomplete = isIncomplete;
      }
    };
    TextEditorSelectionChangeKind = /* @__PURE__ */ ((TextEditorSelectionChangeKind2) => {
      TextEditorSelectionChangeKind2[TextEditorSelectionChangeKind2["Keyboard"] = 1] = "Keyboard";
      TextEditorSelectionChangeKind2[TextEditorSelectionChangeKind2["Mouse"] = 2] = "Mouse";
      TextEditorSelectionChangeKind2[TextEditorSelectionChangeKind2["Command"] = 3] = "Command";
      return TextEditorSelectionChangeKind2;
    })(TextEditorSelectionChangeKind || {});
    ((TextEditorSelectionChangeKind2) => {
      function fromValue(s) {
        switch (s) {
          case "keyboard":
            return 1 /* Keyboard */;
          case "mouse":
            return 2 /* Mouse */;
          case "api":
            return 3 /* Command */;
        }
        return void 0;
      }
      TextEditorSelectionChangeKind2.fromValue = fromValue;
    })(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}));
    DataTransferItem = class {
      constructor(value, id) {
        this.value = value;
        this.id = id ?? generateUuid();
      }
      async asString() {
        return typeof this.value === "string" ? this.value : JSON.stringify(this.value);
      }
      asFile() {
        return void 0;
      }
    };
    _DocumentDropOrPasteEditKind = class _DocumentDropOrPasteEditKind {
      constructor(value) {
        this.value = value;
      }
      append(...parts) {
        return new _DocumentDropOrPasteEditKind((this.value ? [this.value, ...parts] : parts).join(_DocumentDropOrPasteEditKind.sep));
      }
      intersects(other) {
        return this.contains(other) || other.contains(this);
      }
      contains(other) {
        return this.value === other.value || other.value.startsWith(this.value + _DocumentDropOrPasteEditKind.sep);
      }
    };
    _DocumentDropOrPasteEditKind.sep = ".";
    DocumentDropOrPasteEditKind = _DocumentDropOrPasteEditKind;
    DocumentDropOrPasteEditKind.Empty = new DocumentDropOrPasteEditKind("");
    DocumentDropOrPasteEditKind.Text = new DocumentDropOrPasteEditKind("text");
    DocumentPasteEdit = class {
      constructor(insertText, title, kind) {
        this.title = title;
        this.insertText = insertText;
        this.kind = kind;
      }
    };
    RelativePattern = class {
      get base() {
        return this._base;
      }
      set base(base) {
        this._base = base;
        this._baseUri = URI4.file(base);
      }
      get baseUri() {
        return this._baseUri;
      }
      set baseUri(baseUri) {
        this._baseUri = baseUri;
        this._base = baseUri.fsPath;
      }
      constructor(base, pattern) {
        if (typeof base !== "string") {
          if (!base || !URI4.isUri(base) && !URI4.isUri(base.uri)) {
            throw illegalArgument("base");
          }
        }
        if (typeof pattern !== "string") {
          throw illegalArgument("pattern");
        }
        if (typeof base === "string") {
          this.baseUri = URI4.file(base);
        } else if (URI4.isUri(base)) {
          this.baseUri = base;
        } else {
          this.baseUri = base.uri;
        }
        this.pattern = pattern;
      }
      toJSON() {
        return {
          pattern: this.pattern,
          base: this.base,
          baseUri: this.baseUri.toJSON()
        };
      }
    };
    FoldingRange = class {
      constructor(start, end, kind) {
        this.start = start;
        this.end = end;
        this.kind = kind;
      }
    };
    SemanticTokensLegend = class {
      constructor(tokenTypes2, tokenModifiers2 = []) {
        this.tokenTypes = tokenTypes2;
        this.tokenModifiers = tokenModifiers2;
      }
    };
    SemanticTokensBuilder = class _SemanticTokensBuilder {
      constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt = /* @__PURE__ */ new Map();
        this._tokenModifierStrToInt = /* @__PURE__ */ new Map();
        this._hasLegend = false;
        if (legend) {
          this._hasLegend = true;
          for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
            this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
          }
          for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
            this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
          }
        }
      }
      push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === "number" && typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && (typeof arg4 === "number" || typeof arg4 === "undefined")) {
          if (typeof arg4 === "undefined") {
            arg4 = 0;
          }
          return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (Range.isRange(arg0) && typeof arg1 === "string" && isStrArrayOrUndefined(arg2)) {
          return this._push(arg0, arg1, arg2);
        }
        throw illegalArgument();
      }
      _push(range, tokenType, tokenModifiers2) {
        if (!this._hasLegend) {
          throw new Error("Legend must be provided in constructor");
        }
        if (range.start.line !== range.end.line) {
          throw new Error("`range` cannot span multiple lines");
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
          throw new Error("`tokenType` is not in the provided legend");
        }
        const line = range.start.line;
        const char = range.start.character;
        const length = range.end.character - range.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers2) {
          for (const tokenModifier of tokenModifiers2) {
            if (!this._tokenModifierStrToInt.has(tokenModifier)) {
              throw new Error("`tokenModifier` is not in the provided legend");
            }
            const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
            nTokenModifiers |= 1 << nTokenModifier >>> 0;
          }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
      }
      _pushEncoded(line, char, length, tokenType, tokenModifiers2) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || line === this._prevLine && char < this._prevChar)) {
          this._dataIsSortedAndDeltaEncoded = false;
          const tokenCount = this._data.length / 5 | 0;
          let prevLine = 0;
          let prevChar = 0;
          for (let i = 0; i < tokenCount; i++) {
            let line2 = this._data[5 * i];
            let char2 = this._data[5 * i + 1];
            if (line2 === 0) {
              line2 = prevLine;
              char2 += prevChar;
            } else {
              line2 += prevLine;
            }
            this._data[5 * i] = line2;
            this._data[5 * i + 1] = char2;
            prevLine = line2;
            prevChar = char2;
          }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers2;
        this._prevLine = line;
        this._prevChar = char;
      }
      static _sortAndDeltaEncode(data) {
        const pos = [];
        const tokenCount = data.length / 5 | 0;
        for (let i = 0; i < tokenCount; i++) {
          pos[i] = i;
        }
        pos.sort((a, b) => {
          const aLine = data[5 * a];
          const bLine = data[5 * b];
          if (aLine === bLine) {
            const aChar = data[5 * a + 1];
            const bChar = data[5 * b + 1];
            return aChar - bChar;
          }
          return aLine - bLine;
        });
        const result = new Uint32Array(data.length);
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
          const srcOffset = 5 * pos[i];
          const line = data[srcOffset + 0];
          const char = data[srcOffset + 1];
          const length = data[srcOffset + 2];
          const tokenType = data[srcOffset + 3];
          const tokenModifiers2 = data[srcOffset + 4];
          const pushLine = line - prevLine;
          const pushChar = pushLine === 0 ? char - prevChar : char;
          const dstOffset = 5 * i;
          result[dstOffset + 0] = pushLine;
          result[dstOffset + 1] = pushChar;
          result[dstOffset + 2] = length;
          result[dstOffset + 3] = tokenType;
          result[dstOffset + 4] = tokenModifiers2;
          prevLine = line;
          prevChar = char;
        }
        return result;
      }
      build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
          return new SemanticTokens(_SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId);
        }
        return new SemanticTokens(new Uint32Array(this._data), resultId);
      }
    };
    SemanticTokens = class {
      constructor(data, resultId) {
        this.resultId = resultId;
        this.data = data;
      }
    };
    LinkedEditingRanges = class {
      constructor(ranges, wordPattern) {
        this.ranges = ranges;
        this.wordPattern = wordPattern;
      }
    };
    TabInputText = class {
      constructor(uri) {
        this.uri = uri;
      }
    };
    TabInputTextDiff = class {
      constructor(original, modified) {
        this.original = original;
        this.modified = modified;
      }
    };
    TabInputNotebook = class {
      constructor(uri, notebookType) {
        this.uri = uri;
        this.notebookType = notebookType;
      }
    };
    CancellationError = class extends Error {
      constructor() {
        super("Canceled");
        this.name = this.message;
      }
    };
  }
});

// src/shims/log.ts
import * as lsp4 from "vscode-languageserver-protocol";
function format(args) {
  let result = "";
  for (let i = 0; i < args.length; i++) {
    let a = args[i];
    if (a instanceof Error) {
      a = a.stack ? `${a.message}: ${a.stack}` : a.message;
    }
    if (typeof a === "object") {
      try {
        a = JSON.stringify(a);
      } catch (e) {
      }
    }
    result += (i > 0 ? " " : "") + a;
  }
  return result;
}
var OutputChannel, LogOutputChannel;
var init_log = __esm({
  "src/shims/log.ts"() {
    "use strict";
    init_dispose2();
    OutputChannel = class extends Disposable {
      constructor(delegate, name) {
        super();
        this.delegate = delegate;
        this.name = name;
      }
      append(value) {
        this.delegate.logMessage(lsp4.MessageType.Log, value);
      }
      appendLine(value) {
        this.delegate.logMessage(lsp4.MessageType.Log, value);
      }
      replace() {
      }
      clear() {
      }
      show() {
      }
      hide() {
      }
    };
    LogOutputChannel = class extends OutputChannel {
      constructor() {
        super(...arguments);
        this.logLevel = 1 /* Trace */;
        this._onDidChangeLogLevel = new lsp4.Emitter();
        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
      }
      trace(message, ...args) {
        this.delegate.logTrace(format([message, ...args]));
      }
      debug(message, ...args) {
        this.delegate.logMessage(lsp4.MessageType.Log, format([message, ...args]));
      }
      info(message, ...args) {
        this.delegate.logMessage(lsp4.MessageType.Info, format([message, ...args]));
      }
      warn(message, ...args) {
        this.delegate.logMessage(lsp4.MessageType.Warning, format([message, ...args]));
      }
      error(error, ...args) {
        this.delegate.logMessage(lsp4.MessageType.Error, format([error, ...args]));
      }
    };
  }
});

// src/shims/window.ts
import * as lsp5 from "vscode-languageserver-protocol";
var WindowShimService;
var init_window = __esm({
  "src/shims/window.ts"() {
    "use strict";
    init_dispose2();
    init_types();
    init_log();
    WindowShimService = class extends Disposable {
      constructor(delegate) {
        super();
        this.delegate = delegate;
        this.outputChannels = /* @__PURE__ */ new Map();
        this._onDidChangeActiveTextEditor = this._register(new lsp5.Emitter());
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this._onDidChangeVisibleTextEditors = this._register(new lsp5.Emitter());
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
        this._onDidChangeTabGroups = this._register(new lsp5.Emitter());
        this._onDidChangeTabs = this._register(new lsp5.Emitter());
        this.tabGroups = {
          onDidChangeTabGroups: this._onDidChangeTabGroups.event,
          onDidChangeTabs: this._onDidChangeTabs.event,
          get all() {
            return [this.activeTabGroup];
          },
          activeTabGroup: {
            isActive: false,
            viewColumn: -1,
            activeTab: void 0,
            tabs: []
          }
        };
        this._register(
          lsp5.Disposable.create(() => {
            disposeAll([...this.outputChannels.values()]);
            this.outputChannels.clear();
          })
        );
      }
      get visibleTextEditors() {
        return [];
      }
      createOutputChannel(name, options) {
        const log = typeof options === "object" && options.log;
        const newChannel = this._register(
          log ? new LogOutputChannel(this.delegate, name) : new OutputChannel(this.delegate, name)
        );
        this.outputChannels.set(name, newChannel);
        return newChannel;
      }
      showErrorMessage(message, ...items) {
        return this._showMessagePrompt(lsp5.MessageType.Error, message, items);
      }
      async showInformationMessage(message, ...items) {
        return this._showMessagePrompt(lsp5.MessageType.Info, message, items);
      }
      async showWarningMessage(message, ...items) {
        return this._showMessagePrompt(lsp5.MessageType.Warning, message, items);
      }
      async withProgress(options, task) {
        const reporter = await this.delegate.createWorkDoneProgress();
        if (!reporter) {
          return await task({ report() {
          } }, lsp5.CancellationToken.None);
        }
        reporter.begin(options.title ?? "");
        try {
          const result = await task(
            {
              report({ increment, message }) {
                reporter.report(increment, message);
              }
            },
            reporter.token
          );
          reporter.done();
          return result;
        } catch (e) {
          reporter.done();
          void this.delegate.logMessage(lsp5.MessageType.Error, String(e));
          throw e;
        }
      }
      showTextDocument(document) {
        return this.delegate.openTextDocument(document.uri.toString(), true);
      }
      async _showMessagePrompt(type, message, items) {
        const allTitles = items.map((i, id) => {
          if (typeof i === "string") {
            return { title: i, tsId: id };
          } else if (!isPrimitive(i) && "title" in i) {
            return { title: i.title, tsId: id };
          }
          return;
        });
        const transformedItems = allTitles.filter((i) => !!i);
        const selected = await this.delegate.showMessage(type, message, ...transformedItems);
        if ((selected == null ? void 0 : selected.tsId) !== void 0 && typeof selected.tsId === "number") {
          return items[selected.tsId];
        } else {
          return selected;
        }
      }
    };
  }
});

// src/shims/fs.ts
import { promises as fsPromises } from "fs";
async function symLinkStat(path15) {
  let lstats;
  try {
    lstats = await fsPromises.lstat(path15);
    if (!lstats.isSymbolicLink()) {
      return { stat: lstats };
    }
  } catch (error) {
  }
  try {
    const stats = await fsPromises.stat(path15);
    return {
      stat: stats,
      symbolicLink: (lstats == null ? void 0 : lstats.isSymbolicLink()) ? { dangling: false } : void 0
    };
  } catch (error) {
    if (error.code === "ENOENT" && lstats) {
      return { stat: lstats, symbolicLink: { dangling: true } };
    }
    if (process.platform === "win32" && error.code === "EACCES") {
      try {
        const stats = await fsPromises.stat(await fsPromises.readlink(path15));
        return { stat: stats, symbolicLink: { dangling: false } };
      } catch (error2) {
        if (error2.code === "ENOENT" && lstats) {
          return { stat: lstats, symbolicLink: { dangling: true } };
        }
        throw error2;
      }
    }
    throw error;
  }
}
function toType(entry, symbolicLink) {
  let type;
  if (symbolicLink == null ? void 0 : symbolicLink.dangling) {
    type = 0 /* Unknown */;
  } else if (entry.isFile()) {
    type = 1 /* File */;
  } else if (entry.isDirectory()) {
    type = 2 /* Directory */;
  } else {
    type = 0 /* Unknown */;
  }
  if (symbolicLink) {
    type |= 64 /* SymbolicLink */;
  }
  return type;
}
function createFileSystemShim() {
  return {
    async stat(uri) {
      const { stat, symbolicLink } = await symLinkStat(uri.fsPath);
      return {
        type: toType(stat, symbolicLink),
        ctime: stat.birthtime.getTime(),
        // intentionally not using ctime here, we want the creation time
        mtime: stat.mtime.getTime(),
        size: stat.size
      };
    }
  };
}
var init_fs3 = __esm({
  "src/shims/fs.ts"() {
    "use strict";
  }
});

// src/utils/word.ts
function getWordPattern() {
  return /(-?\d*\.\d\w*)|([^\`\~\@\!\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>/\?\s]+)/g;
}
function getWordAtText(column, text, textOffset = 0) {
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, text, textOffset);
  }
  const wordDefinition = getWordPattern();
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
      break;
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match) {
      break;
    }
    match = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match) {
    const result = {
      word: match[0],
      startColumn: textOffset + 1 + match.index,
      endColumn: textOffset + 1 + match.index + match[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match;
  while (match = wordDefinition.exec(text)) {
    const matchIndex = match.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}
var config;
var init_word = __esm({
  "src/utils/word.ts"() {
    "use strict";
    config = {
      maxLen: 1e3,
      windowSize: 15,
      timeBudget: 150
    };
  }
});

// src/shims/textdocument.ts
import * as lsp6 from "vscode-languageserver-protocol";
import {
  TextDocument
} from "vscode-languageserver-textdocument";
import { URI as URI5 } from "vscode-uri";
var IsomorphicTextDocument, DocumentLine;
var init_textdocument = __esm({
  "src/shims/textdocument.ts"() {
    "use strict";
    init_types2();
    init_word();
    IsomorphicTextDocument = class _IsomorphicTextDocument {
      constructor($documentModel) {
        this.$documentModel = $documentModel;
        this.getText = this.$documentModel.getText.bind(this.$documentModel);
        this.offsetAt = this.$documentModel.offsetAt.bind(this.$documentModel);
        this.positionAt = (offset) => {
          const pos = this.$documentModel.positionAt(offset);
          return new Position(pos.line, pos.character);
        };
        this.getWordRangeAtPosition = (position) => {
          const line = this.getText(new Range(position.line, 0, position.line, Number.MAX_VALUE));
          const wordAtText = getWordAtText(position.character + 1, line);
          if (wordAtText) {
            return new Range(
              position.line,
              wordAtText.startColumn - 1,
              position.line,
              wordAtText.endColumn - 1
            );
          }
        };
        this.eol = 1 /* LF */;
        // not synced if removed from documents
        this.isClosed = false;
        // assume always dirty
        this.isDirty = true;
        this.lineAt = (lineOrPosition) => {
          let line = 0;
          if (lineOrPosition instanceof Position) {
            line = lineOrPosition.line;
          } else if (typeof lineOrPosition === "number") {
            line = lineOrPosition;
          } else {
            throw new Error("invalid params");
          }
          const lineText = this.$documentModel.getText(
            lsp6.Range.create(lsp6.Position.create(line, 0), lsp6.Position.create(line, Number.MAX_VALUE))
          ).replace(/[\r\n]+$/, "");
          return new DocumentLine(line, lineText, line === this.lineCount - 1);
        };
        this.uri = URI5.parse($documentModel.uri);
      }
      static create(uri, languageId, version, content) {
        const documentModel = TextDocument.create(uri, languageId, version, content);
        return new _IsomorphicTextDocument(documentModel);
      }
      static update(document, changes, version) {
        TextDocument.update(document.$documentModel, changes, version);
      }
      static applyEdits(document, edits) {
        TextDocument.applyEdits(document.$documentModel, edits);
      }
      get version() {
        return this.$documentModel.version;
      }
      get languageId() {
        return this.$documentModel.languageId;
      }
      get lineCount() {
        return this.$documentModel.lineCount;
      }
      get fileName() {
        return this.uri.fsPath;
      }
      get isUntitled() {
        return this.uri.scheme == "untitled";
      }
      // TODO: following unimplemented methods
      save() {
        throw new Error("Function not implemented.");
      }
      validateRange(range) {
        return range;
      }
      validatePosition(position) {
        return position;
      }
    };
    DocumentLine = class {
      constructor(line, text, isLastLine) {
        this._line = line;
        this._text = text;
        this._isLastLine = isLastLine;
      }
      get lineNumber() {
        return this._line;
      }
      get text() {
        return this._text;
      }
      get range() {
        return new Range(this._line, 0, this._line, this._text.length);
      }
      get rangeIncludingLineBreak() {
        if (this._isLastLine) {
          return this.range;
        }
        return new Range(this._line, 0, this._line + 1, 0);
      }
      get firstNonWhitespaceCharacterIndex() {
        return /^(\s*)/.exec(this._text)[1].length;
      }
      get isEmptyOrWhitespace() {
        return this.firstNonWhitespaceCharacterIndex === this._text.length;
      }
    };
  }
});

// src/shims/workspace.ts
import * as path2 from "path";
import * as lsp7 from "vscode-languageserver-protocol";
import { URI as URI6, Utils as uriUtils } from "vscode-uri";
var DocumentNotOpenedError, WorkspaceShimService;
var init_workspace = __esm({
  "src/shims/workspace.ts"() {
    "use strict";
    init_barrier();
    init_dispose2();
    init_fs();
    init_resourceMap2();
    init_fs3();
    init_textdocument();
    init_types2();
    DocumentNotOpenedError = class extends Error {
      constructor(uri) {
        super(`Cannot find document ${uri}. It should be opened before requesting features for it.`);
      }
    };
    WorkspaceShimService = class extends Disposable {
      constructor(delegate, configurationShim, initWorkspaceFolders) {
        super();
        this.delegate = delegate;
        this.configurationShim = configurationShim;
        this._onDidOpenTextDocument = this._register(new lsp7.Emitter());
        this.onDidOpenTextDocument = this._onDidOpenTextDocument.event;
        this._onDidCloseTextDocument = this._register(new lsp7.Emitter());
        this.onDidCloseTextDocument = this._onDidCloseTextDocument.event;
        this._onDidChangeTextDocument = this._register(
          new lsp7.Emitter()
        );
        this.onDidChangeTextDocument = this._onDidChangeTextDocument.event;
        this._onDidRenameFiles = this._register(new lsp7.Emitter());
        this.onDidRenameFiles = this._onDidRenameFiles.event;
        this.onDidChangeConfiguration = this.configurationShim.onDidChangeConfiguration;
        this._onDidChangeWorkspaceFolders = this._register(
          new lsp7.Emitter()
        );
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this._onDidGrantWorkspaceTrust = this._register(new lsp7.Emitter());
        this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event;
        this._workspaceFolderIdGen = 0;
        this._fs = createFileSystemShim();
        // TODO: should we handle this?
        this.isTrusted = true;
        this._documents = new ResourceMap(void 0, {
          onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem()
        });
        this._workspaceFolders = new ResourceMap(void 0, {
          onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem()
        });
        for (const f of initWorkspaceFolders ?? []) {
          const id = this._workspaceFolderIdGen++;
          const uri = URI6.parse(f.uri);
          this._workspaceFolders.set(uri, {
            name: f.name || uriUtils.basename(uri),
            index: id,
            uri
          });
        }
      }
      get fs() {
        return this._fs;
      }
      get textDocuments() {
        return Array.from(this._documents.values());
      }
      get workspaceFolders() {
        const result = [];
        for (const folder of this._workspaceFolders.values()) {
          result.push(folder);
        }
        return result;
      }
      $getOpenedDoc(uri) {
        return this._documents.get(URI6.parse(uri));
      }
      $getOpenedDocThrow(uri) {
        const doc = this.$getOpenedDoc(uri);
        if (!doc) {
          throw new DocumentNotOpenedError(uri);
        }
        return doc;
      }
      $openTextDocument(params) {
        const {
          textDocument: { uri, languageId, version, text }
        } = params;
        const doc = IsomorphicTextDocument.create(uri, languageId, version, text);
        this._documents.set(URI6.parse(uri), doc);
        this._onDidOpenTextDocument.fire(doc);
      }
      $changeTextDocument(params) {
        const {
          textDocument: { uri, version },
          contentChanges: changes
        } = params;
        const doc = this._documents.get(URI6.parse(uri));
        if (!doc) {
          this.delegate.logMessage(lsp7.MessageType.Error, `File ${uri} not found`);
          return;
        }
        IsomorphicTextDocument.update(doc, changes, version);
        this._onDidChangeTextDocument.fire({
          document: doc,
          contentChanges: changes.map((c) => {
            if ("range" in c) {
              const rangeOffset = doc.offsetAt(c.range.start);
              const rangeLength = doc.offsetAt(c.range.end) - rangeOffset;
              return { rangeOffset, rangeLength, range: Range.of(c.range), text: c.text };
            } else {
              return {
                rangeOffset: 0,
                rangeLength: c.text.length,
                range: new Range(0, 0, doc.lineCount, 0),
                text: c.text
              };
            }
          }),
          reason: void 0
        });
      }
      $closeTextDocument(params) {
        const {
          textDocument: { uri }
        } = params;
        const vsUri = URI6.parse(uri);
        const doc = this._documents.get(vsUri);
        if (doc) {
          this._onDidCloseTextDocument.fire(doc);
          this._documents.delete(vsUri);
        }
      }
      $changeWorkspaceFolders(params) {
        const { event } = params;
        const transformedAdded = [];
        event.added.forEach((folder) => {
          const uri = URI6.parse(folder.uri);
          const addFolder = {
            name: folder.name,
            index: this._workspaceFolderIdGen++,
            uri
          };
          this._workspaceFolders.set(uri, addFolder);
          transformedAdded.push(addFolder);
        });
        const transformedRemoved = [];
        event.removed.forEach((folder) => {
          const uri = URI6.parse(folder.uri);
          const removed = this._workspaceFolders.get(uri);
          if (removed) {
            transformedRemoved.push(removed);
            this._workspaceFolders.delete(uri);
          }
        });
        this._onDidChangeWorkspaceFolders.fire({
          added: transformedAdded,
          removed: transformedRemoved
        });
      }
      $renameFiles(params) {
        const renamedFiles = params.files.map(({ newUri, oldUri }) => ({
          newUri: URI6.parse(newUri),
          oldUri: URI6.parse(oldUri)
        }));
        if (renamedFiles.length > 0) {
          this._onDidRenameFiles.fire({
            files: renamedFiles
          });
        }
      }
      getWorkspaceFolder(uri) {
        for (const folder of this._workspaceFolders.values()) {
          const fUri = folder.uri;
          const fPathWithSlash = fUri.path.endsWith("/") ? fUri.path : fUri.path + "/";
          if (fUri.scheme === uri.scheme && fUri.authority === uri.authority && uri.path > fPathWithSlash && uri.path.startsWith(fPathWithSlash)) {
            return folder;
          }
        }
      }
      asRelativePath(pathOrUri, includeWorkspace) {
        const uri = URI6.isUri(pathOrUri) ? pathOrUri : URI6.file(pathOrUri);
        const workspaceFolder = this.getWorkspaceFolder(uri);
        if (!workspaceFolder) {
          return uri.fsPath;
        }
        const includeFolder = typeof includeWorkspace === "undefined" ? this._workspaceFolders.size > 1 : includeWorkspace;
        const result = path2.relative(workspaceFolder.uri.fsPath, uri.fsPath);
        if (includeFolder) {
          return path2.join(workspaceFolder.name, result);
        } else {
          return result;
        }
      }
      getConfiguration(section) {
        return this.configurationShim.getConfiguration(section);
      }
      async openTextDocument(nameOrUri) {
        const uri = typeof nameOrUri === "string" ? URI6.file(nameOrUri) : nameOrUri;
        const maybeOpenedDoc = this._documents.get(uri);
        if (maybeOpenedDoc) {
          return maybeOpenedDoc;
        }
        const success = await this.delegate.openTextDocument(uri.toString());
        if (!success) {
          throw new Error(`Cannot open doc ${uri.toString()}`);
        }
        const pending = new Barrier();
        const handler = this.onDidOpenTextDocument((textDocument) => {
          if (textDocument.uri === uri) {
            pending.open();
            handler.dispose();
          }
        });
        setTimeout(() => {
          handler.dispose();
          pending.open();
        }, 200);
        await pending.wait();
        const doc = this._documents.get(uri) ?? IsomorphicTextDocument.create(uri.toString(), "unknown", 0, "");
        return doc;
      }
      applyEdit(edit) {
        return this.delegate.applyWorkspaceEdit(this.delegate.converter.convertWorkspaceEdit(edit));
      }
      async requestWorkspaceTrust() {
        return true;
      }
    };
  }
});

// src/shims/index.ts
import * as l10n from "@vscode/l10n";
import * as os2 from "os";
import { Emitter as Emitter8 } from "vscode-languageserver-protocol";
import { URI as URI7, Utils } from "vscode-uri";
import { CancellationTokenSource } from "vscode-languageserver-protocol";
function initializeShimServices(initOptions, delegate, defaultConfig, defaultNls) {
  l10n.config({ contents: defaultNls });
  const configurationService = new ConfigurationShimService(defaultConfig);
  const workspaceService = new WorkspaceShimService(
    delegate,
    configurationService,
    initOptions.workspaceFolders
  );
  const commandsService = new CommandsShimService(delegate);
  const diagnosticsSerivce = new DiagnosticsShimService();
  const languageFeaturesService = new LanguageFeaturesShimService(delegate, diagnosticsSerivce);
  const windowService = new WindowShimService(delegate);
  const context = createContextShim(initOptions.tsExtLogPath ?? os2.tmpdir(), initOptions.hostInfo);
  const dispose = () => {
    configurationService.dispose();
    languageFeaturesService.dispose();
    commandsService.dispose();
    workspaceService.dispose();
    windowService.dispose();
    context.subscriptions.forEach((d) => {
      d.dispose();
    });
  };
  languages = languageFeaturesService;
  commands = commandsService;
  workspace = workspaceService;
  window = windowService;
  env = {
    language: initOptions.locale ?? "en",
    openExternal: (uri) => delegate.openExternal(uri.toString(true)),
    uiKind: 1 /* Desktop */
  };
  chat = createChatShim();
  return {
    configurationService,
    workspaceService,
    commandsService,
    diagnosticsSerivce,
    languageFeaturesService,
    windowService,
    context,
    l10n,
    extensions,
    env,
    chat,
    dispose
  };
}
var extensions, languages, commands, window, env, workspace, chat, EventEmitter, Uri;
var init_shims = __esm({
  "src/shims/index.ts"() {
    "use strict";
    init_chat();
    init_commands();
    init_configuration();
    init_context();
    init_diagnostics();
    init_extensions();
    init_languageFeatures();
    init_types2();
    init_window();
    init_workspace();
    init_fs3();
    init_log();
    init_types2();
    extensions = createExtensionsShim();
    EventEmitter = Emitter8;
    Uri = new Proxy(URI7, {
      get(target, p) {
        return target[p] ?? Utils[p];
      }
    });
  }
});

// src/typescript-language-features/src/api.ts
function getExtensionApi(onCompletionAccepted, pluginManager) {
  return {
    getAPI(version) {
      if (version === 0) {
        return new ApiV0(onCompletionAccepted, pluginManager);
      }
      return void 0;
    }
  };
}
var ApiV0;
var init_api = __esm({
  "src/typescript-language-features/src/api.ts"() {
    "use strict";
    ApiV0 = class {
      constructor(onCompletionAccepted, _pluginManager) {
        this.onCompletionAccepted = onCompletionAccepted;
        this._pluginManager = _pluginManager;
      }
      configurePlugin(pluginId, configuration) {
        this._pluginManager.setConfiguration(pluginId, configuration);
      }
    };
  }
});

// src/typescript-language-features/src/commands/commandManager.ts
var CommandManager;
var init_commandManager = __esm({
  "src/typescript-language-features/src/commands/commandManager.ts"() {
    "use strict";
    init_shims();
    CommandManager = class {
      constructor() {
        this.commands = /* @__PURE__ */ new Map();
      }
      dispose() {
        for (const registration of this.commands.values()) {
          registration.registration.dispose();
        }
        this.commands.clear();
      }
      register(command) {
        let entry = this.commands.get(command.id);
        if (!entry) {
          entry = { refCount: 1, registration: commands.registerCommand(command.id, command.execute, command) };
          this.commands.set(command.id, entry);
        } else {
          entry.refCount += 1;
        }
        return new Disposable4(() => {
          entry.refCount -= 1;
          if (entry.refCount <= 0) {
            entry.registration.dispose();
            this.commands.delete(command.id);
          }
        });
      }
    };
  }
});

// src/typescript-language-features/src/commands/configurePlugin.ts
var ConfigurePluginCommand;
var init_configurePlugin = __esm({
  "src/typescript-language-features/src/commands/configurePlugin.ts"() {
    "use strict";
    ConfigurePluginCommand = class {
      constructor(pluginManager) {
        this.pluginManager = pluginManager;
        this.id = "_typescript.configurePlugin";
      }
      execute(pluginId, configuration) {
        this.pluginManager.setConfiguration(pluginId, configuration);
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/api.ts
import * as semver from "semver";
var _API, API;
var init_api2 = __esm({
  "src/typescript-language-features/src/tsServer/api.ts"() {
    "use strict";
    init_shims();
    _API = class _API {
      constructor(displayName2, version, fullVersionString) {
        this.displayName = displayName2;
        this.version = version;
        this.fullVersionString = fullVersionString;
      }
      static fromSimpleString(value) {
        return new _API(value, value, value);
      }
      static fromVersionString(versionString) {
        let version = semver.valid(versionString);
        if (!version) {
          return new _API(l10n.t("invalid version"), "1.0.0", "1.0.0");
        }
        const index = versionString.indexOf("-");
        if (index >= 0) {
          version = version.substr(0, index);
        }
        return new _API(versionString, version, versionString);
      }
      eq(other) {
        return semver.eq(this.version, other.version);
      }
      gte(other) {
        return semver.gte(this.version, other.version);
      }
      lt(other) {
        return !this.gte(other);
      }
      isYarnPnp() {
        return this.fullVersionString.includes("-sdk");
      }
    };
    _API.defaultVersion = _API.fromSimpleString("1.0.0");
    _API.v380 = _API.fromSimpleString("3.8.0");
    _API.v390 = _API.fromSimpleString("3.9.0");
    _API.v400 = _API.fromSimpleString("4.0.0");
    _API.v401 = _API.fromSimpleString("4.0.1");
    _API.v420 = _API.fromSimpleString("4.2.0");
    _API.v430 = _API.fromSimpleString("4.3.0");
    _API.v440 = _API.fromSimpleString("4.4.0");
    _API.v460 = _API.fromSimpleString("4.6.0");
    _API.v470 = _API.fromSimpleString("4.7.0");
    _API.v490 = _API.fromSimpleString("4.9.0");
    _API.v500 = _API.fromSimpleString("5.0.0");
    _API.v510 = _API.fromSimpleString("5.1.0");
    _API.v520 = _API.fromSimpleString("5.2.0");
    _API.v544 = _API.fromSimpleString("5.4.4");
    _API.v540 = _API.fromSimpleString("5.4.0");
    _API.v560 = _API.fromSimpleString("5.6.0");
    _API.v570 = _API.fromSimpleString("5.7.0");
    API = _API;
  }
});

// src/typescript-language-features/src/utils/cancellation.ts
var noopDisposable, nulToken;
var init_cancellation = __esm({
  "src/typescript-language-features/src/utils/cancellation.ts"() {
    "use strict";
    init_shims();
    noopDisposable = Disposable4.from();
    nulToken = {
      isCancellationRequested: false,
      onCancellationRequested: () => noopDisposable
    };
  }
});

// src/typescript-language-features/src/tsconfig.ts
function isImplicitProjectConfigFile(configFileName) {
  return configFileName.startsWith("/dev/null/");
}
function inferredProjectCompilerOptions(version, projectType, serviceConfig) {
  const projectConfig = {
    module: version.gte(API.v540) ? "Preserve" : "ESNext",
    moduleResolution: version.gte(API.v540) ? "Bundler" : "Node",
    target: "ES2022",
    jsx: "react"
  };
  if (version.gte(API.v500)) {
    projectConfig.allowImportingTsExtensions = true;
  }
  if (serviceConfig.implicitProjectConfiguration.checkJs) {
    projectConfig.checkJs = true;
    if (projectType === 0 /* TypeScript */) {
      projectConfig.allowJs = true;
    }
  }
  if (serviceConfig.implicitProjectConfiguration.experimentalDecorators) {
    projectConfig.experimentalDecorators = true;
  }
  if (serviceConfig.implicitProjectConfiguration.strictNullChecks) {
    projectConfig.strictNullChecks = true;
  }
  if (serviceConfig.implicitProjectConfiguration.strictFunctionTypes) {
    projectConfig.strictFunctionTypes = true;
  }
  if (serviceConfig.implicitProjectConfiguration.module) {
    projectConfig.module = serviceConfig.implicitProjectConfiguration.module;
  }
  if (serviceConfig.implicitProjectConfiguration.target) {
    projectConfig.target = serviceConfig.implicitProjectConfiguration.target;
  }
  if (projectType === 0 /* TypeScript */) {
    projectConfig.sourceMap = true;
  }
  return projectConfig;
}
function inferredProjectConfigSnippet(version, projectType, config3) {
  const baseConfig = inferredProjectCompilerOptions(version, projectType, config3);
  if (projectType === 0 /* TypeScript */) {
    delete baseConfig.allowImportingTsExtensions;
  }
  const compilerOptions = Object.keys(baseConfig).map((key) => `"${key}": ${JSON.stringify(baseConfig[key])}`);
  return new SnippetString(`{
	"compilerOptions": {
		${compilerOptions.join(",\n		")}$0
	},
	"exclude": [
		"node_modules",
		"**/node_modules/*"
	]
}`);
}
async function openOrCreateConfig(version, projectType, rootPath, configuration) {
  var _a;
  const configFile = Uri.joinPath(rootPath, projectType === 0 /* TypeScript */ ? "tsconfig.json" : "jsconfig.json");
  const col = (_a = window.activeTextEditor) == null ? void 0 : _a.viewColumn;
  try {
    const doc = await workspace.openTextDocument(configFile);
    return window.showTextDocument(doc, col);
  } catch {
    const doc = await workspace.openTextDocument(configFile.with({ scheme: "untitled" }));
    const editor = await window.showTextDocument(doc, col);
    if (editor.document.getText().length === 0) {
      await editor.insertSnippet(inferredProjectConfigSnippet(version, projectType, configuration));
    }
    return editor;
  }
}
async function openProjectConfigOrPromptToCreate(projectType, client, rootPath, configFilePath) {
  var _a;
  if (!isImplicitProjectConfigFile(configFilePath)) {
    const doc = await workspace.openTextDocument(client.toResource(configFilePath));
    window.showTextDocument(doc, (_a = window.activeTextEditor) == null ? void 0 : _a.viewColumn);
    return;
  }
  const CreateConfigItem = {
    title: projectType === 0 /* TypeScript */ ? l10n.t("Configure tsconfig.json") : l10n.t("Configure jsconfig.json")
  };
  const selected = await window.showInformationMessage(
    projectType === 0 /* TypeScript */ ? l10n.t("File is not part of a TypeScript project. View the [tsconfig.json documentation]({0}) to learn more.", "https://go.microsoft.com/fwlink/?linkid=841896") : l10n.t("File is not part of a JavaScript project. View the [jsconfig.json documentation]({0}) to learn more.", "https://go.microsoft.com/fwlink/?linkid=759670"),
    CreateConfigItem
  );
  switch (selected) {
    case CreateConfigItem:
      openOrCreateConfig(client.apiVersion, projectType, rootPath, client.configuration);
      return;
  }
}
async function openProjectConfigForFile(projectType, client, resource) {
  const rootPath = client.getWorkspaceRootForResource(resource);
  if (!rootPath) {
    window.showInformationMessage(
      l10n.t("Please open a folder in VS Code to use a TypeScript or JavaScript project")
    );
    return;
  }
  const file2 = client.toTsFilePath(resource);
  if (!file2 || !client.toTsFilePath(resource)) {
    window.showWarningMessage(
      l10n.t("Could not determine TypeScript or JavaScript project. Unsupported file type")
    );
    return;
  }
  let res;
  try {
    res = await client.execute("projectInfo", { file: file2, needFileNameList: false }, nulToken);
  } catch {
  }
  if ((res == null ? void 0 : res.type) !== "response" || !res.body) {
    window.showWarningMessage(l10n.t("Could not determine TypeScript or JavaScript project"));
    return;
  }
  return openProjectConfigOrPromptToCreate(projectType, client, rootPath, res.body.configFileName);
}
var init_tsconfig = __esm({
  "src/typescript-language-features/src/tsconfig.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_cancellation();
  }
});

// src/typescript-language-features/src/commands/goToProjectConfiguration.ts
var TypeScriptGoToProjectConfigCommand, JavaScriptGoToProjectConfigCommand;
var init_goToProjectConfiguration = __esm({
  "src/typescript-language-features/src/commands/goToProjectConfiguration.ts"() {
    "use strict";
    init_tsconfig();
    init_shims();
    TypeScriptGoToProjectConfigCommand = class {
      constructor(activeJsTsEditorTracker, lazyClientHost) {
        this.activeJsTsEditorTracker = activeJsTsEditorTracker;
        this.lazyClientHost = lazyClientHost;
        this.id = "typescript.goToProjectConfig";
      }
      execute(uri) {
        openProjectConfigForFile(0 /* TypeScript */, this.lazyClientHost.value.serviceClient, Uri.parse(uri));
      }
    };
    JavaScriptGoToProjectConfigCommand = class {
      constructor(activeJsTsEditorTracker, lazyClientHost) {
        this.activeJsTsEditorTracker = activeJsTsEditorTracker;
        this.lazyClientHost = lazyClientHost;
        this.id = "javascript.goToProjectConfig";
      }
      execute(uri) {
        openProjectConfigForFile(1 /* JavaScript */, this.lazyClientHost.value.serviceClient, Uri.parse(uri));
      }
    };
  }
});

// src/typescript-language-features/src/configuration/languageIds.ts
function isSupportedLanguageMode(doc) {
  return true;
}
function isTypeScriptDocument(doc) {
  return languages.match([typescript, typescriptreact], doc) > 0;
}
var typescript, typescriptreact, javascript, javascriptreact, jsTsLanguageModes;
var init_languageIds = __esm({
  "src/typescript-language-features/src/configuration/languageIds.ts"() {
    "use strict";
    init_shims();
    typescript = "typescript";
    typescriptreact = "typescriptreact";
    javascript = "javascript";
    javascriptreact = "javascriptreact";
    jsTsLanguageModes = [
      javascript,
      javascriptreact,
      typescript,
      typescriptreact
    ];
  }
});

// src/typescript-language-features/src/commands/learnMoreAboutRefactorings.ts
var _LearnMoreAboutRefactoringsCommand, LearnMoreAboutRefactoringsCommand;
var init_learnMoreAboutRefactorings = __esm({
  "src/typescript-language-features/src/commands/learnMoreAboutRefactorings.ts"() {
    "use strict";
    init_shims();
    init_languageIds();
    _LearnMoreAboutRefactoringsCommand = class _LearnMoreAboutRefactoringsCommand {
      constructor() {
        this.id = _LearnMoreAboutRefactoringsCommand.id;
      }
      execute() {
        const docUrl = window.activeTextEditor && isTypeScriptDocument(window.activeTextEditor.document) ? "https://go.microsoft.com/fwlink/?linkid=2114477" : "https://go.microsoft.com/fwlink/?linkid=2116761";
        env.openExternal(Uri.parse(docUrl));
      }
    };
    _LearnMoreAboutRefactoringsCommand.id = "_typescript.learnMoreAboutRefactorings";
    LearnMoreAboutRefactoringsCommand = _LearnMoreAboutRefactoringsCommand;
  }
});

// src/typescript-language-features/src/commands/openJsDocLink.ts
var _OpenJsDocLinkCommand, OpenJsDocLinkCommand;
var init_openJsDocLink = __esm({
  "src/typescript-language-features/src/commands/openJsDocLink.ts"() {
    "use strict";
    init_shims();
    _OpenJsDocLinkCommand = class _OpenJsDocLinkCommand {
      constructor() {
        this.id = _OpenJsDocLinkCommand.id;
      }
      async execute(args) {
        const { line, character } = args.position;
        const position = new Position(line, character);
        await commands.executeCommand("vscode.open", Uri.from(args.file), {
          selection: new Range(position, position)
        });
      }
    };
    _OpenJsDocLinkCommand.id = "_typescript.openJsDocLink";
    OpenJsDocLinkCommand = _OpenJsDocLinkCommand;
  }
});

// src/typescript-language-features/src/commands/openTsServerLog.ts
var OpenTsServerLogCommand;
var init_openTsServerLog = __esm({
  "src/typescript-language-features/src/commands/openTsServerLog.ts"() {
    "use strict";
    OpenTsServerLogCommand = class {
      constructor(lazyClientHost) {
        this.lazyClientHost = lazyClientHost;
        this.id = "typescript.openTsServerLog";
      }
      execute() {
        this.lazyClientHost.value.serviceClient.openTsServerLogFile();
      }
    };
  }
});

// src/typescript-language-features/src/commands/reloadProject.ts
var ReloadTypeScriptProjectsCommand, ReloadJavaScriptProjectsCommand;
var init_reloadProject = __esm({
  "src/typescript-language-features/src/commands/reloadProject.ts"() {
    "use strict";
    ReloadTypeScriptProjectsCommand = class {
      constructor(lazyClientHost) {
        this.lazyClientHost = lazyClientHost;
        this.id = "typescript.reloadProjects";
      }
      execute() {
        this.lazyClientHost.value.reloadProjects();
      }
    };
    ReloadJavaScriptProjectsCommand = class {
      constructor(lazyClientHost) {
        this.lazyClientHost = lazyClientHost;
        this.id = "javascript.reloadProjects";
      }
      execute() {
        this.lazyClientHost.value.reloadProjects();
      }
    };
  }
});

// src/typescript-language-features/src/commands/restartTsServer.ts
var RestartTsServerCommand;
var init_restartTsServer = __esm({
  "src/typescript-language-features/src/commands/restartTsServer.ts"() {
    "use strict";
    RestartTsServerCommand = class {
      constructor(lazyClientHost) {
        this.lazyClientHost = lazyClientHost;
        this.id = "typescript.restartTsServer";
      }
      execute() {
        this.lazyClientHost.value.serviceClient.restartTsServer(true);
      }
    };
  }
});

// src/typescript-language-features/src/commands/selectTypeScriptVersion.ts
var _SelectTypeScriptVersionCommand, SelectTypeScriptVersionCommand;
var init_selectTypeScriptVersion = __esm({
  "src/typescript-language-features/src/commands/selectTypeScriptVersion.ts"() {
    "use strict";
    _SelectTypeScriptVersionCommand = class _SelectTypeScriptVersionCommand {
      constructor(lazyClientHost) {
        this.lazyClientHost = lazyClientHost;
        this.id = _SelectTypeScriptVersionCommand.id;
      }
      execute() {
        this.lazyClientHost.value.serviceClient.showVersionPicker();
      }
    };
    _SelectTypeScriptVersionCommand.id = "typescript.selectTypeScriptVersion";
    SelectTypeScriptVersionCommand = _SelectTypeScriptVersionCommand;
  }
});

// src/typescript-language-features/src/commands/tsserverRequests.ts
function isCancellationToken(value) {
  return value && typeof value.isCancellationRequested === "boolean" && typeof value.onCancellationRequested === "function";
}
var TSServerRequestCommand;
var init_tsserverRequests = __esm({
  "src/typescript-language-features/src/commands/tsserverRequests.ts"() {
    "use strict";
    init_shims();
    init_cancellation();
    TSServerRequestCommand = class {
      constructor(lazyClientHost) {
        this.lazyClientHost = lazyClientHost;
        this.id = "typescript.tsserverRequest";
      }
      async execute(command, args, config3, token) {
        if (!isCancellationToken(token)) {
          token = nulToken;
        }
        if (args && typeof args === "object" && !Array.isArray(args)) {
          const requestArgs = args;
          let newArgs = void 0;
          if (requestArgs.file instanceof Uri) {
            newArgs = { ...args };
            const client = this.lazyClientHost.value.serviceClient;
            newArgs.file = client.toOpenTsFilePath(requestArgs.file);
            args = newArgs;
          }
        }
        const allowList = [
          // Seeing the JS/DTS output for a file
          "emit-output",
          // Grabbing a file's diagnostics
          "semanticDiagnosticsSync",
          "syntacticDiagnosticsSync",
          "suggestionDiagnosticsSync",
          // Introspecting code at a position
          "quickinfo",
          "quickinfo-full",
          "completionInfo",
          "getMoveToRefactoringFileSuggestions"
        ];
        if (allowList.includes(command) || command.startsWith("_")) {
          return this.lazyClientHost.value.serviceClient.execute(command, args, token, config3);
        }
        return void 0;
      }
    };
  }
});

// src/typescript-language-features/src/commands/index.ts
function registerBaseCommands(commandManager, lazyClientHost, pluginManager, activeJsTsEditorTracker) {
  commandManager.register(new ReloadTypeScriptProjectsCommand(lazyClientHost));
  commandManager.register(new ReloadJavaScriptProjectsCommand(lazyClientHost));
  commandManager.register(new SelectTypeScriptVersionCommand(lazyClientHost));
  commandManager.register(new OpenTsServerLogCommand(lazyClientHost));
  commandManager.register(new RestartTsServerCommand(lazyClientHost));
  commandManager.register(new TypeScriptGoToProjectConfigCommand(activeJsTsEditorTracker, lazyClientHost));
  commandManager.register(new JavaScriptGoToProjectConfigCommand(activeJsTsEditorTracker, lazyClientHost));
  commandManager.register(new ConfigurePluginCommand(pluginManager));
  commandManager.register(new LearnMoreAboutRefactoringsCommand());
  commandManager.register(new TSServerRequestCommand(lazyClientHost));
  commandManager.register(new OpenJsDocLinkCommand());
}
var init_commands2 = __esm({
  "src/typescript-language-features/src/commands/index.ts"() {
    "use strict";
    init_configurePlugin();
    init_goToProjectConfiguration();
    init_learnMoreAboutRefactorings();
    init_openJsDocLink();
    init_openTsServerLog();
    init_reloadProject();
    init_restartTsServer();
    init_selectTypeScriptVersion();
    init_tsserverRequests();
  }
});

// src/typescript-language-features/src/configuration/languageDescription.ts
import { basename } from "path";
function isJsConfigOrTsConfigFileName(fileName) {
  return /^[jt]sconfig\.(.+\.)?json$/i.test(basename(fileName));
}
function doesResourceLookLikeATypeScriptFile(resource) {
  return /\.(tsx?|mts|cts)$/i.test(resource.fsPath);
}
function doesResourceLookLikeAJavaScriptFile(resource) {
  return /\.(jsx?|mjs|cjs)$/i.test(resource.fsPath);
}
var standardLanguageDescriptions;
var init_languageDescription = __esm({
  "src/typescript-language-features/src/configuration/languageDescription.ts"() {
    "use strict";
    init_languageIds();
    standardLanguageDescriptions = [
      {
        id: "typescript",
        diagnosticOwner: "typescript",
        diagnosticSource: "ts",
        diagnosticLanguage: 1 /* TypeScript */,
        languageIds: [typescript, typescriptreact],
        configFilePattern: /^tsconfig(\..*)?\.json$/i,
        standardFileExtensions: [
          "ts",
          "tsx",
          "cts",
          "mts"
        ]
      },
      {
        id: "javascript",
        diagnosticOwner: "typescript",
        diagnosticSource: "ts",
        diagnosticLanguage: 0 /* JavaScript */,
        languageIds: [javascript, javascriptreact],
        configFilePattern: /^jsconfig(\..*)?\.json$/i,
        standardFileExtensions: [
          "js",
          "jsx",
          "cjs",
          "mjs",
          "es6",
          "pac"
        ]
      }
    ];
  }
});

// src/typescript-language-features/src/languageFeatures/fileConfigurationManager.ts
import * as path3 from "path";
function areFileConfigurationsEqual(a, b) {
  return equals2(a, b);
}
function withDefaultAsUndefined(value, def) {
  return value === def ? void 0 : value;
}
function getInlayHintsPreferences(config3) {
  return {
    includeInlayParameterNameHints: getInlayParameterNameHintsPreference(config3),
    includeInlayParameterNameHintsWhenArgumentMatchesName: !config3.get(InlayHintSettingNames.parameterNamesSuppressWhenArgumentMatchesName, true),
    includeInlayFunctionParameterTypeHints: config3.get(InlayHintSettingNames.parameterNamesEnabled, false),
    includeInlayVariableTypeHints: config3.get(InlayHintSettingNames.variableTypesEnabled, false),
    includeInlayVariableTypeHintsWhenTypeMatchesName: !config3.get(InlayHintSettingNames.variableTypesSuppressWhenTypeMatchesName, true),
    includeInlayPropertyDeclarationTypeHints: config3.get(InlayHintSettingNames.propertyDeclarationTypesEnabled, false),
    includeInlayFunctionLikeReturnTypeHints: config3.get(InlayHintSettingNames.functionLikeReturnTypesEnabled, false),
    includeInlayEnumMemberValueHints: config3.get(InlayHintSettingNames.enumMemberValuesEnabled, false)
  };
}
function getInlayParameterNameHintsPreference(config3) {
  switch (config3.get("inlayHints.parameterNames.enabled")) {
    case "none":
      return "none";
    case "literals":
      return "literals";
    case "all":
      return "all";
    default:
      return void 0;
  }
}
function getImportModuleSpecifierPreference(config3) {
  switch (config3.get("importModuleSpecifier")) {
    case "project-relative":
      return "project-relative";
    case "relative":
      return "relative";
    case "non-relative":
      return "non-relative";
    default:
      return void 0;
  }
}
function getImportModuleSpecifierEndingPreference(config3) {
  switch (config3.get("importModuleSpecifierEnding")) {
    case "minimal":
      return "minimal";
    case "index":
      return "index";
    case "js":
      return "js";
    default:
      return "auto";
  }
}
function getJsxAttributeCompletionStyle(config3) {
  switch (config3.get("jsxAttributeCompletionStyle")) {
    case "braces":
      return "braces";
    case "none":
      return "none";
    default:
      return "auto";
  }
}
var FileConfigurationManager, InlayHintSettingNames;
var init_fileConfigurationManager = __esm({
  "src/typescript-language-features/src/languageFeatures/fileConfigurationManager.ts"() {
    "use strict";
    init_shims();
    init_fileSchemes();
    init_languageIds();
    init_api2();
    init_dispose();
    init_objects();
    init_resourceMap();
    FileConfigurationManager = class extends Disposable {
      constructor(client, onCaseInsensitiveFileSystem2) {
        super();
        this.client = client;
        this.formatOptions = new ResourceMap(void 0, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 });
        workspace.onDidCloseTextDocument((textDocument) => {
          this.formatOptions.delete(textDocument.uri);
        }, void 0, this._disposables);
      }
      async ensureConfigurationForDocument(document, token) {
        return this.ensureConfigurationOptions(document, void 0, token);
      }
      getFormattingOptions(document) {
        const editor = window.visibleTextEditors.find((editor2) => editor2.document.uri.toString() === document.uri.toString());
        if (!editor) {
          return void 0;
        }
        return {
          tabSize: typeof editor.options.tabSize === "number" ? editor.options.tabSize : void 0,
          insertSpaces: typeof editor.options.insertSpaces === "boolean" ? editor.options.insertSpaces : void 0
        };
      }
      async ensureConfigurationOptions(document, options, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return;
        }
        const currentOptions = this.getFileOptions(document, options);
        const cachedOptions = this.formatOptions.get(document.uri);
        if (cachedOptions) {
          const cachedOptionsValue = await cachedOptions;
          if (token.isCancellationRequested) {
            return;
          }
          if (cachedOptionsValue && areFileConfigurationsEqual(cachedOptionsValue, currentOptions)) {
            return;
          }
        }
        const task = (async () => {
          try {
            const response = await this.client.execute("configure", { file: file2, ...currentOptions }, token);
            return response.type === "response" ? currentOptions : void 0;
          } catch {
            return void 0;
          }
        })();
        this.formatOptions.set(document.uri, task);
        await task;
      }
      async setGlobalConfigurationFromDocument(document, token) {
        const args = {
          file: void 0,
          ...this.getFileOptions(document)
        };
        await this.client.execute("configure", args, token);
      }
      reset() {
        this.formatOptions.clear();
      }
      getFileOptions(document, options) {
        return {
          formatOptions: this.getFormatOptions(document, options),
          preferences: this.getPreferences(document)
        };
      }
      getFormatOptions(document, options) {
        const config3 = workspace.getConfiguration(
          isTypeScriptDocument(document) ? "typescript.format" : "javascript.format",
          document.uri
        );
        const tsEditorConfig = workspace.getConfiguration(
          isTypeScriptDocument(document) ? "vtsls.typescript.format" : "vtsls.javascript.format",
          document.uri
        );
        return {
          tabSize: (options == null ? void 0 : options.tabSize) ?? tsEditorConfig.get("tabSize"),
          baseIndentSize: tsEditorConfig.get("baseIndentSize"),
          indentSize: (options == null ? void 0 : options.tabSize) ?? tsEditorConfig.get("indentSize"),
          indentStyle: tsEditorConfig.get("indentStyle"),
          trimTrailingWhitespace: tsEditorConfig.get("trimTrailingWhitespace"),
          convertTabsToSpaces: (options == null ? void 0 : options.insertSpaces) ?? tsEditorConfig.get("convertTabsToSpaces"),
          // We can use \n here since the editor normalizes later on to its line endings.
          newLineCharacter: tsEditorConfig.get("newLineCharacter") ?? "\n",
          insertSpaceAfterCommaDelimiter: config3.get("insertSpaceAfterCommaDelimiter"),
          insertSpaceAfterConstructor: config3.get("insertSpaceAfterConstructor"),
          insertSpaceAfterSemicolonInForStatements: config3.get("insertSpaceAfterSemicolonInForStatements"),
          insertSpaceBeforeAndAfterBinaryOperators: config3.get("insertSpaceBeforeAndAfterBinaryOperators"),
          insertSpaceAfterKeywordsInControlFlowStatements: config3.get("insertSpaceAfterKeywordsInControlFlowStatements"),
          insertSpaceAfterFunctionKeywordForAnonymousFunctions: config3.get("insertSpaceAfterFunctionKeywordForAnonymousFunctions"),
          insertSpaceBeforeFunctionParenthesis: config3.get("insertSpaceBeforeFunctionParenthesis"),
          insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config3.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis"),
          insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config3.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets"),
          insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config3.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces"),
          insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config3.get("insertSpaceAfterOpeningAndBeforeClosingEmptyBraces"),
          insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config3.get("insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces"),
          insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config3.get("insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces"),
          insertSpaceAfterTypeAssertion: config3.get("insertSpaceAfterTypeAssertion"),
          placeOpenBraceOnNewLineForFunctions: config3.get("placeOpenBraceOnNewLineForFunctions"),
          placeOpenBraceOnNewLineForControlBlocks: config3.get("placeOpenBraceOnNewLineForControlBlocks"),
          semicolons: config3.get("semicolons"),
          indentSwitchCase: config3.get("indentSwitchCase")
        };
      }
      getPreferences(document) {
        var _a;
        const config3 = workspace.getConfiguration(
          isTypeScriptDocument(document) ? "typescript" : "javascript",
          document
        );
        const preferencesConfig = workspace.getConfiguration(
          isTypeScriptDocument(document) ? "typescript.preferences" : "javascript.preferences",
          document
        );
        const preferences = {
          ...config3.get("unstable"),
          quotePreference: this.getQuoteStylePreference(preferencesConfig),
          importModuleSpecifierPreference: getImportModuleSpecifierPreference(preferencesConfig),
          importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(preferencesConfig),
          jsxAttributeCompletionStyle: getJsxAttributeCompletionStyle(preferencesConfig),
          allowTextChangesInNewFiles: document.uri.scheme === file,
          providePrefixAndSuffixTextForRename: preferencesConfig.get("renameShorthandProperties", true) === false ? false : preferencesConfig.get("useAliasesForRenames", true),
          allowRenameOfImportPath: true,
          includeAutomaticOptionalChainCompletions: config3.get("suggest.includeAutomaticOptionalChainCompletions", true),
          provideRefactorNotApplicableReason: true,
          generateReturnInDocTemplate: config3.get("suggest.jsdoc.generateReturns", true),
          includeCompletionsForImportStatements: config3.get("suggest.includeCompletionsForImportStatements", true),
          includeCompletionsWithSnippetText: true,
          includeCompletionsWithClassMemberSnippets: config3.get("suggest.classMemberSnippets.enabled", true),
          includeCompletionsWithObjectLiteralMethodSnippets: config3.get("suggest.objectLiteralMethodSnippets.enabled", true),
          autoImportFileExcludePatterns: this.getAutoImportFileExcludePatternsPreference(preferencesConfig, (_a = workspace.getWorkspaceFolder(document.uri)) == null ? void 0 : _a.uri),
          autoImportSpecifierExcludeRegexes: preferencesConfig.get("autoImportSpecifierExcludeRegexes"),
          preferTypeOnlyAutoImports: preferencesConfig.get("preferTypeOnlyAutoImports", false),
          useLabelDetailsInCompletionEntries: true,
          allowIncompleteCompletions: true,
          displayPartsForJSDoc: true,
          disableLineTextInReferences: true,
          interactiveInlayHints: true,
          includeCompletionsForModuleExports: config3.get("suggest.autoImports"),
          ...getInlayHintsPreferences(config3),
          ...this.getOrganizeImportsPreferences(preferencesConfig)
        };
        return preferences;
      }
      getQuoteStylePreference(config3) {
        switch (config3.get("quoteStyle")) {
          case "single":
            return "single";
          case "double":
            return "double";
          default:
            return "auto";
        }
      }
      getAutoImportFileExcludePatternsPreference(config3, workspaceFolder) {
        var _a;
        return workspaceFolder && ((_a = config3.get("autoImportFileExcludePatterns")) == null ? void 0 : _a.map((p) => {
          const isRelative = /^\.\.?($|[\/\\])/.test(p);
          const wildcardPrefix = this.client.apiVersion.gte(API.v540) ? "" : path3.parse(this.client.toTsFilePath(workspaceFolder)).root;
          return path3.isAbsolute(p) ? p : p.startsWith("*") ? wildcardPrefix + p : isRelative ? this.client.toTsFilePath(Uri.joinPath(workspaceFolder, p)) : wildcardPrefix + "**" + path3.sep + p;
        }));
      }
      getOrganizeImportsPreferences(config3) {
        const organizeImportsCollation = config3.get("organizeImports.unicodeCollation");
        const organizeImportsCaseSensitivity = config3.get("organizeImports.caseSensitivity");
        return {
          // More specific settings
          organizeImportsTypeOrder: withDefaultAsUndefined(config3.get("organizeImports.typeOrder", "auto"), "auto"),
          organizeImportsIgnoreCase: organizeImportsCaseSensitivity === "caseInsensitive" ? true : organizeImportsCaseSensitivity === "caseSensitive" ? false : "auto",
          organizeImportsCollation,
          // The rest of the settings are only applicable when using unicode collation
          ...organizeImportsCollation === "unicode" ? {
            organizeImportsCaseFirst: organizeImportsCaseSensitivity === "caseInsensitive" ? void 0 : withDefaultAsUndefined(config3.get("organizeImports.caseFirst", false), "default"),
            organizeImportsAccentCollation: config3.get("organizeImports.accentCollation"),
            organizeImportsLocale: config3.get("organizeImports.locale"),
            organizeImportsNumericCollation: config3.get("organizeImports.numericCollation")
          } : {}
        };
      }
    };
    InlayHintSettingNames = class {
    };
    InlayHintSettingNames.parameterNamesSuppressWhenArgumentMatchesName = "inlayHints.parameterNames.suppressWhenArgumentMatchesName";
    InlayHintSettingNames.parameterNamesEnabled = "inlayHints.parameterTypes.enabled";
    InlayHintSettingNames.variableTypesEnabled = "inlayHints.variableTypes.enabled";
    InlayHintSettingNames.variableTypesSuppressWhenTypeMatchesName = "inlayHints.variableTypes.suppressWhenTypeMatchesName";
    InlayHintSettingNames.propertyDeclarationTypesEnabled = "inlayHints.propertyDeclarationTypes.enabled";
    InlayHintSettingNames.functionLikeReturnTypesEnabled = "inlayHints.functionLikeReturnTypes.enabled";
    InlayHintSettingNames.enumMemberValuesEnabled = "inlayHints.enumMemberValues.enabled";
  }
});

// src/typescript-language-features/src/configuration/schemes.ts
var Schemes;
var init_schemes = __esm({
  "src/typescript-language-features/src/configuration/schemes.ts"() {
    "use strict";
    Schemes = Object.freeze({
      file: "file",
      untitled: "untitled",
      mailto: "mailto",
      vscode: "vscode",
      "vscode-insiders": "vscode-insiders",
      notebookCell: "vscode-notebook-cell"
    });
  }
});

// src/typescript-language-features/src/languageFeatures/diagnostics.ts
function diagnosticsEquals(a, b) {
  if (a === b) {
    return true;
  }
  return a.code === b.code && a.message === b.message && a.severity === b.severity && a.source === b.source && a.range.isEqual(b.range) && equals(a.relatedInformation || empty, b.relatedInformation || empty, (a2, b2) => {
    return a2.message === b2.message && a2.location.range.isEqual(b2.location.range) && a2.location.uri.fsPath === b2.location.uri.fsPath;
  }) && equals(a.tags || empty, b.tags || empty);
}
function areLanguageDiagnosticSettingsEqual(currentSettings, newSettings) {
  return currentSettings.validate === newSettings.validate && currentSettings.enableSuggestions === newSettings.enableSuggestions;
}
var FileDiagnostics, _DiagnosticSettings, DiagnosticSettings, DiagnosticsTelemetryManager, DiagnosticsManager;
var init_diagnostics2 = __esm({
  "src/typescript-language-features/src/languageFeatures/diagnostics.ts"() {
    "use strict";
    init_shims();
    init_arrays();
    init_dispose();
    init_objects();
    init_resourceMap();
    FileDiagnostics = class {
      constructor(file2, language) {
        this.file = file2;
        this.language = language;
        this._diagnostics = /* @__PURE__ */ new Map();
      }
      updateDiagnostics(language, kind, diagnostics, ranges) {
        if (language !== this.language) {
          this._diagnostics.clear();
          this.language = language;
        }
        const existing = this._diagnostics.get(kind);
        if ((existing == null ? void 0 : existing.length) === 0 && diagnostics.length === 0) {
          return false;
        }
        if (kind === 3 /* RegionSemantic */) {
          return this.updateRegionDiagnostics(diagnostics, ranges);
        }
        this._diagnostics.set(kind, diagnostics);
        return true;
      }
      getAllDiagnostics(settings) {
        if (!settings.getValidate(this.language)) {
          return [];
        }
        return [
          ...this.get(0 /* Syntax */),
          ...this.get(1 /* Semantic */),
          ...this.getSuggestionDiagnostics(settings)
        ];
      }
      delete(toDelete) {
        for (const [type, diags] of this._diagnostics) {
          this._diagnostics.set(type, diags.filter((diag) => !diagnosticsEquals(diag, toDelete)));
        }
      }
      /**
       * @param ranges The ranges whose diagnostics were updated.
       */
      updateRegionDiagnostics(diagnostics, ranges) {
        if (!this._diagnostics.get(1 /* Semantic */)) {
          this._diagnostics.set(1 /* Semantic */, diagnostics);
          return true;
        }
        const oldDiagnostics = this._diagnostics.get(1 /* Semantic */);
        const newDiagnostics = oldDiagnostics.filter((diag) => !ranges.some((range) => diag.range.intersection(range)));
        newDiagnostics.push(...diagnostics);
        this._diagnostics.set(1 /* Semantic */, newDiagnostics);
        return true;
      }
      getSuggestionDiagnostics(settings) {
        const enableSuggestions = settings.getEnableSuggestions(this.language);
        return this.get(2 /* Suggestion */).filter((x) => {
          if (!enableSuggestions) {
            return x.tags && (x.tags.includes(1 /* Unnecessary */) || x.tags.includes(2 /* Deprecated */));
          }
          return true;
        });
      }
      get(kind) {
        return this._diagnostics.get(kind) || [];
      }
    };
    _DiagnosticSettings = class _DiagnosticSettings {
      constructor() {
        this._languageSettings = /* @__PURE__ */ new Map();
      }
      getValidate(language) {
        return this.get(language).validate;
      }
      setValidate(language, value) {
        return this.update(language, (settings) => ({
          validate: value,
          enableSuggestions: settings.enableSuggestions
        }));
      }
      getEnableSuggestions(language) {
        return this.get(language).enableSuggestions;
      }
      setEnableSuggestions(language, value) {
        return this.update(language, (settings) => ({
          validate: settings.validate,
          enableSuggestions: value
        }));
      }
      get(language) {
        return this._languageSettings.get(language) || _DiagnosticSettings.defaultSettings;
      }
      update(language, f) {
        const currentSettings = this.get(language);
        const newSettings = f(currentSettings);
        this._languageSettings.set(language, newSettings);
        return !areLanguageDiagnosticSettingsEqual(currentSettings, newSettings);
      }
    };
    _DiagnosticSettings.defaultSettings = {
      validate: true,
      enableSuggestions: true
    };
    DiagnosticSettings = _DiagnosticSettings;
    DiagnosticsTelemetryManager = class extends Disposable {
      constructor(_telemetryReporter, _diagnosticsCollection) {
        super();
        this._telemetryReporter = _telemetryReporter;
        this._diagnosticsCollection = _diagnosticsCollection;
        this._diagnosticCodesMap = /* @__PURE__ */ new Map();
        this._diagnosticSnapshotsMap = new ResourceMap((uri) => uri.toString(), { onCaseInsensitiveFileSystem: false });
        this._register(workspace.onDidChangeTextDocument((e) => {
          if (e.document.languageId === "typescript" || e.document.languageId === "typescriptreact") {
            this._updateAllDiagnosticCodesAfterTimeout();
          }
        }));
        this._updateAllDiagnosticCodesAfterTimeout();
        this._registerTelemetryEventEmitter();
      }
      logDiagnosticsPerformanceTelemetry(performanceData) {
        for (const data of performanceData) {
          this._telemetryReporter.logTelemetry(
            "diagnostics.performance",
            {
              syntaxDiagDuration: data.syntaxDiag,
              semanticDiagDuration: data.semanticDiag,
              suggestionDiagDuration: data.suggestionDiag,
              regionSemanticDiagDuration: data.regionSemanticDiag,
              fileLineCount: data.fileLineCount
            }
          );
        }
      }
      _updateAllDiagnosticCodesAfterTimeout() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._updateDiagnosticCodes(), 5e3);
      }
      _increaseDiagnosticCodeCount(code) {
        if (code === void 0) {
          return;
        }
        this._diagnosticCodesMap.set(Number(code), (this._diagnosticCodesMap.get(Number(code)) || 0) + 1);
      }
      _updateDiagnosticCodes() {
        this._diagnosticsCollection.forEach((uri, diagnostics) => {
          const previousDiagnostics = this._diagnosticSnapshotsMap.get(uri);
          this._diagnosticSnapshotsMap.set(uri, diagnostics);
          const diagnosticsDiff = diagnostics.filter((diagnostic) => !(previousDiagnostics == null ? void 0 : previousDiagnostics.some((previousDiagnostic) => equals2(diagnostic, previousDiagnostic))));
          diagnosticsDiff.forEach((diagnostic) => {
            const code = diagnostic.code;
            this._increaseDiagnosticCodeCount(typeof code === "string" || typeof code === "number" ? code : code == null ? void 0 : code.value);
          });
        });
      }
      _registerTelemetryEventEmitter() {
        this._telemetryEmitter = setInterval(() => {
          if (this._diagnosticCodesMap.size > 0) {
            let diagnosticCodes = "";
            this._diagnosticCodesMap.forEach((value, key) => {
              diagnosticCodes += `${key}:${value},`;
            });
            this._diagnosticCodesMap.clear();
            this._telemetryReporter.logTelemetry("typescript.diagnostics", {
              diagnosticCodes
            });
          }
        }, 5 * 60 * 1e3);
      }
      dispose() {
        super.dispose();
        clearTimeout(this._timeout);
        clearInterval(this._telemetryEmitter);
      }
    };
    DiagnosticsManager = class extends Disposable {
      constructor(owner, configuration, telemetryReporter, onCaseInsensitiveFileSystem2) {
        super();
        this._settings = new DiagnosticSettings();
        this._updateDelay = 50;
        this._diagnostics = new ResourceMap(void 0, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 });
        this._pendingUpdates = new ResourceMap(void 0, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 });
        this._currentDiagnostics = this._register(languages.createDiagnosticCollection(owner));
        if (Math.random() * 1e3 <= 1 || configuration.enableDiagnosticsTelemetry) {
          this._diagnosticsTelemetryManager = this._register(new DiagnosticsTelemetryManager(telemetryReporter, this._currentDiagnostics));
        }
      }
      dispose() {
        super.dispose();
        for (const value of this._pendingUpdates.values()) {
          clearTimeout(value);
        }
        this._pendingUpdates.clear();
      }
      reInitialize() {
        this._currentDiagnostics.clear();
        this._diagnostics.clear();
      }
      setValidate(language, value) {
        const didUpdate = this._settings.setValidate(language, value);
        if (didUpdate) {
          this.rebuildAll();
        }
      }
      setEnableSuggestions(language, value) {
        const didUpdate = this._settings.setEnableSuggestions(language, value);
        if (didUpdate) {
          this.rebuildAll();
        }
      }
      updateDiagnostics(file2, language, kind, diagnostics, ranges) {
        let didUpdate = false;
        const entry = this._diagnostics.get(file2);
        if (entry) {
          didUpdate = entry.updateDiagnostics(language, kind, diagnostics, ranges);
        } else if (diagnostics.length) {
          const fileDiagnostics = new FileDiagnostics(file2, language);
          fileDiagnostics.updateDiagnostics(language, kind, diagnostics, ranges);
          this._diagnostics.set(file2, fileDiagnostics);
          didUpdate = true;
        }
        if (didUpdate) {
          this.scheduleDiagnosticsUpdate(file2);
        }
      }
      configFileDiagnosticsReceived(file2, diagnostics) {
        this._currentDiagnostics.set(file2, diagnostics);
      }
      deleteAllDiagnosticsInFile(resource) {
        this._currentDiagnostics.delete(resource);
        this._diagnostics.delete(resource);
      }
      deleteDiagnostic(resource, diagnostic) {
        const fileDiagnostics = this._diagnostics.get(resource);
        if (fileDiagnostics) {
          fileDiagnostics.delete(diagnostic);
          this.rebuildFile(fileDiagnostics);
        }
      }
      getDiagnostics(file2) {
        return this._currentDiagnostics.get(file2) || [];
      }
      logDiagnosticsPerformanceTelemetry(performanceData) {
        var _a;
        (_a = this._diagnosticsTelemetryManager) == null ? void 0 : _a.logDiagnosticsPerformanceTelemetry(performanceData);
      }
      scheduleDiagnosticsUpdate(file2) {
        if (!this._pendingUpdates.has(file2)) {
          this._pendingUpdates.set(file2, setTimeout(() => this.updateCurrentDiagnostics(file2), this._updateDelay));
        }
      }
      updateCurrentDiagnostics(file2) {
        if (this._pendingUpdates.has(file2)) {
          clearTimeout(this._pendingUpdates.get(file2));
          this._pendingUpdates.delete(file2);
        }
        const fileDiagnostics = this._diagnostics.get(file2);
        this._currentDiagnostics.set(file2, fileDiagnostics ? fileDiagnostics.getAllDiagnostics(this._settings) : []);
      }
      rebuildAll() {
        this._currentDiagnostics.clear();
        for (const fileDiagnostic of this._diagnostics.values()) {
          this.rebuildFile(fileDiagnostic);
        }
      }
      rebuildFile(fileDiagnostic) {
        this._currentDiagnostics.set(fileDiagnostic.file, fileDiagnostic.getAllDiagnostics(this._settings));
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/cachedResponse.ts
var CachedResponse;
var init_cachedResponse = __esm({
  "src/typescript-language-features/src/tsServer/cachedResponse.ts"() {
    "use strict";
    CachedResponse = class {
      constructor() {
        this.version = -1;
        this.document = "";
      }
      /**
       * Execute a request. May return cached value or resolve the new value
       *
       * Caller must ensure that all input `resolve` functions return equivilent results (keyed only off of document).
       */
      execute(document, resolve) {
        if (this.response && this.matches(document)) {
          return this.response = this.response.then((result) => result.type === "cancelled" ? resolve() : result);
        }
        return this.reset(document, resolve);
      }
      matches(document) {
        return this.version === document.version && this.document === document.uri.toString();
      }
      async reset(document, resolve) {
        this.version = document.version;
        this.document = document.uri.toString();
        return this.response = resolve();
      }
    };
  }
});

// src/typescript-language-features/src/typescriptService.ts
var ServerResponse, ClientCapabilities;
var init_typescriptService = __esm({
  "src/typescript-language-features/src/typescriptService.ts"() {
    "use strict";
    ((ServerResponse3) => {
      class Cancelled {
        constructor(reason) {
          this.reason = reason;
          this.type = "cancelled";
        }
      }
      ServerResponse3.Cancelled = Cancelled;
      ServerResponse3.NoContent = { type: "noContent" };
      ServerResponse3.NoServer = { type: "noServer" };
    })(ServerResponse || (ServerResponse = {}));
    ClientCapabilities = class {
      constructor(...capabilities) {
        this.capabilities = new Set(capabilities);
      }
      has(capability) {
        return this.capabilities.has(capability);
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/protocol/modifiers.ts
function parseKindModifier(kindModifiers) {
  return new Set(kindModifiers.split(/,|\s+/g));
}
var init_modifiers = __esm({
  "src/typescript-language-features/src/tsServer/protocol/modifiers.ts"() {
    "use strict";
  }
});

// src/typescript-language-features/src/tsServer/protocol/protocol.const.ts
var Kind, DiagnosticCategory, _KindModifiers, KindModifiers, DisplayPartKind;
var init_protocol_const = __esm({
  "src/typescript-language-features/src/tsServer/protocol/protocol.const.ts"() {
    "use strict";
    Kind = class {
    };
    Kind.alias = "alias";
    Kind.callSignature = "call";
    Kind.class = "class";
    Kind.const = "const";
    Kind.constructorImplementation = "constructor";
    Kind.constructSignature = "construct";
    Kind.directory = "directory";
    Kind.enum = "enum";
    Kind.enumMember = "enum member";
    Kind.externalModuleName = "external module name";
    Kind.function = "function";
    Kind.indexSignature = "index";
    Kind.interface = "interface";
    Kind.keyword = "keyword";
    Kind.let = "let";
    Kind.localFunction = "local function";
    Kind.localVariable = "local var";
    Kind.method = "method";
    Kind.memberGetAccessor = "getter";
    Kind.memberSetAccessor = "setter";
    Kind.memberVariable = "property";
    Kind.module = "module";
    Kind.primitiveType = "primitive type";
    Kind.script = "script";
    Kind.type = "type";
    Kind.variable = "var";
    Kind.warning = "warning";
    Kind.string = "string";
    Kind.parameter = "parameter";
    Kind.typeParameter = "type parameter";
    DiagnosticCategory = class {
    };
    DiagnosticCategory.error = "error";
    DiagnosticCategory.warning = "warning";
    DiagnosticCategory.suggestion = "suggestion";
    _KindModifiers = class _KindModifiers {
    };
    _KindModifiers.optional = "optional";
    _KindModifiers.deprecated = "deprecated";
    _KindModifiers.color = "color";
    _KindModifiers.dtsFile = ".d.ts";
    _KindModifiers.tsFile = ".ts";
    _KindModifiers.tsxFile = ".tsx";
    _KindModifiers.jsFile = ".js";
    _KindModifiers.jsxFile = ".jsx";
    _KindModifiers.jsonFile = ".json";
    _KindModifiers.fileExtensionKindModifiers = [
      _KindModifiers.dtsFile,
      _KindModifiers.tsFile,
      _KindModifiers.tsxFile,
      _KindModifiers.jsFile,
      _KindModifiers.jsxFile,
      _KindModifiers.jsonFile
    ];
    KindModifiers = _KindModifiers;
    DisplayPartKind = class {
    };
    DisplayPartKind.functionName = "functionName";
    DisplayPartKind.methodName = "methodName";
    DisplayPartKind.parameterName = "parameterName";
    DisplayPartKind.propertyName = "propertyName";
    DisplayPartKind.punctuation = "punctuation";
    DisplayPartKind.text = "text";
  }
});

// src/typescript-language-features/src/typeConverters.ts
var Range4, Position3, Location2, TextEdit3, WorkspaceEdit2, SymbolKind2, CompletionTriggerKind3, OrganizeImportsMode2;
var init_typeConverters = __esm({
  "src/typescript-language-features/src/typeConverters.ts"() {
    "use strict";
    init_shims();
    init_protocol_const();
    ((Range5) => {
      Range5.fromTextSpan = (span) => (0, Range5.fromLocations)(span.start, span.end);
      Range5.toTextSpan = (range) => ({
        start: Position3.toLocation(range.start),
        end: Position3.toLocation(range.end)
      });
      Range5.fromLocations = (start, end) => new Range(
        Math.max(0, start.line - 1),
        Math.max(start.offset - 1, 0),
        Math.max(0, end.line - 1),
        Math.max(0, end.offset - 1)
      );
      Range5.toFileRange = (range) => ({
        startLine: range.start.line + 1,
        startOffset: range.start.character + 1,
        endLine: range.end.line + 1,
        endOffset: range.end.character + 1
      });
      Range5.toFileRangeRequestArgs = (file2, range) => ({
        file: file2,
        ...(0, Range5.toFileRange)(range)
      });
      Range5.toFileRangesRequestArgs = (file2, ranges) => ({
        file: file2,
        ranges: ranges.map(Range5.toFileRange)
      });
      Range5.toFormattingRequestArgs = (file2, range) => ({
        file: file2,
        line: range.start.line + 1,
        offset: range.start.character + 1,
        endLine: range.end.line + 1,
        endOffset: range.end.character + 1
      });
    })(Range4 || (Range4 = {}));
    ((Position4) => {
      Position4.fromLocation = (tslocation) => new Position(tslocation.line - 1, tslocation.offset - 1);
      Position4.toLocation = (vsPosition) => ({
        line: vsPosition.line + 1,
        offset: vsPosition.character + 1
      });
      Position4.toFileLocationRequestArgs = (file2, position) => ({
        file: file2,
        line: position.line + 1,
        offset: position.character + 1
      });
    })(Position3 || (Position3 = {}));
    ((Location3) => {
      Location3.fromTextSpan = (resource, tsTextSpan) => new Location(resource, Range4.fromTextSpan(tsTextSpan));
    })(Location2 || (Location2 = {}));
    ((TextEdit4) => {
      TextEdit4.fromCodeEdit = (edit) => new TextEdit(
        Range4.fromTextSpan(edit),
        edit.newText
      );
    })(TextEdit3 || (TextEdit3 = {}));
    ((WorkspaceEdit3) => {
      function fromFileCodeEdits(client, edits) {
        return withFileCodeEdits(new WorkspaceEdit(), client, edits);
      }
      WorkspaceEdit3.fromFileCodeEdits = fromFileCodeEdits;
      function withFileCodeEdits(workspaceEdit, client, edits) {
        for (const edit of edits) {
          const resource = client.toResource(edit.fileName);
          for (const textChange of edit.textChanges) {
            workspaceEdit.replace(
              resource,
              Range4.fromTextSpan(textChange),
              textChange.newText
            );
          }
        }
        return workspaceEdit;
      }
      WorkspaceEdit3.withFileCodeEdits = withFileCodeEdits;
    })(WorkspaceEdit2 || (WorkspaceEdit2 = {}));
    ((SymbolKind3) => {
      function fromProtocolScriptElementKind(kind) {
        switch (kind) {
          case Kind.module:
            return 1 /* Module */;
          case Kind.class:
            return 4 /* Class */;
          case Kind.enum:
            return 9 /* Enum */;
          case Kind.enumMember:
            return 21 /* EnumMember */;
          case Kind.interface:
            return 10 /* Interface */;
          case Kind.indexSignature:
            return 5 /* Method */;
          case Kind.callSignature:
            return 5 /* Method */;
          case Kind.method:
            return 5 /* Method */;
          case Kind.memberVariable:
            return 6 /* Property */;
          case Kind.memberGetAccessor:
            return 6 /* Property */;
          case Kind.memberSetAccessor:
            return 6 /* Property */;
          case Kind.variable:
            return 12 /* Variable */;
          case Kind.let:
            return 12 /* Variable */;
          case Kind.const:
            return 12 /* Variable */;
          case Kind.localVariable:
            return 12 /* Variable */;
          case Kind.alias:
            return 12 /* Variable */;
          case Kind.function:
            return 11 /* Function */;
          case Kind.localFunction:
            return 11 /* Function */;
          case Kind.constructSignature:
            return 8 /* Constructor */;
          case Kind.constructorImplementation:
            return 8 /* Constructor */;
          case Kind.typeParameter:
            return 25 /* TypeParameter */;
          case Kind.string:
            return 14 /* String */;
          default:
            return 12 /* Variable */;
        }
      }
      SymbolKind3.fromProtocolScriptElementKind = fromProtocolScriptElementKind;
    })(SymbolKind2 || (SymbolKind2 = {}));
    ((CompletionTriggerKind4) => {
      function toProtocolCompletionTriggerKind(kind) {
        switch (kind) {
          case 0 /* Invoke */:
            return 1;
          case 1 /* TriggerCharacter */:
            return 2;
          case 2 /* TriggerForIncompleteCompletions */:
            return 3;
        }
      }
      CompletionTriggerKind4.toProtocolCompletionTriggerKind = toProtocolCompletionTriggerKind;
    })(CompletionTriggerKind3 || (CompletionTriggerKind3 = {}));
    ((OrganizeImportsMode3) => {
      function toProtocolOrganizeImportsMode(mode) {
        switch (mode) {
          case "All" /* All */:
            return "All";
          case "SortAndCombine" /* SortAndCombine */:
            return "SortAndCombine";
          case "RemoveUnused" /* RemoveUnused */:
            return "RemoveUnused";
        }
      }
      OrganizeImportsMode3.toProtocolOrganizeImportsMode = toProtocolOrganizeImportsMode;
    })(OrganizeImportsMode2 || (OrganizeImportsMode2 = {}));
  }
});

// src/typescript-language-features/src/languageFeatures/util/dependentRegistration.ts
function conditionalRegistration(conditions, doRegister) {
  return new ConditionalRegistration(conditions, doRegister);
}
function requireMinVersion(client, minVersion) {
  return new Condition(
    () => client.apiVersion.gte(minVersion),
    client.onTsServerStarted
  );
}
function requireGlobalConfiguration(section, configValue) {
  return new Condition(
    () => {
      const config3 = workspace.getConfiguration(section, null);
      return !!config3.get(configValue);
    },
    workspace.onDidChangeConfiguration
  );
}
function requireSomeCapability(client, ...capabilities) {
  return new Condition(
    () => capabilities.some((requiredCapability) => client.capabilities.has(requiredCapability)),
    client.onDidChangeCapabilities
  );
}
var Condition, ConditionalRegistration;
var init_dependentRegistration = __esm({
  "src/typescript-language-features/src/languageFeatures/util/dependentRegistration.ts"() {
    "use strict";
    init_shims();
    init_dispose();
    Condition = class extends Disposable {
      constructor(getValue, onUpdate) {
        super();
        this.getValue = getValue;
        this._onDidChange = this._register(new EventEmitter());
        this.onDidChange = this._onDidChange.event;
        this._value = this.getValue();
        onUpdate(() => {
          const newValue = this.getValue();
          if (newValue !== this._value) {
            this._value = newValue;
            this._onDidChange.fire();
          }
        });
      }
      get value() {
        return this._value;
      }
    };
    ConditionalRegistration = class {
      constructor(conditions, doRegister) {
        this.conditions = conditions;
        this.doRegister = doRegister;
        this.registration = void 0;
        for (const condition of conditions) {
          condition.onDidChange(() => this.update());
        }
        this.update();
      }
      dispose() {
        var _a;
        (_a = this.registration) == null ? void 0 : _a.dispose();
        this.registration = void 0;
      }
      update() {
        var _a;
        const enabled = this.conditions.every((condition) => condition.value);
        if (enabled) {
          this.registration ??= this.doRegister();
        } else {
          (_a = this.registration) == null ? void 0 : _a.dispose();
          this.registration = void 0;
        }
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/callHierarchy.ts
var callHierarchy_exports = {};
__export(callHierarchy_exports, {
  register: () => register
});
import * as path4 from "path";
function isSourceFileItem(item) {
  return item.kind === Kind.script || item.kind === Kind.module && item.selectionSpan.start.line === 1 && item.selectionSpan.start.offset === 1;
}
function fromProtocolCallHierarchyItem(item) {
  const useFileName = isSourceFileItem(item);
  const name = useFileName ? path4.basename(item.file) : item.name;
  const detail = useFileName ? workspace.asRelativePath(path4.dirname(item.file)) : item.containerName ?? "";
  const result = new CallHierarchyItem(
    SymbolKind2.fromProtocolScriptElementKind(item.kind),
    name,
    detail,
    Uri.file(item.file),
    Range4.fromTextSpan(item.span),
    Range4.fromTextSpan(item.selectionSpan)
  );
  const kindModifiers = item.kindModifiers ? parseKindModifier(item.kindModifiers) : void 0;
  if (kindModifiers == null ? void 0 : kindModifiers.has(KindModifiers.deprecated)) {
    result.tags = [1 /* Deprecated */];
  }
  return result;
}
function fromProtocolCallHierarchyIncomingCall(item) {
  return new CallHierarchyIncomingCall(
    fromProtocolCallHierarchyItem(item.from),
    item.fromSpans.map(Range4.fromTextSpan)
  );
}
function fromProtocolCallHierarchyOutgoingCall(item) {
  return new CallHierarchyOutgoingCall(
    fromProtocolCallHierarchyItem(item.to),
    item.fromSpans.map(Range4.fromTextSpan)
  );
}
function register(selector, client) {
  return conditionalRegistration([
    requireMinVersion(client, TypeScriptCallHierarchySupport.minVersion),
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerCallHierarchyProvider(
      selector.semantic,
      new TypeScriptCallHierarchySupport(client)
    );
  });
}
var TypeScriptCallHierarchySupport;
var init_callHierarchy = __esm({
  "src/typescript-language-features/src/languageFeatures/callHierarchy.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_modifiers();
    init_protocol_const();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    TypeScriptCallHierarchySupport = class {
      constructor(client) {
        this.client = client;
      }
      async prepareCallHierarchy(document, position, token) {
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return void 0;
        }
        const args = Position3.toFileLocationRequestArgs(filepath, position);
        const response = await this.client.execute("prepareCallHierarchy", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        return Array.isArray(response.body) ? response.body.map(fromProtocolCallHierarchyItem) : fromProtocolCallHierarchyItem(response.body);
      }
      async provideCallHierarchyIncomingCalls(item, token) {
        const filepath = this.client.toTsFilePath(item.uri);
        if (!filepath) {
          return void 0;
        }
        const args = Position3.toFileLocationRequestArgs(filepath, item.selectionRange.start);
        const response = await this.client.execute("provideCallHierarchyIncomingCalls", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        return response.body.map(fromProtocolCallHierarchyIncomingCall);
      }
      async provideCallHierarchyOutgoingCalls(item, token) {
        const filepath = this.client.toTsFilePath(item.uri);
        if (!filepath) {
          return void 0;
        }
        const args = Position3.toFileLocationRequestArgs(filepath, item.selectionRange.start);
        const response = await this.client.execute("provideCallHierarchyOutgoingCalls", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        return response.body.map(fromProtocolCallHierarchyOutgoingCall);
      }
    };
    TypeScriptCallHierarchySupport.minVersion = API.v380;
  }
});

// src/typescript-language-features/src/utils/regexp.ts
function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
var init_regexp = __esm({
  "src/typescript-language-features/src/utils/regexp.ts"() {
    "use strict";
  }
});

// src/typescript-language-features/src/languageFeatures/codeLens/baseCodeLensProvider.ts
var baseCodeLensProvider_exports = {};
__export(baseCodeLensProvider_exports, {
  ReferencesCodeLens: () => ReferencesCodeLens,
  TypeScriptBaseCodeLensProvider: () => TypeScriptBaseCodeLensProvider,
  getSymbolRange: () => getSymbolRange
});
function getSymbolRange(document, item) {
  var _a;
  if (item.nameSpan) {
    return Range4.fromTextSpan(item.nameSpan);
  }
  const span = (_a = item.spans) == null ? void 0 : _a[0];
  if (!span) {
    return void 0;
  }
  const range = Range4.fromTextSpan(span);
  const text = document.getText(range);
  const identifierMatch = new RegExp(`^(.*?(\\b|\\W))${escapeRegExp(item.text || "")}(\\b|\\W)`, "gm");
  const match = identifierMatch.exec(text);
  const prefixLength = match ? match.index + match[1].length : 0;
  const startOffset = document.offsetAt(new Position(range.start.line, range.start.character)) + prefixLength;
  return new Range(
    document.positionAt(startOffset),
    document.positionAt(startOffset + item.text.length)
  );
}
var ReferencesCodeLens, TypeScriptBaseCodeLensProvider;
var init_baseCodeLensProvider = __esm({
  "src/typescript-language-features/src/languageFeatures/codeLens/baseCodeLensProvider.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    init_regexp();
    init_dispose();
    ReferencesCodeLens = class extends CodeLens {
      constructor(document, file2, range) {
        super(range);
        this.document = document;
        this.file = file2;
      }
    };
    TypeScriptBaseCodeLensProvider = class extends Disposable {
      constructor(client, cachedResponse) {
        super();
        this.client = client;
        this.cachedResponse = cachedResponse;
        this.changeEmitter = this._register(new EventEmitter());
        this.onDidChangeCodeLenses = this.changeEmitter.event;
      }
      async provideCodeLenses(document, token) {
        var _a, _b;
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return [];
        }
        const response = await this.cachedResponse.execute(document, () => this.client.execute("navtree", { file: filepath }, token));
        if (response.type !== "response") {
          return [];
        }
        const referenceableSpans = [];
        (_b = (_a = response.body) == null ? void 0 : _a.childItems) == null ? void 0 : _b.forEach((item) => this.walkNavTree(document, item, void 0, referenceableSpans));
        return referenceableSpans.map((span) => new ReferencesCodeLens(document.uri, filepath, span));
      }
      walkNavTree(document, item, parent, results) {
        var _a;
        const range = this.extractSymbol(document, item, parent);
        if (range) {
          results.push(range);
        }
        (_a = item.childItems) == null ? void 0 : _a.forEach((child) => this.walkNavTree(document, child, item, results));
      }
    };
    TypeScriptBaseCodeLensProvider.cancelledCommand = {
      // Cancellation is not an error. Just show nothing until we can properly re-compute the code lens
      title: "",
      command: ""
    };
    TypeScriptBaseCodeLensProvider.errorCommand = {
      title: l10n.t("Could not determine references"),
      command: ""
    };
  }
});

// src/typescript-language-features/src/tsServer/callbackMap.ts
var CallbackMap;
var init_callbackMap = __esm({
  "src/typescript-language-features/src/tsServer/callbackMap.ts"() {
    "use strict";
    init_typescriptService();
    CallbackMap = class {
      constructor() {
        this._callbacks = /* @__PURE__ */ new Map();
        this._asyncCallbacks = /* @__PURE__ */ new Map();
      }
      destroy(cause) {
        const cancellation = new ServerResponse.Cancelled(cause);
        for (const callback of this._callbacks.values()) {
          callback.onSuccess(cancellation);
        }
        this._callbacks.clear();
        for (const callback of this._asyncCallbacks.values()) {
          callback.onSuccess(cancellation);
        }
        this._asyncCallbacks.clear();
      }
      add(seq, callback, isAsync) {
        if (isAsync) {
          this._asyncCallbacks.set(seq, callback);
        } else {
          this._callbacks.set(seq, callback);
        }
      }
      fetch(seq) {
        const callback = this._callbacks.get(seq) || this._asyncCallbacks.get(seq);
        this.delete(seq);
        return callback;
      }
      delete(seq) {
        if (!this._callbacks.delete(seq)) {
          this._asyncCallbacks.delete(seq);
        }
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/requestQueue.ts
var RequestQueue;
var init_requestQueue = __esm({
  "src/typescript-language-features/src/tsServer/requestQueue.ts"() {
    "use strict";
    RequestQueue = class {
      constructor() {
        this.queue = [];
        this.sequenceNumber = 0;
      }
      get length() {
        return this.queue.length;
      }
      enqueue(item) {
        if (item.queueingType === 1 /* Normal */) {
          let index = this.queue.length - 1;
          while (index >= 0) {
            if (this.queue[index].queueingType !== 2 /* LowPriority */) {
              break;
            }
            --index;
          }
          this.queue.splice(index + 1, 0, item);
        } else {
          this.queue.push(item);
        }
      }
      dequeue() {
        return this.queue.shift();
      }
      tryDeletePendingRequest(seq) {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i].request.seq === seq) {
            this.queue.splice(i, 1);
            return true;
          }
        }
        return false;
      }
      createRequest(command, args) {
        return {
          seq: this.sequenceNumber++,
          type: "request",
          command,
          arguments: args
        };
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/serverError.ts
var TypeScriptServerError;
var init_serverError = __esm({
  "src/typescript-language-features/src/tsServer/serverError.ts"() {
    "use strict";
    TypeScriptServerError = class _TypeScriptServerError extends Error {
      constructor(serverId, version, response, serverMessage, serverStack, sanitizedStack) {
        super(`<${serverId}> TypeScript Server Error (${version.displayName})
${serverMessage}
${serverStack}`);
        this.serverId = serverId;
        this.version = version;
        this.response = response;
        this.serverMessage = serverMessage;
        this.serverStack = serverStack;
        this.sanitizedStack = sanitizedStack;
      }
      static create(serverId, version, response) {
        const parsedResult = _TypeScriptServerError.parseErrorText(response);
        return new _TypeScriptServerError(serverId, version, response, parsedResult == null ? void 0 : parsedResult.message, parsedResult == null ? void 0 : parsedResult.stack, parsedResult == null ? void 0 : parsedResult.sanitizedStack);
      }
      get serverErrorText() {
        return this.response.message;
      }
      get serverCommand() {
        return this.response.command;
      }
      get telemetry() {
        return {
          command: this.serverCommand,
          serverid: this.serverId,
          sanitizedstack: this.sanitizedStack || "",
          badclient: /\bBADCLIENT\b/.test(this.stack || "")
        };
      }
      /**
       * Given a `errorText` from a tsserver request indicating failure in handling a request,
       * prepares a payload for telemetry-logging.
       */
      static parseErrorText(response) {
        const errorText = response.message;
        if (errorText) {
          const errorPrefix = "Error processing request. ";
          if (errorText.startsWith(errorPrefix)) {
            const prefixFreeErrorText = errorText.substr(errorPrefix.length);
            const newlineIndex = prefixFreeErrorText.indexOf("\n");
            if (newlineIndex >= 0) {
              const stack = prefixFreeErrorText.substring(newlineIndex + 1);
              return {
                message: prefixFreeErrorText.substring(0, newlineIndex),
                stack,
                sanitizedStack: _TypeScriptServerError.sanitizeStack(stack)
              };
            }
          }
        }
        return void 0;
      }
      /**
       * Drop everything but ".js" and line/column numbers (though retain "tsserver" if that's the filename).
       */
      static sanitizeStack(message) {
        if (!message) {
          return "";
        }
        const regex = /(\btsserver)?(\.(?:ts|tsx|js|jsx)(?::\d+(?::\d+)?)?)\)?$/igm;
        let serverStack = "";
        while (true) {
          const match = regex.exec(message);
          if (!match) {
            break;
          }
          serverStack += `${match[1] || "suppressed"}${match[2]}
`;
        }
        return serverStack;
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/server.ts
var _SingleTsServer, SingleTsServer, _RequestRouter, RequestRouter, _GetErrRoutingTsServer, GetErrRoutingTsServer, _SyntaxRoutingTsServer, SyntaxRoutingTsServer, RequestState;
var init_server = __esm({
  "src/typescript-language-features/src/tsServer/server.ts"() {
    "use strict";
    init_shims();
    init_callbackMap();
    init_requestQueue();
    init_serverError();
    init_typescriptService();
    init_dispose();
    init_protocol_const();
    _SingleTsServer = class _SingleTsServer extends Disposable {
      constructor(_serverId, _serverSource, _process, _tsServerLog, _requestCanceller, _version, _telemetryReporter, _tracer) {
        super();
        this._serverId = _serverId;
        this._serverSource = _serverSource;
        this._process = _process;
        this._tsServerLog = _tsServerLog;
        this._requestCanceller = _requestCanceller;
        this._version = _version;
        this._telemetryReporter = _telemetryReporter;
        this._tracer = _tracer;
        this._requestQueue = new RequestQueue();
        this._callbacks = new CallbackMap();
        this._pendingResponses = /* @__PURE__ */ new Set();
        this._onEvent = this._register(new EventEmitter());
        this.onEvent = this._onEvent.event;
        this._onExit = this._register(new EventEmitter());
        this.onExit = this._onExit.event;
        this._onError = this._register(new EventEmitter());
        this.onError = this._onError.event;
        this._process.onData((msg) => {
          this.dispatchMessage(msg);
        });
        this._process.onExit((code, signal) => {
          this._onExit.fire({ code, signal });
          this._callbacks.destroy("server exited");
        });
        this._process.onError((error) => {
          this._onError.fire(error);
          this._callbacks.destroy("server errored");
        });
      }
      get tsServerLog() {
        return this._tsServerLog;
      }
      write(serverRequest) {
        this._process.write(serverRequest);
      }
      dispose() {
        super.dispose();
        this._callbacks.destroy("server disposed");
        this._pendingResponses.clear();
      }
      kill() {
        this._process.kill();
      }
      dispatchMessage(message) {
        try {
          switch (message.type) {
            case "response":
              if (this._serverSource) {
                this.dispatchResponse({
                  ...message,
                  _serverType: this._serverSource
                });
              } else {
                this.dispatchResponse(message);
              }
              break;
            case "event": {
              const event = message;
              if (event.event === "requestCompleted") {
                const seq = event.body.request_seq;
                const callback = this._callbacks.fetch(seq);
                if (callback) {
                  this._tracer.traceRequestCompleted(this._serverId, "requestCompleted", seq, callback);
                  callback.onSuccess(void 0);
                }
                if (event.body.performanceData) {
                  this._onEvent.fire(event);
                }
              } else {
                this._tracer.traceEvent(this._serverId, event);
                this._onEvent.fire(event);
              }
              break;
            }
            default:
              throw new Error(`Unknown message type ${message.type} received`);
          }
        } finally {
          this.sendNextRequests();
        }
      }
      tryCancelRequest(request, command) {
        const seq = request.seq;
        try {
          if (this._requestQueue.tryDeletePendingRequest(seq)) {
            this.logTrace(`Canceled request with sequence number ${seq}`);
            return true;
          }
          if (this._requestCanceller.tryCancelOngoingRequest(seq)) {
            return true;
          }
          this.logTrace(`Tried to cancel request with sequence number ${seq}. But request got already delivered.`);
          return false;
        } finally {
          const callback = this.fetchCallback(seq);
          callback == null ? void 0 : callback.onSuccess(new ServerResponse.Cancelled(`Cancelled request ${seq} - ${command}`));
        }
      }
      dispatchResponse(response) {
        const callback = this.fetchCallback(response.request_seq);
        if (!callback) {
          return;
        }
        this._tracer.traceResponse(this._serverId, response, callback);
        if (response.success) {
          callback.onSuccess(response);
        } else if (response.message === "No content available.") {
          callback.onSuccess(ServerResponse.NoContent);
        } else {
          callback.onError(TypeScriptServerError.create(this._serverId, this._version, response));
        }
      }
      executeImpl(command, args, executeInfo) {
        const request = this._requestQueue.createRequest(command, args);
        const requestInfo = {
          request,
          expectsResponse: executeInfo.expectsResult,
          isAsync: executeInfo.isAsync,
          queueingType: _SingleTsServer.getQueueingType(command, executeInfo.lowPriority)
        };
        let result;
        if (executeInfo.expectsResult) {
          result = new Promise((resolve, reject) => {
            this._callbacks.add(request.seq, { onSuccess: resolve, onError: reject, queuingStartTime: Date.now(), isAsync: executeInfo.isAsync }, executeInfo.isAsync);
            if (executeInfo.token) {
              executeInfo.token.onCancellationRequested(() => {
                this.tryCancelRequest(request, command);
              });
            }
          }).catch((err) => {
            var _a;
            if (err instanceof TypeScriptServerError) {
              if (!((_a = executeInfo.token) == null ? void 0 : _a.isCancellationRequested)) {
                this._telemetryReporter.logTelemetry("languageServiceErrorResponse", err.telemetry);
              }
            }
            throw err;
          });
        }
        this._requestQueue.enqueue(requestInfo);
        this.sendNextRequests();
        return [result];
      }
      sendNextRequests() {
        while (this._pendingResponses.size === 0 && this._requestQueue.length > 0) {
          const item = this._requestQueue.dequeue();
          if (item) {
            this.sendRequest(item);
          }
        }
      }
      sendRequest(requestItem) {
        const serverRequest = requestItem.request;
        this._tracer.traceRequest(this._serverId, serverRequest, requestItem.expectsResponse, this._requestQueue.length);
        if (requestItem.expectsResponse && !requestItem.isAsync) {
          this._pendingResponses.add(requestItem.request.seq);
        }
        try {
          this.write(serverRequest);
        } catch (err) {
          const callback = this.fetchCallback(serverRequest.seq);
          callback == null ? void 0 : callback.onError(err);
        }
      }
      fetchCallback(seq) {
        const callback = this._callbacks.fetch(seq);
        if (!callback) {
          return void 0;
        }
        this._pendingResponses.delete(seq);
        return callback;
      }
      logTrace(message) {
        this._tracer.trace(this._serverId, message);
      }
      static getQueueingType(command, lowPriority) {
        if (_SingleTsServer.fenceCommands.has(command)) {
          return 3 /* Fence */;
        }
        return lowPriority ? 2 /* LowPriority */ : 1 /* Normal */;
      }
    };
    _SingleTsServer.fenceCommands = /* @__PURE__ */ new Set(["change", "close", "open", "updateOpen"]);
    SingleTsServer = _SingleTsServer;
    _RequestRouter = class _RequestRouter {
      constructor(servers, delegate) {
        this.servers = servers;
        this.delegate = delegate;
      }
      execute(command, args, executeInfo) {
        if (_RequestRouter.sharedCommands.has(command) && typeof executeInfo.executionTarget === "undefined") {
          const requestStates = this.servers.map(() => RequestState.Unresolved);
          let token = void 0;
          if (executeInfo.token) {
            const source = new CancellationTokenSource();
            executeInfo.token.onCancellationRequested(() => {
              if (requestStates.some((state) => state === RequestState.Resolved)) {
                return;
              }
              source.cancel();
            });
            token = source.token;
          }
          const allRequests = [];
          for (let serverIndex = 0; serverIndex < this.servers.length; ++serverIndex) {
            const server = this.servers[serverIndex].server;
            const request = server.executeImpl(command, args, { ...executeInfo, token })[0];
            allRequests.push(request);
            if (request) {
              request.then((result) => {
                requestStates[serverIndex] = RequestState.Resolved;
                const erroredRequest = requestStates.find((state) => state.type === RequestState.Type.Errored);
                if (erroredRequest) {
                  this.delegate.onFatalError(command, erroredRequest.err);
                }
                return result;
              }, (err) => {
                requestStates[serverIndex] = new RequestState.Errored(err);
                if (requestStates.some((state) => state === RequestState.Resolved)) {
                  this.delegate.onFatalError(command, err);
                }
                throw err;
              });
            }
          }
          return allRequests;
        }
        for (const { canRun, server } of this.servers) {
          if (!canRun || canRun(command, executeInfo)) {
            return server.executeImpl(command, args, executeInfo);
          }
        }
        throw new Error(`Could not find server for command: '${command}'`);
      }
    };
    _RequestRouter.sharedCommands = /* @__PURE__ */ new Set([
      "change",
      "close",
      "open",
      "updateOpen",
      "configure"
    ]);
    RequestRouter = _RequestRouter;
    _GetErrRoutingTsServer = class _GetErrRoutingTsServer extends Disposable {
      constructor(servers, delegate) {
        super();
        this._onEvent = this._register(new EventEmitter());
        this.onEvent = this._onEvent.event;
        this._onExit = this._register(new EventEmitter());
        this.onExit = this._onExit.event;
        this._onError = this._register(new EventEmitter());
        this.onError = this._onError.event;
        this.getErrServer = servers.getErr;
        this.mainServer = servers.primary;
        this.router = new RequestRouter(
          [
            { server: this.getErrServer, canRun: (command) => ["geterr", "geterrForProject"].includes(command) },
            {
              server: this.mainServer,
              canRun: void 0
              /* gets all other commands */
            }
          ],
          delegate
        );
        this._register(this.getErrServer.onEvent((e) => {
          if (_GetErrRoutingTsServer.diagnosticEvents.has(e.event)) {
            this._onEvent.fire(e);
          }
        }));
        this._register(this.mainServer.onEvent((e) => {
          if (!_GetErrRoutingTsServer.diagnosticEvents.has(e.event)) {
            this._onEvent.fire(e);
          }
        }));
        this._register(this.getErrServer.onError((e) => this._onError.fire(e)));
        this._register(this.mainServer.onError((e) => this._onError.fire(e)));
        this._register(this.mainServer.onExit((e) => {
          this._onExit.fire(e);
          this.getErrServer.kill();
        }));
      }
      get tsServerLog() {
        return this.mainServer.tsServerLog;
      }
      kill() {
        this.getErrServer.kill();
        this.mainServer.kill();
      }
      executeImpl(command, args, executeInfo) {
        return this.router.execute(command, args, executeInfo);
      }
    };
    _GetErrRoutingTsServer.diagnosticEvents = /* @__PURE__ */ new Set([
      "configFileDiag" /* configFileDiag */,
      "syntaxDiag" /* syntaxDiag */,
      "semanticDiag" /* semanticDiag */,
      "suggestionDiag" /* suggestionDiag */
    ]);
    GetErrRoutingTsServer = _GetErrRoutingTsServer;
    _SyntaxRoutingTsServer = class _SyntaxRoutingTsServer extends Disposable {
      constructor(servers, delegate, enableDynamicRouting) {
        super();
        this._projectLoading = true;
        this._onEvent = this._register(new EventEmitter());
        this.onEvent = this._onEvent.event;
        this._onExit = this._register(new EventEmitter());
        this.onExit = this._onExit.event;
        this._onError = this._register(new EventEmitter());
        this.onError = this._onError.event;
        this.syntaxServer = servers.syntax;
        this.semanticServer = servers.semantic;
        this.router = new RequestRouter(
          [
            {
              server: this.syntaxServer,
              canRun: (command, execInfo) => {
                switch (execInfo.executionTarget) {
                  case 0 /* Semantic */:
                    return false;
                  case 1 /* Syntax */:
                    return true;
                }
                if (_SyntaxRoutingTsServer.syntaxAlwaysCommands.has(command)) {
                  return true;
                }
                if (_SyntaxRoutingTsServer.semanticCommands.has(command)) {
                  return false;
                }
                if (enableDynamicRouting && this.projectLoading && _SyntaxRoutingTsServer.syntaxAllowedCommands.has(command)) {
                  return true;
                }
                return false;
              }
            },
            {
              server: this.semanticServer,
              canRun: void 0
              /* gets all other commands */
            }
          ],
          delegate
        );
        this._register(this.syntaxServer.onEvent((e) => {
          return this._onEvent.fire(e);
        }));
        this._register(this.semanticServer.onEvent((e) => {
          switch (e.event) {
            case "projectLoadingStart" /* projectLoadingStart */:
              this._projectLoading = true;
              break;
            case "projectLoadingFinish" /* projectLoadingFinish */:
            case "semanticDiag" /* semanticDiag */:
            case "syntaxDiag" /* syntaxDiag */:
            case "suggestionDiag" /* suggestionDiag */:
            case "configFileDiag" /* configFileDiag */:
              this._projectLoading = false;
              break;
          }
          return this._onEvent.fire(e);
        }));
        this._register(this.semanticServer.onExit((e) => {
          this._onExit.fire(e);
          this.syntaxServer.kill();
        }));
        this._register(this.semanticServer.onError((e) => this._onError.fire(e)));
      }
      get projectLoading() {
        return this._projectLoading;
      }
      get tsServerLog() {
        return this.semanticServer.tsServerLog;
      }
      kill() {
        this.syntaxServer.kill();
        this.semanticServer.kill();
      }
      executeImpl(command, args, executeInfo) {
        return this.router.execute(command, args, executeInfo);
      }
    };
    /**
     * Commands that should always be run on the syntax server.
     */
    _SyntaxRoutingTsServer.syntaxAlwaysCommands = /* @__PURE__ */ new Set([
      "navtree",
      "getOutliningSpans",
      "jsxClosingTag",
      "selectionRange",
      "format",
      "formatonkey",
      "docCommentTemplate",
      "linkedEditingRange"
    ]);
    /**
     * Commands that should always be run on the semantic server.
     */
    _SyntaxRoutingTsServer.semanticCommands = /* @__PURE__ */ new Set([
      "geterr",
      "geterrForProject",
      "projectInfo",
      "configurePlugin"
    ]);
    /**
     * Commands that can be run on the syntax server but would benefit from being upgraded to the semantic server.
     */
    _SyntaxRoutingTsServer.syntaxAllowedCommands = /* @__PURE__ */ new Set([
      "completions",
      "completionEntryDetails",
      "completionInfo",
      "definition",
      "definitionAndBoundSpan",
      "documentHighlights",
      "implementation",
      "navto",
      "quickinfo",
      "references",
      "rename",
      "signatureHelp"
    ]);
    SyntaxRoutingTsServer = _SyntaxRoutingTsServer;
    ((RequestState2) => {
      let Type;
      ((Type2) => {
        Type2[Type2["Unresolved"] = 0] = "Unresolved";
        Type2[Type2["Resolved"] = 1] = "Resolved";
        Type2[Type2["Errored"] = 2] = "Errored";
      })(Type = RequestState2.Type || (RequestState2.Type = {}));
      RequestState2.Unresolved = { type: 0 /* Unresolved */ };
      RequestState2.Resolved = { type: 1 /* Resolved */ };
      class Errored {
        constructor(err) {
          this.err = err;
          this.type = 2 /* Errored */;
        }
      }
      RequestState2.Errored = Errored;
    })(RequestState || (RequestState = {}));
  }
});

// src/typescript-language-features/src/languageFeatures/codeLens/implementationsCodeLens.ts
var implementationsCodeLens_exports = {};
__export(implementationsCodeLens_exports, {
  default: () => TypeScriptImplementationsCodeLensProvider,
  register: () => register2
});
function register2(selector, language, client, cachedResponse) {
  return conditionalRegistration([
    requireGlobalConfiguration(language.id, "implementationsCodeLens.enabled"),
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerCodeLensProvider(
      selector.semantic,
      new TypeScriptImplementationsCodeLensProvider(client, cachedResponse, language)
    );
  });
}
var TypeScriptImplementationsCodeLensProvider;
var init_implementationsCodeLens = __esm({
  "src/typescript-language-features/src/languageFeatures/codeLens/implementationsCodeLens.ts"() {
    "use strict";
    init_shims();
    init_protocol_const();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    init_baseCodeLensProvider();
    init_server();
    TypeScriptImplementationsCodeLensProvider = class extends TypeScriptBaseCodeLensProvider {
      constructor(client, _cachedResponse, language) {
        super(client, _cachedResponse);
        this._cachedResponse = _cachedResponse;
        this.language = language;
        this._register(
          workspace.onDidChangeConfiguration((evt) => {
            if (evt.affectsConfiguration(`${language.id}.implementationsCodeLens.showOnInterfaceMethods`)) {
              this.changeEmitter.fire();
            }
          })
        );
      }
      async resolveCodeLens(codeLens, token) {
        const args = Position3.toFileLocationRequestArgs(codeLens.file, codeLens.range.start);
        const response = await this.client.execute("implementation", args, token, {
          lowPriority: true,
          executionTarget: 0 /* Semantic */,
          cancelOnResourceChange: codeLens.document
        });
        if (response.type !== "response" || !response.body) {
          codeLens.command = response.type === "cancelled" ? TypeScriptBaseCodeLensProvider.cancelledCommand : TypeScriptBaseCodeLensProvider.errorCommand;
          return codeLens;
        }
        const locations = response.body.map((reference) => (
          // Only take first line on implementation: https://github.com/microsoft/vscode/issues/23924
          new Location(
            this.client.toResource(reference.file),
            reference.start.line === reference.end.line ? Range4.fromTextSpan(reference) : new Range(
              Position3.fromLocation(reference.start),
              new Position(reference.start.line, 0)
            )
          )
        )).filter((location) => !(location.uri.toString() === codeLens.document.toString() && location.range.start.line === codeLens.range.start.line && location.range.start.character === codeLens.range.start.character));
        codeLens.command = this.getCommand(locations, codeLens);
        return codeLens;
      }
      getCommand(locations, codeLens) {
        return {
          title: this.getTitle(locations),
          command: locations.length ? "editor.action.showReferences" : "",
          arguments: [codeLens.document, codeLens.range.start, locations]
        };
      }
      getTitle(locations) {
        return locations.length === 1 ? l10n.t("1 implementation") : l10n.t("{0} implementations", locations.length);
      }
      extractSymbol(document, item, parent) {
        if (item.kind === Kind.method && parent && parent.kind === Kind.interface && workspace.getConfiguration(this.language.id).get("implementationsCodeLens.showOnInterfaceMethods")) {
          return getSymbolRange(document, item);
        }
        switch (item.kind) {
          case Kind.interface:
            return getSymbolRange(document, item);
          case Kind.class:
          case Kind.method:
          case Kind.memberVariable:
          case Kind.memberGetAccessor:
          case Kind.memberSetAccessor:
            if (item.kindModifiers.match(/\babstract\b/g)) {
              return getSymbolRange(document, item);
            }
            break;
        }
        return void 0;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/codeLens/referencesCodeLens.ts
var referencesCodeLens_exports = {};
__export(referencesCodeLens_exports, {
  TypeScriptReferencesCodeLensProvider: () => TypeScriptReferencesCodeLensProvider,
  register: () => register3
});
function register3(selector, language, client, cachedResponse) {
  return conditionalRegistration([
    requireGlobalConfiguration(language.id, "referencesCodeLens.enabled"),
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerCodeLensProvider(
      selector.semantic,
      new TypeScriptReferencesCodeLensProvider(client, cachedResponse, language)
    );
  });
}
var TypeScriptReferencesCodeLensProvider;
var init_referencesCodeLens = __esm({
  "src/typescript-language-features/src/languageFeatures/codeLens/referencesCodeLens.ts"() {
    "use strict";
    init_shims();
    init_protocol_const();
    init_server();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    init_baseCodeLensProvider();
    TypeScriptReferencesCodeLensProvider = class extends TypeScriptBaseCodeLensProvider {
      constructor(client, _cachedResponse, language) {
        super(client, _cachedResponse);
        this._cachedResponse = _cachedResponse;
        this.language = language;
        this._register(
          workspace.onDidChangeConfiguration((evt) => {
            if (evt.affectsConfiguration(`${language.id}.referencesCodeLens.showOnAllFunctions`)) {
              this.changeEmitter.fire();
            }
          })
        );
      }
      async resolveCodeLens(codeLens, token) {
        const args = Position3.toFileLocationRequestArgs(codeLens.file, codeLens.range.start);
        const response = await this.client.execute("references", args, token, {
          lowPriority: true,
          executionTarget: 0 /* Semantic */,
          cancelOnResourceChange: codeLens.document
        });
        if (response.type !== "response" || !response.body) {
          codeLens.command = response.type === "cancelled" ? TypeScriptBaseCodeLensProvider.cancelledCommand : TypeScriptBaseCodeLensProvider.errorCommand;
          return codeLens;
        }
        const locations = response.body.refs.filter((reference) => !reference.isDefinition).map((reference) => Location2.fromTextSpan(this.client.toResource(reference.file), reference));
        codeLens.command = {
          title: this.getCodeLensLabel(locations),
          command: locations.length ? "editor.action.showReferences" : "",
          arguments: [codeLens.document, codeLens.range.start, locations]
        };
        return codeLens;
      }
      getCodeLensLabel(locations) {
        return locations.length === 1 ? l10n.t("1 reference") : l10n.t("{0} references", locations.length);
      }
      extractSymbol(document, item, parent) {
        if (parent && parent.kind === Kind.enum) {
          return getSymbolRange(document, item);
        }
        switch (item.kind) {
          case Kind.function: {
            const showOnAllFunctions = workspace.getConfiguration(this.language.id).get("referencesCodeLens.showOnAllFunctions");
            if (showOnAllFunctions && item.nameSpan) {
              return getSymbolRange(document, item);
            }
          }
          // fallthrough
          case Kind.const:
          case Kind.let:
          case Kind.variable:
            if (/\bexport\b/.test(item.kindModifiers)) {
              return getSymbolRange(document, item);
            }
            break;
          case Kind.class:
            if (item.text === "<class>") {
              break;
            }
            return getSymbolRange(document, item);
          case Kind.interface:
          case Kind.type:
          case Kind.enum:
            return getSymbolRange(document, item);
          case Kind.method:
          case Kind.memberGetAccessor:
          case Kind.memberSetAccessor:
          case Kind.constructorImplementation:
          case Kind.memberVariable:
            if (parent && Position3.fromLocation(parent.spans[0].start).isEqual(Position3.fromLocation(item.spans[0].start))) {
              return void 0;
            }
            switch (parent == null ? void 0 : parent.kind) {
              case Kind.class:
              case Kind.interface:
              case Kind.type:
                return getSymbolRange(document, item);
            }
            break;
        }
        return void 0;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/util/codeAction.ts
function getEditForCodeAction(client, action) {
  var _a;
  return ((_a = action.changes) == null ? void 0 : _a.length) ? WorkspaceEdit2.fromFileCodeEdits(client, action.changes) : void 0;
}
async function applyCodeAction(client, action, token) {
  const workspaceEdit = getEditForCodeAction(client, action);
  if (workspaceEdit) {
    if (!await workspace.applyEdit(workspaceEdit)) {
      return false;
    }
  }
  return applyCodeActionCommands(client, action.commands, token);
}
async function applyCodeActionCommands(client, commands3, token) {
  if (commands3 == null ? void 0 : commands3.length) {
    for (const command of commands3) {
      await client.execute("applyCodeActionCommand", { command }, token);
    }
  }
  return true;
}
var init_codeAction = __esm({
  "src/typescript-language-features/src/languageFeatures/util/codeAction.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
  }
});

// src/typescript-language-features/src/languageFeatures/util/snippetForFunctionCall.ts
function snippetForFunctionCall(item, displayParts) {
  if (item.insertText && typeof item.insertText !== "string") {
    return { snippet: item.insertText, parameterCount: 0 };
  }
  const parameterListParts = getParameterListParts(displayParts);
  const snippet = new SnippetString();
  snippet.appendText(`${item.insertText || item.label}(`);
  appendJoinedPlaceholders(snippet, parameterListParts.parts, ", ");
  if (parameterListParts.hasOptionalParameters) {
    snippet.appendTabstop();
  }
  snippet.appendText(")");
  snippet.appendTabstop(0);
  return { snippet, parameterCount: parameterListParts.parts.length + (parameterListParts.hasOptionalParameters ? 1 : 0) };
}
function appendJoinedPlaceholders(snippet, parts, joiner) {
  for (let i = 0; i < parts.length; ++i) {
    const paramterPart = parts[i];
    snippet.appendPlaceholder(paramterPart.text);
    if (i !== parts.length - 1) {
      snippet.appendText(joiner);
    }
  }
}
function getParameterListParts(displayParts) {
  const parts = [];
  let optionalParams = [];
  let isInMethod = false;
  let hasOptionalParameters = false;
  let parenCount = 0;
  let braceCount = 0;
  outer: for (let i = 0; i < displayParts.length; ++i) {
    const part = displayParts[i];
    switch (part.kind) {
      case DisplayPartKind.methodName:
      case DisplayPartKind.functionName:
      case DisplayPartKind.text:
      case DisplayPartKind.propertyName:
        if (parenCount === 0 && braceCount === 0) {
          isInMethod = true;
        }
        break;
      case DisplayPartKind.parameterName:
        if (parenCount === 1 && braceCount === 0 && isInMethod) {
          const next = displayParts[i + 1];
          const nameIsFollowedByOptionalIndicator = next && next.text === "?";
          const nameIsThis = part.text === "this";
          if (nameIsFollowedByOptionalIndicator) {
            optionalParams.push(part);
          } else {
            parts.push(...optionalParams);
            optionalParams = [];
          }
          if (!nameIsFollowedByOptionalIndicator && !nameIsThis) {
            parts.push(part);
          }
          hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
        }
        break;
      case DisplayPartKind.punctuation:
        if (part.text === "(") {
          ++parenCount;
        } else if (part.text === ")") {
          --parenCount;
          if (parenCount <= 0 && isInMethod) {
            break outer;
          }
        } else if (part.text === "..." && parenCount === 1) {
          hasOptionalParameters = true;
          break outer;
        } else if (part.text === "{") {
          ++braceCount;
        } else if (part.text === "}") {
          --braceCount;
        }
        break;
    }
  }
  return { hasOptionalParameters, parts };
}
var init_snippetForFunctionCall = __esm({
  "src/typescript-language-features/src/languageFeatures/util/snippetForFunctionCall.ts"() {
    "use strict";
    init_shims();
    init_protocol_const();
  }
});

// src/typescript-language-features/src/languageFeatures/util/textRendering.ts
function getTagBodyText(tag, filePathConverter) {
  if (!tag.text) {
    return void 0;
  }
  function makeCodeblock(text2) {
    if (/^\s*[~`]{3}/m.test(text2)) {
      return text2;
    }
    return "```tsx\n" + text2 + "\n```";
  }
  let text = convertLinkTags(tag.text, filePathConverter);
  switch (tag.name) {
    case "example": {
      text = asPlainText(tag.text);
      const captionTagMatches = text.match(/<caption>(.*?)<\/caption>\s*(\r\n|\n)/);
      if (captionTagMatches && captionTagMatches.index === 0) {
        return captionTagMatches[1] + "\n" + makeCodeblock(text.substr(captionTagMatches[0].length));
      } else {
        return makeCodeblock(text);
      }
    }
    case "author": {
      const emailMatch = text.match(/(.+)\s<([-.\w]+@[-.\w]+)>/);
      if (emailMatch === null) {
        return text;
      } else {
        return `${emailMatch[1]} ${emailMatch[2]}`;
      }
    }
    case "default": {
      return makeCodeblock(text);
    }
    default: {
      return text;
    }
  }
}
function getTagDocumentation(tag, filePathConverter) {
  var _a;
  switch (tag.name) {
    case "augments":
    case "extends":
    case "param":
    case "template": {
      const body = getTagBody(tag, filePathConverter);
      if ((body == null ? void 0 : body.length) === 3) {
        const param = body[1];
        const doc = body[2];
        const label2 = `*@${tag.name}* \`${param}\``;
        if (!doc) {
          return label2;
        }
        return label2 + (doc.match(/\r\n|\n/g) ? "  \n" + doc : ` \u2014 ${doc}`);
      }
      break;
    }
    case "return":
    case "returns": {
      if (!((_a = tag.text) == null ? void 0 : _a.length)) {
        return void 0;
      }
      break;
    }
  }
  const label = `*@${tag.name}*`;
  const text = getTagBodyText(tag, filePathConverter);
  if (!text) {
    return label;
  }
  return label + (text.match(/\r\n|\n/g) ? "  \n" + text : ` \u2014 ${text}`);
}
function getTagBody(tag, filePathConverter) {
  if (tag.name === "template") {
    const parts = tag.text;
    if (parts && typeof parts !== "string") {
      const params = parts.filter((p) => p.kind === "typeParameterName").map((p) => p.text).join(", ");
      const docs = parts.filter((p) => p.kind === "text").map((p) => convertLinkTags(p.text.replace(/^\s*-?\s*/, ""), filePathConverter)).join(" ");
      return params ? ["", params, docs] : void 0;
    }
  }
  return convertLinkTags(tag.text, filePathConverter).split(/^(\S+)\s*-?\s*/);
}
function asPlainText(parts) {
  if (typeof parts === "string") {
    return parts;
  }
  return parts.map((part) => part.text).join("");
}
function asPlainTextWithLinks(parts, filePathConverter) {
  return convertLinkTags(parts, filePathConverter);
}
function convertLinkTags(parts, filePathConverter) {
  if (!parts) {
    return "";
  }
  if (typeof parts === "string") {
    return parts;
  }
  const out = [];
  let currentLink;
  for (const part of parts) {
    switch (part.kind) {
      case "link":
        if (currentLink) {
          if (currentLink.target) {
            const link = filePathConverter.toResource(currentLink.target.file).with({
              fragment: `L${currentLink.target.start.line},${currentLink.target.start.offset}`
            });
            const linkText = currentLink.text ? currentLink.text : escapeMarkdownSyntaxTokensForCode(currentLink.name ?? "");
            out.push(`[${currentLink.linkcode ? "`" + linkText + "`" : linkText}](${link.toString()})`);
          } else {
            const text = currentLink.text ?? currentLink.name;
            if (text) {
              if (/^https?:/.test(text)) {
                const parts2 = text.split(" ");
                if (parts2.length === 1 && !currentLink.linkcode) {
                  out.push(`<${parts2[0]}>`);
                } else {
                  const linkText = parts2.length > 1 ? parts2.slice(1).join(" ") : parts2[0];
                  out.push(`[${currentLink.linkcode ? "`" + escapeMarkdownSyntaxTokensForCode(linkText) + "`" : linkText}](${parts2[0]})`);
                }
              } else {
                out.push(escapeMarkdownSyntaxTokensForCode(text));
              }
            }
          }
          currentLink = void 0;
        } else {
          currentLink = {
            linkcode: part.text === "{@linkcode "
          };
        }
        break;
      case "linkName":
        if (currentLink) {
          currentLink.name = part.text;
          currentLink.target = part.target;
        }
        break;
      case "linkText":
        if (currentLink) {
          currentLink.text = part.text;
        }
        break;
      default:
        out.push(part.text);
        break;
    }
  }
  return out.join("");
}
function escapeMarkdownSyntaxTokensForCode(text) {
  return text.replace(/`/g, "\\$&");
}
function tagsToMarkdown(tags, filePathConverter) {
  return tags.map((tag) => getTagDocumentation(tag, filePathConverter)).join("  \n\n");
}
function documentationToMarkdown(documentation, tags, filePathConverter, baseUri) {
  const out = new MarkdownString();
  appendDocumentationAsMarkdown(out, documentation, tags, filePathConverter);
  out.baseUri = baseUri;
  out.isTrusted = { enabledCommands: [OpenJsDocLinkCommand.id] };
  return out;
}
function appendDocumentationAsMarkdown(out, documentation, tags, converter) {
  if (documentation) {
    out.appendMarkdown(asPlainTextWithLinks(documentation, converter));
  }
  if (tags) {
    const tagsPreview = tagsToMarkdown(tags, converter);
    if (tagsPreview) {
      out.appendMarkdown("\n\n" + tagsPreview);
    }
  }
  out.isTrusted = { enabledCommands: [OpenJsDocLinkCommand.id] };
  return out;
}
var init_textRendering = __esm({
  "src/typescript-language-features/src/languageFeatures/util/textRendering.ts"() {
    "use strict";
    init_shims();
    init_openJsDocLink();
  }
});

// src/typescript-language-features/src/languageFeatures/completions.ts
var completions_exports = {};
__export(completions_exports, {
  register: () => register4
});
function getScriptKindDetails(tsEntry) {
  if (!tsEntry.kindModifiers || tsEntry.kind !== Kind.script) {
    return;
  }
  const kindModifiers = parseKindModifier(tsEntry.kindModifiers);
  for (const extModifier of KindModifiers.fileExtensionKindModifiers) {
    if (kindModifiers.has(extModifier)) {
      if (tsEntry.name.toLowerCase().endsWith(extModifier)) {
        return tsEntry.name;
      } else {
        return tsEntry.name + extModifier;
      }
    }
  }
  return void 0;
}
function shouldExcludeCompletionEntry(element, completionConfiguration) {
  return !completionConfiguration.nameSuggestions && element.kind === Kind.warning || !completionConfiguration.pathSuggestions && (element.kind === Kind.directory || element.kind === Kind.script || element.kind === Kind.externalModuleName) || !completionConfiguration.autoImportSuggestions && element.hasAction;
}
function register4(selector, language, client, typingsStatus, fileConfigurationManager, commandManager, telemetryReporter, onCompletionAccepted) {
  return conditionalRegistration([
    requireSomeCapability(client, 1 /* EnhancedSyntax */, 2 /* Semantic */)
  ], () => {
    return languages.registerCompletionItemProvider(
      selector.syntax,
      new TypeScriptCompletionItemProvider(client, language, typingsStatus, fileConfigurationManager, commandManager, telemetryReporter, onCompletionAccepted),
      ...TypeScriptCompletionItemProvider.triggerCharacters
    );
  });
}
var MyCompletionItem, _CompletionAcceptedCommand, CompletionAcceptedCommand, _ApplyCompletionCommand, ApplyCompletionCommand, _ApplyCompletionCodeActionCommand, ApplyCompletionCodeActionCommand, CompletionConfiguration, TypeScriptCompletionItemProvider;
var init_completions = __esm({
  "src/typescript-language-features/src/languageFeatures/completions.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_modifiers();
    init_protocol_const();
    init_typeConverters();
    init_typescriptService();
    init_cancellation();
    init_codeAction();
    init_dependentRegistration();
    init_snippetForFunctionCall();
    init_textRendering();
    MyCompletionItem = class _MyCompletionItem extends CompletionItem {
      constructor(position, document, tsEntry, completionContext, metadata, client, defaultCommitCharacters) {
        const label = tsEntry.name || (tsEntry.insertText ?? "");
        super(label, _MyCompletionItem.convertKind(tsEntry.kind));
        this.position = position;
        this.document = document;
        this.tsEntry = tsEntry;
        this.completionContext = completionContext;
        this.metadata = metadata;
        if (tsEntry.source && tsEntry.hasAction && client.apiVersion.lt(API.v490)) {
          this.sortText = "\uFFFF" + tsEntry.sortText;
        } else {
          this.sortText = tsEntry.sortText;
        }
        if (tsEntry.source && tsEntry.hasAction) {
          const qualifierCandidate = workspace.asRelativePath(tsEntry.source);
          if (qualifierCandidate !== tsEntry.source) {
            this.label = { label, description: qualifierCandidate };
          }
        }
        const { sourceDisplay, isSnippet } = tsEntry;
        if (sourceDisplay) {
          this.label = { label, description: asPlainTextWithLinks(sourceDisplay, client) };
        }
        if (tsEntry.labelDetails) {
          this.label = { label, ...tsEntry.labelDetails };
        }
        this.preselect = tsEntry.isRecommended;
        this.position = position;
        this.useCodeSnippet = completionContext.completeFunctionCalls && (this.kind === 2 /* Function */ || this.kind === 1 /* Method */);
        this.range = this.getRangeFromReplacementSpan(tsEntry, completionContext);
        this.commitCharacters = _MyCompletionItem.getCommitCharacters(completionContext, tsEntry, defaultCommitCharacters);
        this.insertText = isSnippet && tsEntry.insertText ? new SnippetString(tsEntry.insertText) : tsEntry.insertText;
        this.filterText = tsEntry.filterText || this.getFilterText(completionContext.line, tsEntry.insertText);
        if (completionContext.isMemberCompletion && completionContext.dotAccessorContext && !(this.insertText instanceof SnippetString)) {
          this.filterText = completionContext.dotAccessorContext.text + (this.insertText || this.textLabel);
          if (!this.range) {
            const replacementRange = this.completionContext.wordRange;
            if (replacementRange) {
              this.range = {
                inserting: completionContext.dotAccessorContext.range,
                replacing: completionContext.dotAccessorContext.range.union(replacementRange)
              };
            } else {
              this.range = completionContext.dotAccessorContext.range;
            }
            this.insertText = this.filterText;
          }
        }
        if (tsEntry.kindModifiers) {
          const kindModifiers = parseKindModifier(tsEntry.kindModifiers);
          if (kindModifiers.has(KindModifiers.optional)) {
            this.insertText ??= this.textLabel;
            this.filterText ??= this.textLabel;
            if (typeof this.label === "string") {
              this.label += "?";
            } else {
              this.label.label += "?";
            }
          }
          if (kindModifiers.has(KindModifiers.deprecated)) {
            this.tags = [1 /* Deprecated */];
          }
          if (kindModifiers.has(KindModifiers.color)) {
            this.kind = 15 /* Color */;
          }
          this.detail = getScriptKindDetails(tsEntry);
        }
        this.resolveRange();
      }
      get textLabel() {
        return typeof this.label === "string" ? this.label : this.label.label;
      }
      async resolveCompletionItem(client, token) {
        token.onCancellationRequested(() => {
          if (this._resolvedPromise && --this._resolvedPromise.waiting <= 0) {
            setTimeout(() => {
              if (this._resolvedPromise && this._resolvedPromise.waiting <= 0) {
                this._resolvedPromise.requestToken.cancel();
              }
            }, 300);
          }
        });
        if (this._resolvedPromise) {
          ++this._resolvedPromise.waiting;
          return this._resolvedPromise.promise;
        }
        const requestToken = new CancellationTokenSource();
        const promise = (async () => {
          var _a;
          const filepath = client.toOpenTsFilePath(this.document);
          if (!filepath) {
            return void 0;
          }
          const args = {
            ...Position3.toFileLocationRequestArgs(filepath, this.position),
            entryNames: [
              this.tsEntry.source || this.tsEntry.data ? {
                name: this.tsEntry.name,
                source: this.tsEntry.source,
                data: this.tsEntry.data
              } : this.tsEntry.name
            ]
          };
          const response = await client.interruptGetErr(() => client.execute("completionEntryDetails", args, requestToken.token));
          if (response.type !== "response" || !((_a = response.body) == null ? void 0 : _a.length)) {
            return void 0;
          }
          const detail = response.body[0];
          const newItemDetails = this.getDetails(client, detail);
          if (newItemDetails) {
            this.detail = newItemDetails;
          }
          this.documentation = this.getDocumentation(client, detail, this.document.uri);
          const codeAction = this.getCodeActions(detail, filepath, client);
          const commands3 = [{
            command: CompletionAcceptedCommand.ID,
            title: "",
            arguments: [this]
          }];
          if (codeAction.command) {
            commands3.push(codeAction.command);
          }
          const additionalTextEdits = codeAction.additionalTextEdits;
          if (this.useCodeSnippet) {
            const shouldCompleteFunction = await this.isValidFunctionCompletionContext(client, filepath, this.position, this.document, token);
            if (shouldCompleteFunction) {
              const { snippet, parameterCount } = snippetForFunctionCall({ ...this, label: this.textLabel }, detail.displayParts);
              this.insertText = snippet;
              if (parameterCount > 0) {
                if (workspace.getConfiguration("editor.parameterHints").get("enabled")) {
                  commands3.push({ title: "triggerParameterHints", command: "editor.action.triggerParameterHints" });
                }
              }
            }
          }
          return { commands: commands3, edits: additionalTextEdits };
        })();
        this._resolvedPromise = {
          promise,
          requestToken,
          waiting: 1
        };
        return this._resolvedPromise.promise;
      }
      getDetails(client, detail) {
        const parts = [];
        if (detail.kind === Kind.script) {
          return void 0;
        }
        for (const action of detail.codeActions ?? []) {
          parts.push(action.description);
        }
        parts.push(asPlainTextWithLinks(detail.displayParts, client));
        return parts.join("\n\n");
      }
      getDocumentation(client, detail, baseUri) {
        const documentation = new MarkdownString();
        appendDocumentationAsMarkdown(documentation, detail.documentation, detail.tags, client);
        documentation.baseUri = baseUri;
        return documentation.value.length ? documentation : void 0;
      }
      async isValidFunctionCompletionContext(client, filepath, position, document, token) {
        try {
          const args = Position3.toFileLocationRequestArgs(filepath, position);
          const response = await client.execute("quickinfo", args, token);
          if (response.type === "response" && response.body) {
            switch (response.body.kind) {
              case "var":
              case "let":
              case "const":
              case "alias":
                return false;
            }
          }
        } catch {
        }
        const line = document.lineAt(position.line);
        const after = line.text.slice(position.character);
        if (after.match(/^[a-z_$0-9]*\s*\(/gi)) {
          return false;
        }
        const before = line.text.slice(0, position.character);
        if (before.match(/<\s*[\w]*$/gi)) {
          return false;
        }
        return true;
      }
      getCodeActions(detail, filepath, client) {
        var _a;
        if (!((_a = detail.codeActions) == null ? void 0 : _a.length)) {
          return {};
        }
        const additionalTextEdits = [];
        let hasRemainingCommandsOrEdits = false;
        for (const tsAction of detail.codeActions) {
          if (tsAction.commands) {
            hasRemainingCommandsOrEdits = true;
          }
          if (tsAction.changes) {
            for (const change of tsAction.changes) {
              if (client.toResource(change.fileName).fsPath === filepath) {
                additionalTextEdits.push(...change.textChanges.map(TextEdit3.fromCodeEdit));
              } else {
                hasRemainingCommandsOrEdits = true;
              }
            }
          }
        }
        let command = void 0;
        if (hasRemainingCommandsOrEdits) {
          command = {
            title: "",
            command: ApplyCompletionCodeActionCommand.ID,
            arguments: [filepath, detail.codeActions.map((x) => ({
              commands: x.commands,
              description: x.description,
              changes: x.changes.filter((x2) => x2.fileName !== filepath)
            }))]
          };
        }
        return {
          command,
          additionalTextEdits: additionalTextEdits.length ? additionalTextEdits : void 0
        };
      }
      getRangeFromReplacementSpan(tsEntry, completionContext) {
        if (!tsEntry.replacementSpan) {
          if (completionContext.optionalReplacementRange) {
            return {
              inserting: new Range(completionContext.optionalReplacementRange.start, this.position),
              replacing: completionContext.optionalReplacementRange
            };
          }
          return void 0;
        }
        let replaceRange = Range4.fromTextSpan(tsEntry.replacementSpan);
        if (!replaceRange.isSingleLine) {
          replaceRange = new Range(replaceRange.start.line, replaceRange.start.character, replaceRange.start.line, completionContext.line.length);
        }
        return {
          inserting: replaceRange,
          replacing: replaceRange
        };
      }
      getFilterText(line, insertText) {
        if (this.tsEntry.name.startsWith("#")) {
          const wordRange = this.completionContext.wordRange;
          const wordStart = wordRange ? line.charAt(wordRange.start.character) : void 0;
          if (insertText) {
            if (insertText.startsWith("this.#")) {
              return wordStart === "#" ? insertText : insertText.replace(/^this\.#/, "");
            } else {
              return insertText;
            }
          } else {
            return wordStart === "#" ? void 0 : this.tsEntry.name.replace(/^#/, "");
          }
        }
        if (insertText == null ? void 0 : insertText.startsWith("this.")) {
          return void 0;
        } else if (insertText == null ? void 0 : insertText.startsWith("[")) {
          return insertText.replace(/^\[['"](.+)[['"]\]$/, ".$1");
        }
        return insertText;
      }
      resolveRange() {
        if (this.range) {
          return;
        }
        const replaceRange = this.completionContext.wordRange;
        if (replaceRange) {
          this.range = {
            inserting: new Range(replaceRange.start, this.position),
            replacing: replaceRange
          };
        }
      }
      static convertKind(kind) {
        switch (kind) {
          case Kind.primitiveType:
          case Kind.keyword:
            return 13 /* Keyword */;
          case Kind.const:
          case Kind.let:
          case Kind.variable:
          case Kind.localVariable:
          case Kind.alias:
          case Kind.parameter:
            return 5 /* Variable */;
          case Kind.memberVariable:
          case Kind.memberGetAccessor:
          case Kind.memberSetAccessor:
            return 4 /* Field */;
          case Kind.function:
          case Kind.localFunction:
            return 2 /* Function */;
          case Kind.method:
          case Kind.constructSignature:
          case Kind.callSignature:
          case Kind.indexSignature:
            return 1 /* Method */;
          case Kind.enum:
            return 12 /* Enum */;
          case Kind.enumMember:
            return 19 /* EnumMember */;
          case Kind.module:
          case Kind.externalModuleName:
            return 8 /* Module */;
          case Kind.class:
          case Kind.type:
            return 6 /* Class */;
          case Kind.interface:
            return 7 /* Interface */;
          case Kind.warning:
            return 0 /* Text */;
          case Kind.script:
            return 16 /* File */;
          case Kind.directory:
            return 18 /* Folder */;
          case Kind.string:
            return 20 /* Constant */;
          default:
            return 9 /* Property */;
        }
      }
      static getCommitCharacters(context, entry, defaultCommitCharacters) {
        let commitCharacters = entry.commitCharacters ?? (defaultCommitCharacters ? Array.from(defaultCommitCharacters) : void 0);
        if (commitCharacters) {
          if (context.enableCallCompletions && !context.isNewIdentifierLocation && entry.kind !== Kind.warning && entry.kind !== Kind.string) {
            commitCharacters.push("(");
          }
          return commitCharacters;
        }
        if (entry.kind === Kind.warning || entry.kind === Kind.string) {
          return void 0;
        }
        if (context.isNewIdentifierLocation) {
          return void 0;
        }
        commitCharacters = [".", ",", ";"];
        if (context.enableCallCompletions) {
          commitCharacters.push("(");
        }
        return commitCharacters;
      }
    };
    _CompletionAcceptedCommand = class _CompletionAcceptedCommand {
      constructor(onCompletionAccepted, telemetryReporter) {
        this.onCompletionAccepted = onCompletionAccepted;
        this.telemetryReporter = telemetryReporter;
        this.id = _CompletionAcceptedCommand.ID;
      }
      execute(item) {
        this.onCompletionAccepted(item);
        if (item instanceof MyCompletionItem) {
          this.telemetryReporter.logTelemetry("completions.accept", {
            isPackageJsonImport: item.tsEntry.isPackageJsonImport ? "true" : void 0,
            isImportStatementCompletion: item.tsEntry.isImportStatementCompletion ? "true" : void 0
          });
        }
      }
    };
    _CompletionAcceptedCommand.ID = "_typescript.onCompletionAccepted";
    CompletionAcceptedCommand = _CompletionAcceptedCommand;
    _ApplyCompletionCommand = class _ApplyCompletionCommand {
      constructor(client) {
        this.client = client;
        this.id = _ApplyCompletionCommand.ID;
      }
      async execute(item) {
        const resolved = await item.resolveCompletionItem(this.client, nulToken);
        if (!resolved) {
          return;
        }
        const { edits, commands: commands3 } = resolved;
        if (!item.additionalTextEdits && edits) {
          const workspaceEdit = new WorkspaceEdit();
          for (const edit of edits) {
            workspaceEdit.replace(item.document.uri, edit.range, edit.newText);
          }
          await workspace.applyEdit(workspaceEdit);
        }
        for (const command of commands3) {
          await commands.executeCommand(command.command, ...command.arguments ?? []);
        }
      }
    };
    _ApplyCompletionCommand.ID = "_typescript.applyCompletionCommand";
    ApplyCompletionCommand = _ApplyCompletionCommand;
    _ApplyCompletionCodeActionCommand = class _ApplyCompletionCodeActionCommand {
      constructor(client) {
        this.client = client;
        this.id = _ApplyCompletionCodeActionCommand.ID;
      }
      async execute(_file, codeActions) {
        if (codeActions.length === 0) {
          return true;
        }
        if (codeActions.length === 1) {
          return applyCodeAction(this.client, codeActions[0], nulToken);
        }
        const selection = await window.showQuickPick(
          codeActions.map((action) => ({
            label: action.description,
            description: "",
            action
          })),
          {
            placeHolder: l10n.t("Select code action to apply")
          }
        );
        if (selection) {
          return applyCodeAction(this.client, selection.action, nulToken);
        }
        return false;
      }
    };
    _ApplyCompletionCodeActionCommand.ID = "_typescript.applyCompletionCodeAction";
    ApplyCompletionCodeActionCommand = _ApplyCompletionCodeActionCommand;
    ((CompletionConfiguration2) => {
      CompletionConfiguration2.completeFunctionCalls = "suggest.completeFunctionCalls";
      CompletionConfiguration2.nameSuggestions = "suggest.names";
      CompletionConfiguration2.pathSuggestions = "suggest.paths";
      CompletionConfiguration2.autoImportSuggestions = "suggest.autoImports";
      CompletionConfiguration2.importStatementSuggestions = "suggest.importStatements";
      function getConfigurationForResource(modeId, resource) {
        const config3 = workspace.getConfiguration(modeId, resource);
        return {
          completeFunctionCalls: config3.get(CompletionConfiguration2.completeFunctionCalls, false),
          pathSuggestions: config3.get(CompletionConfiguration2.pathSuggestions, true),
          autoImportSuggestions: config3.get(CompletionConfiguration2.autoImportSuggestions, true),
          nameSuggestions: config3.get(CompletionConfiguration2.nameSuggestions, true),
          importStatementSuggestions: config3.get(CompletionConfiguration2.importStatementSuggestions, true)
        };
      }
      CompletionConfiguration2.getConfigurationForResource = getConfigurationForResource;
    })(CompletionConfiguration || (CompletionConfiguration = {}));
    TypeScriptCompletionItemProvider = class {
      constructor(client, language, typingsStatus, fileConfigurationManager, commandManager, telemetryReporter, onCompletionAccepted) {
        this.client = client;
        this.language = language;
        this.typingsStatus = typingsStatus;
        this.fileConfigurationManager = fileConfigurationManager;
        this.telemetryReporter = telemetryReporter;
        commandManager.register(new ApplyCompletionCodeActionCommand(this.client));
        commandManager.register(new CompletionAcceptedCommand(onCompletionAccepted, this.telemetryReporter));
        commandManager.register(new ApplyCompletionCommand(this.client));
      }
      async provideCompletionItems(document, position, token, context) {
        var _a;
        if (!workspace.getConfiguration(this.language.id, document).get("suggest.enabled")) {
          return void 0;
        }
        if (this.typingsStatus.isAcquiringTypings) {
          return Promise.reject({
            label: l10n.t({
              message: "Acquiring typings...",
              comment: ["Typings refers to the *.d.ts typings files that power our IntelliSense. It should not be localized"]
            }),
            detail: l10n.t({
              message: "Acquiring typings definitions for IntelliSense.",
              comment: ["Typings refers to the *.d.ts typings files that power our IntelliSense. It should not be localized"]
            })
          });
        }
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        const line = document.lineAt(position.line);
        const completionConfiguration = CompletionConfiguration.getConfigurationForResource(this.language.id, document.uri);
        if (!this.shouldTrigger(context, line, position, completionConfiguration)) {
          return void 0;
        }
        let wordRange = document.getWordRangeAtPosition(position);
        if (wordRange && !wordRange.isEmpty) {
          const secondCharPosition = wordRange.start.translate(0, 1);
          const firstChar = document.getText(new Range(wordRange.start, secondCharPosition));
          if (firstChar === "@") {
            wordRange = wordRange.with(secondCharPosition);
          }
        }
        await this.client.interruptGetErr(() => this.fileConfigurationManager.ensureConfigurationForDocument(document, token));
        const args = {
          ...Position3.toFileLocationRequestArgs(file2, position),
          includeExternalModuleExports: completionConfiguration.autoImportSuggestions,
          includeInsertTextCompletions: true,
          triggerCharacter: this.getTsTriggerCharacter(context),
          triggerKind: CompletionTriggerKind3.toProtocolCompletionTriggerKind(context.triggerKind)
        };
        let dotAccessorContext;
        let response;
        let duration;
        let optionalReplacementRange;
        const startTime = Date.now();
        try {
          response = await this.client.interruptGetErr(() => this.client.execute("completionInfo", args, token));
        } finally {
          duration = Date.now() - startTime;
        }
        if (response.type !== "response" || !response.body) {
          this.logCompletionsTelemetry(duration, response);
          return void 0;
        }
        const isNewIdentifierLocation = response.body.isNewIdentifierLocation;
        const isMemberCompletion = response.body.isMemberCompletion;
        if (isMemberCompletion) {
          const dotMatch = line.text.slice(0, position.character).match(/\??\.\s*$/) || void 0;
          if (dotMatch) {
            const range = new Range(position.translate({ characterDelta: -dotMatch[0].length }), position);
            const text = document.getText(range);
            dotAccessorContext = { range, text };
          }
        }
        const isIncomplete = !!response.body.isIncomplete || ((_a = response.metadata) == null ? void 0 : _a.isIncomplete);
        const entries = response.body.entries;
        const metadata = response.metadata;
        const defaultCommitCharacters = Object.freeze(response.body.defaultCommitCharacters);
        if (response.body.optionalReplacementSpan) {
          optionalReplacementRange = Range4.fromTextSpan(response.body.optionalReplacementSpan);
        }
        const completionContext = {
          isNewIdentifierLocation,
          isMemberCompletion,
          dotAccessorContext,
          enableCallCompletions: !completionConfiguration.completeFunctionCalls,
          wordRange,
          line: line.text,
          completeFunctionCalls: completionConfiguration.completeFunctionCalls,
          optionalReplacementRange
        };
        let includesPackageJsonImport = false;
        let includesImportStatementCompletion = false;
        const items = [];
        for (const entry of entries) {
          if (!shouldExcludeCompletionEntry(entry, completionConfiguration)) {
            const item = new MyCompletionItem(
              position,
              document,
              entry,
              completionContext,
              metadata,
              this.client,
              defaultCommitCharacters
            );
            item.command = {
              command: ApplyCompletionCommand.ID,
              title: "",
              arguments: [item]
            };
            items.push(item);
            includesPackageJsonImport = includesPackageJsonImport || !!entry.isPackageJsonImport;
            includesImportStatementCompletion = includesImportStatementCompletion || !!entry.isImportStatementCompletion;
          }
        }
        if (duration !== void 0) {
          this.logCompletionsTelemetry(duration, response, includesPackageJsonImport, includesImportStatementCompletion);
        }
        return new CompletionList(items, isIncomplete);
      }
      logCompletionsTelemetry(duration, response, includesPackageJsonImport, includesImportStatementCompletion) {
        var _a, _b, _c;
        this.telemetryReporter.logTelemetry("completions.execute", {
          duration: String(duration),
          type: (response == null ? void 0 : response.type) ?? "unknown",
          flags: (response == null ? void 0 : response.type) === "response" && typeof ((_a = response.body) == null ? void 0 : _a.flags) === "number" ? String(response.body.flags) : void 0,
          count: String((response == null ? void 0 : response.type) === "response" && response.body ? response.body.entries.length : 0),
          updateGraphDurationMs: (response == null ? void 0 : response.type) === "response" && typeof ((_b = response.performanceData) == null ? void 0 : _b.updateGraphDurationMs) === "number" ? String(response.performanceData.updateGraphDurationMs) : void 0,
          createAutoImportProviderProgramDurationMs: (response == null ? void 0 : response.type) === "response" && typeof ((_c = response.performanceData) == null ? void 0 : _c.createAutoImportProviderProgramDurationMs) === "number" ? String(response.performanceData.createAutoImportProviderProgramDurationMs) : void 0,
          includesPackageJsonImport: includesPackageJsonImport ? "true" : void 0,
          includesImportStatementCompletion: includesImportStatementCompletion ? "true" : void 0
        });
      }
      getTsTriggerCharacter(context) {
        switch (context.triggerCharacter) {
          case "@": {
            return "@";
          }
          case "#": {
            return "#";
          }
          case " ": {
            return this.client.apiVersion.gte(API.v430) ? " " : void 0;
          }
          case ".":
          case '"':
          case "'":
          case "`":
          case "/":
          case "<": {
            return context.triggerCharacter;
          }
          default: {
            return void 0;
          }
        }
      }
      async resolveCompletionItem(item, token) {
        const resolved = await item.resolveCompletionItem(this.client, token);
        item.additionalTextEdits = resolved == null ? void 0 : resolved.edits;
        return item;
      }
      shouldTrigger(context, line, position, configuration) {
        if (context.triggerCharacter === " ") {
          if (!configuration.importStatementSuggestions || this.client.apiVersion.lt(API.v430)) {
            return false;
          }
          const pre = line.text.slice(0, position.character);
          return pre === "import";
        }
        return true;
      }
    };
    TypeScriptCompletionItemProvider.triggerCharacters = [".", '"', "'", "`", "/", "@", "<", "#", " "];
  }
});

// src/typescript-language-features/src/languageFeatures/copyPaste.ts
var copyPaste_exports = {};
__export(copyPaste_exports, {
  register: () => register5
});
function register5(selector, language, client, fileConfigurationManager) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */),
    requireMinVersion(client, API.v570),
    requireGlobalConfiguration(language.id, enabledSettingId)
  ], () => {
    return languages.registerDocumentPasteEditProvider(selector.semantic, new DocumentPasteProvider(language.id, client, fileConfigurationManager), {
      providedPasteEditKinds: [DocumentPasteProvider.kind],
      copyMimeTypes: [DocumentPasteProvider.metadataMimeType],
      pasteMimeTypes: [DocumentPasteProvider.metadataMimeType]
    });
  });
}
var CopyMetadata, enabledSettingId, _DocumentPasteProvider, DocumentPasteProvider;
var init_copyPaste = __esm({
  "src/typescript-language-features/src/languageFeatures/copyPaste.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    CopyMetadata = class _CopyMetadata {
      constructor(resource, ranges) {
        this.resource = resource;
        this.ranges = ranges;
      }
      toJSON() {
        return JSON.stringify({
          resource: this.resource.toJSON(),
          ranges: this.ranges
        });
      }
      static fromJSON(str) {
        try {
          const parsed = JSON.parse(str);
          return new _CopyMetadata(
            Uri.from(parsed.resource),
            parsed.ranges.map((r) => new Range(r[0].line, r[0].character, r[1].line, r[1].character))
          );
        } catch {
        }
        return void 0;
      }
    };
    enabledSettingId = "updateImportsOnPaste.enabled";
    _DocumentPasteProvider = class _DocumentPasteProvider {
      constructor(_modeId, _client, fileConfigurationManager) {
        this._modeId = _modeId;
        this._client = _client;
        this.fileConfigurationManager = fileConfigurationManager;
      }
      async prepareDocumentPaste(document, ranges, dataTransfer, token) {
        if (!this.isEnabled(document)) {
          return;
        }
        const file2 = this._client.toOpenTsFilePath(document);
        if (!file2) {
          return;
        }
        const response = await this._client.interruptGetErr(() => this._client.execute("preparePasteEdits", {
          file: file2,
          copiedTextSpan: ranges.map(Range4.toTextSpan)
        }, token));
        if (token.isCancellationRequested || response.type !== "response" || !response.body) {
          return;
        }
        dataTransfer.set(
          _DocumentPasteProvider.metadataMimeType,
          new DataTransferItem(new CopyMetadata(document.uri, ranges).toJSON())
        );
      }
      async provideDocumentPasteEdits(document, ranges, dataTransfer, _context, token) {
        var _a, _b;
        if (!this.isEnabled(document)) {
          return;
        }
        const file2 = this._client.toOpenTsFilePath(document);
        if (!file2) {
          return;
        }
        const text = await ((_a = dataTransfer.get("text/plain")) == null ? void 0 : _a.asString());
        if (!text || token.isCancellationRequested) {
          return;
        }
        const metadata = await this.extractMetadata(dataTransfer, token);
        if (token.isCancellationRequested) {
          return;
        }
        let copiedFrom;
        if (metadata) {
          const spans = metadata.ranges.map(Range4.toTextSpan);
          const copyFile = this._client.toTsFilePath(metadata.resource);
          if (copyFile) {
            copiedFrom = { file: copyFile, spans };
          }
        }
        if ((copiedFrom == null ? void 0 : copiedFrom.file) === file2) {
          return;
        }
        const response = await this._client.interruptGetErr(() => {
          this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
          return this._client.execute("getPasteEdits", {
            file: file2,
            // TODO: only supports a single paste for now
            pastedText: [text],
            pasteLocations: ranges.map(Range4.toTextSpan),
            copiedFrom
          }, token);
        });
        if (response.type !== "response" || !((_b = response.body) == null ? void 0 : _b.edits.length) || token.isCancellationRequested) {
          return;
        }
        const edit = new DocumentPasteEdit("", l10n.t("Paste with imports"), _DocumentPasteProvider.kind);
        edit.yieldTo = [DocumentDropOrPasteEditKind.Text.append("plain")];
        const additionalEdit = new WorkspaceEdit();
        for (const edit2 of response.body.edits) {
          additionalEdit.set(this._client.toResource(edit2.fileName), edit2.textChanges.map(TextEdit3.fromCodeEdit));
        }
        edit.additionalEdit = additionalEdit;
        return [edit];
      }
      async extractMetadata(dataTransfer, token) {
        var _a;
        const metadata = await ((_a = dataTransfer.get(_DocumentPasteProvider.metadataMimeType)) == null ? void 0 : _a.asString());
        if (token.isCancellationRequested) {
          return void 0;
        }
        return metadata ? CopyMetadata.fromJSON(metadata) : void 0;
      }
      isEnabled(document) {
        const config3 = workspace.getConfiguration(this._modeId, document.uri);
        return config3.get(enabledSettingId, true);
      }
    };
    _DocumentPasteProvider.kind = DocumentDropOrPasteEditKind.Text.append("updateImports", "jsts");
    _DocumentPasteProvider.metadataMimeType = "application/vnd.code.jsts.metadata";
    DocumentPasteProvider = _DocumentPasteProvider;
  }
});

// src/typescript-language-features/src/languageFeatures/definitionProviderBase.ts
var TypeScriptDefinitionProviderBase;
var init_definitionProviderBase = __esm({
  "src/typescript-language-features/src/languageFeatures/definitionProviderBase.ts"() {
    "use strict";
    init_typeConverters();
    TypeScriptDefinitionProviderBase = class {
      constructor(client) {
        this.client = client;
      }
      async getSymbolLocations(definitionType, document, position, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        const args = Position3.toFileLocationRequestArgs(file2, position);
        const response = await this.client.execute(definitionType, args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        return response.body.map((location) => Location2.fromTextSpan(this.client.toResource(location.file), location));
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/definitions.ts
var definitions_exports = {};
__export(definitions_exports, {
  default: () => TypeScriptDefinitionProvider,
  register: () => register6
});
function register6(selector, client) {
  return conditionalRegistration([
    requireSomeCapability(client, 1 /* EnhancedSyntax */, 2 /* Semantic */)
  ], () => {
    return languages.registerDefinitionProvider(
      selector.syntax,
      new TypeScriptDefinitionProvider(client)
    );
  });
}
var TypeScriptDefinitionProvider;
var init_definitions = __esm({
  "src/typescript-language-features/src/languageFeatures/definitions.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_typeConverters();
    init_typescriptService();
    init_definitionProviderBase();
    init_dependentRegistration();
    TypeScriptDefinitionProvider = class extends TypeScriptDefinitionProviderBase {
      async provideDefinition(document, position, token) {
        var _a;
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return void 0;
        }
        const args = Position3.toFileLocationRequestArgs(filepath, position);
        const response = await this.client.execute("definitionAndBoundSpan", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        const span = response.body.textSpan ? Range4.fromTextSpan(response.body.textSpan) : void 0;
        let definitions = response.body.definitions;
        if (workspace.getConfiguration(document.languageId).get("preferGoToSourceDefinition", false) && this.client.apiVersion.gte(API.v470)) {
          const sourceDefinitionsResponse = await this.client.execute("findSourceDefinition", args, token);
          if (sourceDefinitionsResponse.type === "response" && ((_a = sourceDefinitionsResponse.body) == null ? void 0 : _a.length)) {
            definitions = sourceDefinitionsResponse.body;
          }
        }
        return definitions.map((location) => {
          const target = Location2.fromTextSpan(this.client.toResource(location.file), location);
          if (location.contextStart && location.contextEnd) {
            return {
              originSelectionRange: span,
              targetRange: Range4.fromLocations(location.contextStart, location.contextEnd),
              targetUri: target.uri,
              targetSelectionRange: target.range
            };
          }
          return {
            originSelectionRange: span,
            targetRange: target.range,
            targetUri: target.uri
          };
        });
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/directiveCommentCompletions.ts
var directiveCommentCompletions_exports = {};
__export(directiveCommentCompletions_exports, {
  register: () => register7
});
function register7(selector, client) {
  return languages.registerCompletionItemProvider(
    selector.syntax,
    new DirectiveCommentCompletionProvider(client),
    "@"
  );
}
var tsDirectives, tsDirectives390, DirectiveCommentCompletionProvider;
var init_directiveCommentCompletions = __esm({
  "src/typescript-language-features/src/languageFeatures/directiveCommentCompletions.ts"() {
    "use strict";
    init_shims();
    init_api2();
    tsDirectives = [
      {
        value: "@ts-check",
        description: l10n.t("Enables semantic checking in a JavaScript file. Must be at the top of a file.")
      },
      {
        value: "@ts-nocheck",
        description: l10n.t("Disables semantic checking in a JavaScript file. Must be at the top of a file.")
      },
      {
        value: "@ts-ignore",
        description: l10n.t("Suppresses @ts-check errors on the next line of a file.")
      }
    ];
    tsDirectives390 = [
      ...tsDirectives,
      {
        value: "@ts-expect-error",
        description: l10n.t("Suppresses @ts-check errors on the next line of a file, expecting at least one to exist.")
      }
    ];
    DirectiveCommentCompletionProvider = class {
      constructor(client) {
        this.client = client;
      }
      provideCompletionItems(document, position, _token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return [];
        }
        const line = document.lineAt(position.line).text;
        const prefix = line.slice(0, position.character);
        const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
        if (match) {
          const directives = this.client.apiVersion.gte(API.v390) ? tsDirectives390 : tsDirectives;
          return directives.map((directive) => {
            const item = new CompletionItem(directive.value, 14 /* Snippet */);
            item.detail = directive.description;
            item.range = new Range(position.line, Math.max(0, position.character - (match[1] ? match[1].length : 0)), position.line, position.character);
            return item;
          });
        }
        return [];
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/documentHighlight.ts
var documentHighlight_exports = {};
__export(documentHighlight_exports, {
  register: () => register8
});
function convertDocumentHighlight(highlight) {
  return highlight.highlightSpans.map((span) => new DocumentHighlight(
    Range4.fromTextSpan(span),
    span.kind === "writtenReference" ? 2 /* Write */ : 1 /* Read */
  ));
}
function register8(selector, client) {
  const provider = new TypeScriptDocumentHighlightProvider(client);
  return Disposable4.from(
    languages.registerDocumentHighlightProvider(selector.syntax, provider),
    languages.registerMultiDocumentHighlightProvider(selector.syntax, provider)
  );
}
var TypeScriptDocumentHighlightProvider;
var init_documentHighlight = __esm({
  "src/typescript-language-features/src/languageFeatures/documentHighlight.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    TypeScriptDocumentHighlightProvider = class {
      constructor(client) {
        this.client = client;
      }
      async provideMultiDocumentHighlights(document, position, otherDocuments, token) {
        const allFiles = [document, ...otherDocuments].map((doc) => this.client.toOpenTsFilePath(doc)).filter((file3) => !!file3);
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2 || allFiles.length === 0) {
          return [];
        }
        const args = {
          ...Position3.toFileLocationRequestArgs(file2, position),
          filesToSearch: allFiles
        };
        const response = await this.client.execute("documentHighlights", args, token);
        if (response.type !== "response" || !response.body) {
          return [];
        }
        const result = response.body.map(
          (highlightItem) => new MultiDocumentHighlight(
            Uri.file(highlightItem.file),
            [...convertDocumentHighlight(highlightItem)]
          )
        );
        return result;
      }
      async provideDocumentHighlights(document, position, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return [];
        }
        const args = {
          ...Position3.toFileLocationRequestArgs(file2, position),
          filesToSearch: [file2]
        };
        const response = await this.client.execute("documentHighlights", args, token);
        if (response.type !== "response" || !response.body) {
          return [];
        }
        return response.body.flatMap(convertDocumentHighlight);
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/documentSymbol.ts
var documentSymbol_exports = {};
__export(documentSymbol_exports, {
  register: () => register9
});
function register9(selector, client, cachedResponse) {
  return languages.registerDocumentSymbolProvider(
    selector.syntax,
    new TypeScriptDocumentSymbolProvider(client, cachedResponse),
    { label: "TypeScript" }
  );
}
var getSymbolKind, TypeScriptDocumentSymbolProvider;
var init_documentSymbol = __esm({
  "src/typescript-language-features/src/languageFeatures/documentSymbol.ts"() {
    "use strict";
    init_shims();
    init_modifiers();
    init_protocol_const();
    init_typeConverters();
    getSymbolKind = (kind) => {
      switch (kind) {
        case Kind.module:
          return 1 /* Module */;
        case Kind.class:
          return 4 /* Class */;
        case Kind.enum:
          return 9 /* Enum */;
        case Kind.interface:
          return 10 /* Interface */;
        case Kind.method:
          return 5 /* Method */;
        case Kind.memberVariable:
          return 6 /* Property */;
        case Kind.memberGetAccessor:
          return 6 /* Property */;
        case Kind.memberSetAccessor:
          return 6 /* Property */;
        case Kind.variable:
          return 12 /* Variable */;
        case Kind.const:
          return 12 /* Variable */;
        case Kind.localVariable:
          return 12 /* Variable */;
        case Kind.function:
          return 11 /* Function */;
        case Kind.localFunction:
          return 11 /* Function */;
        case Kind.constructSignature:
          return 8 /* Constructor */;
        case Kind.constructorImplementation:
          return 8 /* Constructor */;
      }
      return 12 /* Variable */;
    };
    TypeScriptDocumentSymbolProvider = class _TypeScriptDocumentSymbolProvider {
      constructor(client, cachedResponse) {
        this.client = client;
        this.cachedResponse = cachedResponse;
      }
      async provideDocumentSymbols(document, token) {
        var _a;
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        const args = { file: file2 };
        const response = await this.cachedResponse.execute(document, () => this.client.execute("navtree", args, token));
        if (response.type !== "response" || !((_a = response.body) == null ? void 0 : _a.childItems)) {
          return void 0;
        }
        const result = [];
        for (const item of response.body.childItems) {
          _TypeScriptDocumentSymbolProvider.convertNavTree(document.uri, result, item);
        }
        return result;
      }
      static convertNavTree(resource, output, item) {
        var _a;
        let shouldInclude = _TypeScriptDocumentSymbolProvider.shouldInclueEntry(item);
        if (!shouldInclude && !((_a = item.childItems) == null ? void 0 : _a.length)) {
          return false;
        }
        const children = new Set(item.childItems || []);
        for (const span of item.spans) {
          const range = Range4.fromTextSpan(span);
          const symbolInfo = _TypeScriptDocumentSymbolProvider.convertSymbol(item, range);
          for (const child of children) {
            if (child.spans.some((span2) => !!range.intersection(Range4.fromTextSpan(span2)))) {
              const includedChild = _TypeScriptDocumentSymbolProvider.convertNavTree(resource, symbolInfo.children, child);
              shouldInclude = shouldInclude || includedChild;
              children.delete(child);
            }
          }
          if (shouldInclude) {
            output.push(symbolInfo);
          }
        }
        return shouldInclude;
      }
      static convertSymbol(item, range) {
        const selectionRange = item.nameSpan ? Range4.fromTextSpan(item.nameSpan) : range;
        let label = item.text;
        switch (item.kind) {
          case Kind.memberGetAccessor:
            label = `(get) ${label}`;
            break;
          case Kind.memberSetAccessor:
            label = `(set) ${label}`;
            break;
        }
        const symbolInfo = new DocumentSymbol(
          label,
          "",
          getSymbolKind(item.kind),
          range,
          range.contains(selectionRange) ? selectionRange : range
        );
        const kindModifiers = parseKindModifier(item.kindModifiers);
        if (kindModifiers.has(KindModifiers.deprecated)) {
          symbolInfo.tags = [1 /* Deprecated */];
        }
        return symbolInfo;
      }
      static shouldInclueEntry(item) {
        if (item.kind === Kind.alias) {
          return false;
        }
        return !!(item.text && item.text !== "<function>" && item.text !== "<class>");
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/fileReferences.ts
var fileReferences_exports = {};
__export(fileReferences_exports, {
  register: () => register10
});
function register10(client, commandManager) {
  function updateContext() {
    commands.executeCommand("setContext", FileReferencesCommand.context, client.apiVersion.gte(FileReferencesCommand.minVersion));
  }
  updateContext();
  commandManager.register(new FileReferencesCommand(client));
  return client.onTsServerStarted(() => updateContext());
}
var _FileReferencesCommand, FileReferencesCommand;
var init_fileReferences = __esm({
  "src/typescript-language-features/src/languageFeatures/fileReferences.ts"() {
    "use strict";
    init_shims();
    init_languageIds();
    init_api2();
    init_typeConverters();
    _FileReferencesCommand = class _FileReferencesCommand {
      constructor(client) {
        this.client = client;
        this.id = "typescript.findAllFileReferences";
      }
      async execute(resource) {
        var _a;
        if (this.client.apiVersion.lt(_FileReferencesCommand.minVersion)) {
          window.showErrorMessage(l10n.t("Find file references failed. Requires TypeScript 4.2+."));
          return;
        }
        resource ??= (_a = window.activeTextEditor) == null ? void 0 : _a.document.uri;
        if (!resource) {
          window.showErrorMessage(l10n.t("Find file references failed. No resource provided."));
          return;
        }
        const document = await workspace.openTextDocument(resource);
        if (!isSupportedLanguageMode(document)) {
          window.showErrorMessage(l10n.t("Find file references failed. Unsupported file type."));
          return;
        }
        const openedFiledPath = this.client.toOpenTsFilePath(document);
        if (!openedFiledPath) {
          window.showErrorMessage(l10n.t("Find file references failed. Unknown file type."));
          return;
        }
        return await window.withProgress({
          location: 10 /* Window */,
          title: l10n.t("Finding file references")
        }, async (_progress, token) => {
          const response = await this.client.execute("fileReferences", {
            file: openedFiledPath
          }, token);
          if (response.type !== "response" || !response.body) {
            return;
          }
          const locations = response.body.refs.map((reference) => Location2.fromTextSpan(this.client.toResource(reference.file), reference));
          return locations;
          const config3 = workspace.getConfiguration("references");
          const existingSetting = config3.inspect("preferredLocation");
          await config3.update("preferredLocation", "view");
          try {
            await commands.executeCommand("editor.action.showReferences", resource, new Position(0, 0), locations);
          } finally {
            await config3.update("preferredLocation", (existingSetting == null ? void 0 : existingSetting.workspaceFolderValue) ?? (existingSetting == null ? void 0 : existingSetting.workspaceValue));
          }
        });
      }
    };
    _FileReferencesCommand.context = "tsSupportsFileReferences";
    _FileReferencesCommand.minVersion = API.v420;
    FileReferencesCommand = _FileReferencesCommand;
  }
});

// src/typescript-language-features/src/tsServer/protocol/errorCodes.ts
var variableDeclaredButNeverUsed, propertyDeclaretedButNeverUsed, allImportsAreUnused, unreachableCode, unusedLabel, fallThroughCaseInSwitch, notAllCodePathsReturnAValue, incorrectlyImplementsInterface, cannotFindName, asyncOnlyAllowedInAsyncFunctions;
var init_errorCodes = __esm({
  "src/typescript-language-features/src/tsServer/protocol/errorCodes.ts"() {
    "use strict";
    variableDeclaredButNeverUsed = /* @__PURE__ */ new Set([6196, 6133]);
    propertyDeclaretedButNeverUsed = /* @__PURE__ */ new Set([6138]);
    allImportsAreUnused = /* @__PURE__ */ new Set([6192]);
    unreachableCode = /* @__PURE__ */ new Set([7027]);
    unusedLabel = /* @__PURE__ */ new Set([7028]);
    fallThroughCaseInSwitch = /* @__PURE__ */ new Set([7029]);
    notAllCodePathsReturnAValue = /* @__PURE__ */ new Set([7030]);
    incorrectlyImplementsInterface = /* @__PURE__ */ new Set([2420]);
    cannotFindName = /* @__PURE__ */ new Set([2552, 2304]);
    asyncOnlyAllowedInAsyncFunctions = /* @__PURE__ */ new Set([1308]);
  }
});

// src/typescript-language-features/src/tsServer/protocol/fixNames.ts
var addMissingAwait, addMissingNewOperator, addMissingOverride, annotateWithTypeFromJSDoc, awaitInSyncFunction, classDoesntImplementInheritedAbstractMember, classIncorrectlyImplementsInterface, constructorForDerivedNeedSuperCall, extendsInterfaceBecomesImplements, fixImport, forgottenThisPropertyAccess, removeUnnecessaryAwait, spelling, inferFromUsage, addNameToNamelessParameter, fixMissingFunctionDeclaration, fixClassDoesntImplementInheritedAbstractMember, unreachableCode2, unusedIdentifier;
var init_fixNames = __esm({
  "src/typescript-language-features/src/tsServer/protocol/fixNames.ts"() {
    "use strict";
    addMissingAwait = "addMissingAwait";
    addMissingNewOperator = "addMissingNewOperator";
    addMissingOverride = "fixOverrideModifier";
    annotateWithTypeFromJSDoc = "annotateWithTypeFromJSDoc";
    awaitInSyncFunction = "fixAwaitInSyncFunction";
    classDoesntImplementInheritedAbstractMember = "fixClassDoesntImplementInheritedAbstractMember";
    classIncorrectlyImplementsInterface = "fixClassIncorrectlyImplementsInterface";
    constructorForDerivedNeedSuperCall = "constructorForDerivedNeedSuperCall";
    extendsInterfaceBecomesImplements = "extendsInterfaceBecomesImplements";
    fixImport = "import";
    forgottenThisPropertyAccess = "forgottenThisPropertyAccess";
    removeUnnecessaryAwait = "removeUnnecessaryAwait";
    spelling = "spelling";
    inferFromUsage = "inferFromUsage";
    addNameToNamelessParameter = "addNameToNamelessParameter";
    fixMissingFunctionDeclaration = "fixMissingFunctionDeclaration";
    fixClassDoesntImplementInheritedAbstractMember = "fixClassDoesntImplementInheritedAbstractMember";
    unreachableCode2 = "fixUnreachableCode";
    unusedIdentifier = "unusedIdentifier";
  }
});

// src/typescript-language-features/src/languageFeatures/fixAll.ts
var fixAll_exports = {};
__export(fixAll_exports, {
  register: () => register11
});
async function buildIndividualFixes(fixes, edit, client, file2, diagnostics, token) {
  var _a;
  for (const diagnostic of diagnostics) {
    for (const { codes, fixName } of fixes) {
      if (token.isCancellationRequested) {
        return;
      }
      if (!codes.has(diagnostic.code)) {
        continue;
      }
      const args = {
        ...Range4.toFileRangeRequestArgs(file2, diagnostic.range),
        errorCodes: [+diagnostic.code]
      };
      const response = await client.execute("getCodeFixes", args, token);
      if (response.type !== "response") {
        continue;
      }
      const fix = (_a = response.body) == null ? void 0 : _a.find((fix2) => fix2.fixName === fixName);
      if (fix) {
        WorkspaceEdit2.withFileCodeEdits(edit, client, fix.changes);
        break;
      }
    }
  }
}
async function buildCombinedFix(fixes, edit, client, file2, diagnostics, token) {
  var _a, _b;
  for (const diagnostic of diagnostics) {
    for (const { codes, fixName } of fixes) {
      if (token.isCancellationRequested) {
        return;
      }
      if (!codes.has(diagnostic.code)) {
        continue;
      }
      const args = {
        ...Range4.toFileRangeRequestArgs(file2, diagnostic.range),
        errorCodes: [+diagnostic.code]
      };
      const response = await client.execute("getCodeFixes", args, token);
      if (response.type !== "response" || !((_a = response.body) == null ? void 0 : _a.length)) {
        continue;
      }
      const fix = (_b = response.body) == null ? void 0 : _b.find((fix2) => fix2.fixName === fixName);
      if (!fix) {
        continue;
      }
      if (!fix.fixId) {
        WorkspaceEdit2.withFileCodeEdits(edit, client, fix.changes);
        return;
      }
      const combinedArgs = {
        scope: {
          type: "file",
          args: { file: file2 }
        },
        fixId: fix.fixId
      };
      const combinedResponse = await client.execute("getCombinedCodeFix", combinedArgs, token);
      if (combinedResponse.type !== "response" || !combinedResponse.body) {
        return;
      }
      WorkspaceEdit2.withFileCodeEdits(edit, client, combinedResponse.body.changes);
      return;
    }
  }
}
function register11(selector, client, fileConfigurationManager, diagnosticsManager) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    const provider = new TypeScriptAutoFixProvider(client, fileConfigurationManager, diagnosticsManager);
    return languages.registerCodeActionsProvider(selector.semantic, provider, provider.metadata);
  });
}
var SourceAction, _SourceFixAll, SourceFixAll, _SourceRemoveUnused, SourceRemoveUnused, _SourceAddMissingImports, SourceAddMissingImports, _TypeScriptAutoFixProvider, TypeScriptAutoFixProvider;
var init_fixAll = __esm({
  "src/typescript-language-features/src/languageFeatures/fixAll.ts"() {
    "use strict";
    init_shims();
    init_errorCodes();
    init_fixNames();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    SourceAction = class extends CodeAction {
    };
    _SourceFixAll = class _SourceFixAll extends SourceAction {
      constructor() {
        super(l10n.t("Fix all fixable JS/TS issues"), _SourceFixAll.kind);
      }
      async build(client, file2, diagnostics, token) {
        this.edit = new WorkspaceEdit();
        await buildIndividualFixes([
          { codes: incorrectlyImplementsInterface, fixName: classIncorrectlyImplementsInterface },
          { codes: asyncOnlyAllowedInAsyncFunctions, fixName: awaitInSyncFunction }
        ], this.edit, client, file2, diagnostics, token);
        await buildCombinedFix([
          { codes: unreachableCode, fixName: unreachableCode2 }
        ], this.edit, client, file2, diagnostics, token);
      }
    };
    _SourceFixAll.kind = CodeActionKind.SourceFixAll.append("ts");
    SourceFixAll = _SourceFixAll;
    _SourceRemoveUnused = class _SourceRemoveUnused extends SourceAction {
      constructor() {
        super(l10n.t("Remove all unused code"), _SourceRemoveUnused.kind);
      }
      async build(client, file2, diagnostics, token) {
        this.edit = new WorkspaceEdit();
        await buildCombinedFix([
          { codes: variableDeclaredButNeverUsed, fixName: unusedIdentifier }
        ], this.edit, client, file2, diagnostics, token);
      }
    };
    _SourceRemoveUnused.kind = CodeActionKind.Source.append("removeUnused").append("ts");
    SourceRemoveUnused = _SourceRemoveUnused;
    _SourceAddMissingImports = class _SourceAddMissingImports extends SourceAction {
      constructor() {
        super(l10n.t("Add all missing imports"), _SourceAddMissingImports.kind);
      }
      async build(client, file2, diagnostics, token) {
        this.edit = new WorkspaceEdit();
        await buildCombinedFix(
          [
            { codes: cannotFindName, fixName: fixImport }
          ],
          this.edit,
          client,
          file2,
          diagnostics,
          token
        );
      }
    };
    _SourceAddMissingImports.kind = CodeActionKind.Source.append("addMissingImports").append("ts");
    SourceAddMissingImports = _SourceAddMissingImports;
    _TypeScriptAutoFixProvider = class _TypeScriptAutoFixProvider {
      constructor(client, fileConfigurationManager, diagnosticsManager) {
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
        this.diagnosticsManager = diagnosticsManager;
      }
      get metadata() {
        return {
          providedCodeActionKinds: _TypeScriptAutoFixProvider.kindProviders.map((x) => x.kind)
        };
      }
      async provideCodeActions(document, _range, context, token) {
        if (!context.only || !CodeActionKind.Source.intersects(context.only)) {
          return void 0;
        }
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        const actions = this.getFixAllActions(context.only);
        const diagnostics = this.diagnosticsManager.getDiagnostics(document.uri);
        if (!diagnostics.length) {
          return actions;
        }
        await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
        if (token.isCancellationRequested) {
          return void 0;
        }
        await Promise.all(actions.map((action) => action.build(this.client, file2, diagnostics, token)));
        return actions;
      }
      getFixAllActions(only) {
        return _TypeScriptAutoFixProvider.kindProviders.filter((provider) => only.intersects(provider.kind)).map((provider) => new provider());
      }
    };
    _TypeScriptAutoFixProvider.kindProviders = [
      SourceFixAll,
      SourceRemoveUnused,
      SourceAddMissingImports
    ];
    TypeScriptAutoFixProvider = _TypeScriptAutoFixProvider;
  }
});

// src/typescript-language-features/src/languageFeatures/folding.ts
var folding_exports = {};
__export(folding_exports, {
  register: () => register12
});
function register12(selector, client) {
  return languages.registerFoldingRangeProvider(
    selector.syntax,
    new TypeScriptFoldingProvider(client)
  );
}
var _TypeScriptFoldingProvider, TypeScriptFoldingProvider;
var init_folding = __esm({
  "src/typescript-language-features/src/languageFeatures/folding.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    init_arrays();
    _TypeScriptFoldingProvider = class _TypeScriptFoldingProvider {
      constructor(client) {
        this.client = client;
      }
      async provideFoldingRanges(document, _context, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return;
        }
        const args = { file: file2 };
        const response = await this.client.execute("getOutliningSpans", args, token);
        if (response.type !== "response" || !response.body) {
          return;
        }
        return coalesce(response.body.map((span) => this.convertOutliningSpan(span, document)));
      }
      convertOutliningSpan(span, document) {
        const range = Range4.fromTextSpan(span.textSpan);
        const kind = _TypeScriptFoldingProvider.getFoldingRangeKind(span);
        if (span.kind === "comment") {
          const line = document.lineAt(range.start.line).text;
          if (/\/\/\s*#endregion/gi.test(line)) {
            return void 0;
          }
        }
        const start = range.start.line;
        const end = this.adjustFoldingEnd(range, document);
        return new FoldingRange(start, end, kind);
      }
      adjustFoldingEnd(range, document) {
        if (range.end.character > 0) {
          const foldEndCharacter = document.getText(new Range(range.end.translate(0, -1), range.end));
          if (_TypeScriptFoldingProvider.foldEndPairCharacters.includes(foldEndCharacter)) {
            return Math.max(range.end.line - 1, range.start.line);
          }
        }
        return range.end.line;
      }
      static getFoldingRangeKind(span) {
        switch (span.kind) {
          case "comment":
            return 1 /* Comment */;
          case "region":
            return 3 /* Region */;
          case "imports":
            return 2 /* Imports */;
          case "code":
          default:
            return void 0;
        }
      }
    };
    _TypeScriptFoldingProvider.foldEndPairCharacters = ["}", "]", ")", "`", ">"];
    TypeScriptFoldingProvider = _TypeScriptFoldingProvider;
  }
});

// src/typescript-language-features/src/languageFeatures/formatting.ts
var formatting_exports = {};
__export(formatting_exports, {
  register: () => register13
});
function register13(selector, language, client, fileConfigurationManager) {
  return conditionalRegistration([
    requireGlobalConfiguration(language.id, "format.enable")
  ], () => {
    const formattingProvider = new TypeScriptFormattingProvider(client, fileConfigurationManager);
    return Disposable4.from(
      languages.registerOnTypeFormattingEditProvider(selector.syntax, formattingProvider, ";", "}", "\n"),
      languages.registerDocumentRangeFormattingEditProvider(selector.syntax, formattingProvider)
    );
  });
}
var TypeScriptFormattingProvider;
var init_formatting = __esm({
  "src/typescript-language-features/src/languageFeatures/formatting.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    init_dependentRegistration();
    TypeScriptFormattingProvider = class {
      constructor(client, fileConfigurationManager) {
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
      }
      async provideDocumentRangeFormattingEdits(document, range, options, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        await this.fileConfigurationManager.ensureConfigurationOptions(document, options, token);
        const args = Range4.toFormattingRequestArgs(file2, range);
        const response = await this.client.execute("format", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        return response.body.map(TextEdit3.fromCodeEdit);
      }
      async provideOnTypeFormattingEdits(document, position, ch, options, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return [];
        }
        await this.fileConfigurationManager.ensureConfigurationOptions(document, options, token);
        const args = {
          ...Position3.toFileLocationRequestArgs(file2, position),
          key: ch
        };
        const response = await this.client.execute("formatonkey", args, token);
        if (response.type !== "response" || !response.body) {
          return [];
        }
        const result = [];
        for (const edit of response.body) {
          const textEdit = TextEdit3.fromCodeEdit(edit);
          const range = textEdit.range;
          if (range.start.character === 0 && range.start.line === range.end.line && textEdit.newText === "") {
            const lText = document.lineAt(range.start.line).text;
            if (lText.trim().length > 0 || lText.length > range.end.character) {
              result.push(textEdit);
            }
          } else {
            result.push(textEdit);
          }
        }
        return result;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/hover.ts
var hover_exports = {};
__export(hover_exports, {
  register: () => register14
});
function register14(selector, client, fileConfigurationManager) {
  return conditionalRegistration([
    requireSomeCapability(client, 1 /* EnhancedSyntax */, 2 /* Semantic */)
  ], () => {
    return languages.registerHoverProvider(
      selector.syntax,
      new TypeScriptHoverProvider(client, fileConfigurationManager)
    );
  });
}
var TypeScriptHoverProvider;
var init_hover = __esm({
  "src/typescript-language-features/src/languageFeatures/hover.ts"() {
    "use strict";
    init_shims();
    init_typescriptService();
    init_dependentRegistration();
    init_textRendering();
    init_typeConverters();
    init_api2();
    TypeScriptHoverProvider = class {
      constructor(client, fileConfigurationManager) {
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
      }
      async provideHover(document, position, token, context) {
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return void 0;
        }
        const enableExpandableHover = workspace.getConfiguration("typescript").get("experimental.expandableHover");
        let verbosityLevel;
        if (enableExpandableHover && this.client.apiVersion.gte(API.v570)) {
          verbosityLevel = Math.max(0, this.getPreviousLevel(context == null ? void 0 : context.previousHover) + ((context == null ? void 0 : context.verbosityDelta) ?? 0));
        }
        const args = { ...Position3.toFileLocationRequestArgs(filepath, position), verbosityLevel };
        const response = await this.client.interruptGetErr(async () => {
          await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
          return this.client.execute("quickinfo", args, token);
        });
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        const contents = this.getContents(document.uri, response.body, response._serverType);
        const range = Range4.fromTextSpan(response.body);
        const hover = verbosityLevel !== void 0 ? new VerboseHover(
          contents,
          range,
          // @ts-expect-error
          /*canIncreaseVerbosity*/
          response.body.canIncreaseVerbosityLevel,
          /*canDecreaseVerbosity*/
          verbosityLevel !== 0
        ) : new Hover(
          contents,
          range
        );
        if (verbosityLevel !== void 0) {
          this.lastHoverAndLevel = [hover, verbosityLevel];
        }
        return hover;
      }
      getContents(resource, data, source) {
        const parts = [];
        if (data.displayString) {
          const displayParts = [];
          if (source === "syntax" /* Syntax */ && this.client.hasCapabilityForResource(resource, 2 /* Semantic */)) {
            displayParts.push(
              l10n.t({
                message: "(loading...)",
                comment: ["Prefix displayed for hover entries while the server is still loading"]
              })
            );
          }
          displayParts.push(data.displayString);
          parts.push(new MarkdownString().appendCodeblock(displayParts.join(" "), "typescript"));
        }
        const md = documentationToMarkdown(data.documentation, data.tags, this.client, resource);
        parts.push(md);
        return parts;
      }
      getPreviousLevel(previousHover) {
        if (previousHover && this.lastHoverAndLevel && this.lastHoverAndLevel[0] === previousHover) {
          return this.lastHoverAndLevel[1];
        }
        return 0;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/implementations.ts
var implementations_exports = {};
__export(implementations_exports, {
  register: () => register15
});
function register15(selector, client) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerImplementationProvider(
      selector.semantic,
      new TypeScriptImplementationProvider(client)
    );
  });
}
var TypeScriptImplementationProvider;
var init_implementations = __esm({
  "src/typescript-language-features/src/languageFeatures/implementations.ts"() {
    "use strict";
    init_shims();
    init_typescriptService();
    init_definitionProviderBase();
    init_dependentRegistration();
    TypeScriptImplementationProvider = class extends TypeScriptDefinitionProviderBase {
      provideImplementation(document, position, token) {
        return this.getSymbolLocations("implementation", document, position, token);
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/inlayHints.ts
var inlayHints_exports = {};
__export(inlayHints_exports, {
  register: () => register16
});
function fromProtocolInlayHintKind(kind) {
  switch (kind) {
    case "Parameter":
      return 2 /* Parameter */;
    case "Type":
      return 1 /* Type */;
    case "Enum":
      return void 0;
    default:
      return void 0;
  }
}
function areInlayHintsEnabledForFile(language, document) {
  const config3 = workspace.getConfiguration(language.id, document);
  const preferences = getInlayHintsPreferences(config3);
  return preferences.includeInlayParameterNameHints === "literals" || preferences.includeInlayParameterNameHints === "all" || preferences.includeInlayEnumMemberValueHints || preferences.includeInlayFunctionLikeReturnTypeHints || preferences.includeInlayFunctionParameterTypeHints || preferences.includeInlayPropertyDeclarationTypeHints || preferences.includeInlayVariableTypeHints;
}
function register16(selector, language, client, fileConfigurationManager, telemetryReporter) {
  return conditionalRegistration([
    requireMinVersion(client, TypeScriptInlayHintsProvider.minVersion),
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    const provider = new TypeScriptInlayHintsProvider(language, client, fileConfigurationManager, telemetryReporter);
    return languages.registerInlayHintsProvider(selector.semantic, provider);
  });
}
var inlayHintSettingNames, TypeScriptInlayHintsProvider;
var init_inlayHints = __esm({
  "src/typescript-language-features/src/languageFeatures/inlayHints.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_typeConverters();
    init_typescriptService();
    init_dispose();
    init_fileConfigurationManager();
    init_dependentRegistration();
    inlayHintSettingNames = Object.freeze([
      InlayHintSettingNames.parameterNamesSuppressWhenArgumentMatchesName,
      InlayHintSettingNames.parameterNamesEnabled,
      InlayHintSettingNames.variableTypesEnabled,
      InlayHintSettingNames.variableTypesSuppressWhenTypeMatchesName,
      InlayHintSettingNames.propertyDeclarationTypesEnabled,
      InlayHintSettingNames.functionLikeReturnTypesEnabled,
      InlayHintSettingNames.enumMemberValuesEnabled
    ]);
    TypeScriptInlayHintsProvider = class extends Disposable {
      constructor(language, client, fileConfigurationManager, telemetryReporter) {
        super();
        this.language = language;
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
        this.telemetryReporter = telemetryReporter;
        this._onDidChangeInlayHints = this._register(new EventEmitter());
        this.onDidChangeInlayHints = this._onDidChangeInlayHints.event;
        this.hasReportedTelemetry = false;
        this._register(workspace.onDidChangeConfiguration((e) => {
          if (inlayHintSettingNames.some((settingName) => e.affectsConfiguration(language.id + "." + settingName))) {
            this._onDidChangeInlayHints.fire();
          }
        }));
        this._register(workspace.onDidChangeTextDocument((e) => {
          if (language.languageIds.includes(e.document.languageId)) {
            this._onDidChangeInlayHints.fire();
          }
        }));
      }
      async provideInlayHints(model, range, token) {
        const filepath = this.client.toOpenTsFilePath(model);
        if (!filepath) {
          return;
        }
        if (!areInlayHintsEnabledForFile(this.language, model)) {
          return;
        }
        const start = model.offsetAt(range.start);
        const length = model.offsetAt(range.end) - start;
        await this.fileConfigurationManager.ensureConfigurationForDocument(model, token);
        if (token.isCancellationRequested) {
          return;
        }
        if (!this.hasReportedTelemetry) {
          this.hasReportedTelemetry = true;
          this.telemetryReporter.logTelemetry("inlayHints.provide", {});
        }
        const response = await this.client.execute("provideInlayHints", { file: filepath, start, length }, token);
        if (response.type !== "response" || !response.success || !response.body) {
          return;
        }
        return response.body.map((hint) => {
          const result = new InlayHint(
            Position3.fromLocation(hint.position),
            this.convertInlayHintText(hint),
            fromProtocolInlayHintKind(hint.kind)
          );
          result.paddingLeft = hint.whitespaceBefore;
          result.paddingRight = hint.whitespaceAfter;
          return result;
        });
      }
      convertInlayHintText(tsHint) {
        if (tsHint.displayParts) {
          return tsHint.displayParts.map((part) => {
            const out = new InlayHintLabelPart(part.text);
            if (part.span) {
              out.location = Location2.fromTextSpan(this.client.toResource(part.span.file), part.span);
            }
            return out;
          });
        }
        return tsHint.text;
      }
    };
    TypeScriptInlayHintsProvider.minVersion = API.v440;
  }
});

// src/typescript-language-features/src/languageFeatures/jsDocCompletions.ts
var jsDocCompletions_exports = {};
__export(jsDocCompletions_exports, {
  register: () => register17,
  templateToSnippet: () => templateToSnippet
});
function templateToSnippet(template) {
  let snippetIndex = 1;
  template = template.replace(/\$/g, "\\$");
  template = template.replace(/^[ \t]*(?=(\/|[ ]\*))/gm, "");
  template = template.replace(/^(\/\*\*\s*\*[ ]*)$/m, (x) => x + `$0`);
  template = template.replace(/\* @param([ ]\{\S+\})?\s+(\S+)[ \t]*$/gm, (_param, type, post) => {
    let out = "* @param ";
    if (type === " {any}" || type === " {*}") {
      out += `{\${${snippetIndex++}:*}} `;
    } else if (type) {
      out += type + " ";
    }
    out += post + ` \${${snippetIndex++}}`;
    return out;
  });
  template = template.replace(/\* @returns[ \t]*$/gm, `* @returns \${${snippetIndex++}}`);
  return new SnippetString(template);
}
function register17(selector, language, client, fileConfigurationManager) {
  return languages.registerCompletionItemProvider(
    selector.syntax,
    new JsDocCompletionProvider(client, language, fileConfigurationManager),
    "*"
  );
}
var defaultJsDoc, JsDocCompletionItem, JsDocCompletionProvider;
var init_jsDocCompletions = __esm({
  "src/typescript-language-features/src/languageFeatures/jsDocCompletions.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    defaultJsDoc = new SnippetString(`/**
 * $0
 */`);
    JsDocCompletionItem = class extends CompletionItem {
      constructor(document, position) {
        super("/** */", 0 /* Text */);
        this.document = document;
        this.position = position;
        this.detail = l10n.t("JSDoc comment");
        this.sortText = "\0";
        const line = document.lineAt(position.line).text;
        const prefix = line.slice(0, position.character).match(/\/\**\s*$/);
        const suffix = line.slice(position.character).match(/^\s*\**\//);
        const start = position.translate(0, prefix ? -prefix[0].length : 0);
        const range = new Range(start, position.translate(0, suffix ? suffix[0].length : 0));
        this.range = { inserting: range, replacing: range };
      }
    };
    JsDocCompletionProvider = class {
      constructor(client, language, fileConfigurationManager) {
        this.client = client;
        this.language = language;
        this.fileConfigurationManager = fileConfigurationManager;
      }
      async provideCompletionItems(document, position, token) {
        if (!workspace.getConfiguration(this.language.id, document).get("suggest.completeJSDocs")) {
          return void 0;
        }
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        if (!this.isPotentiallyValidDocCompletionPosition(document, position)) {
          return void 0;
        }
        const response = await this.client.interruptGetErr(async () => {
          await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
          const args = Position3.toFileLocationRequestArgs(file2, position);
          return this.client.execute("docCommentTemplate", args, token);
        });
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        const item = new JsDocCompletionItem(document, position);
        if (response.body.newText === "/** */") {
          item.insertText = defaultJsDoc;
        } else {
          item.insertText = templateToSnippet(response.body.newText);
        }
        return [item];
      }
      isPotentiallyValidDocCompletionPosition(document, position) {
        const line = document.lineAt(position.line).text;
        const prefix = line.slice(0, position.character);
        if (!/^\s*$|\/\*\*\s*$|^\s*\/\*\*+\s*$/.test(prefix)) {
          return false;
        }
        const suffix = line.slice(position.character);
        return /^\s*(\*+\/)?\s*$/.test(suffix);
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/linkedEditing.ts
var linkedEditing_exports = {};
__export(linkedEditing_exports, {
  register: () => register18
});
function register18(selector, client) {
  return conditionalRegistration([
    requireMinVersion(client, LinkedEditingSupport.minVersion),
    requireSomeCapability(client, 0 /* Syntax */)
  ], () => {
    return languages.registerLinkedEditingRangeProvider(
      selector.syntax,
      new LinkedEditingSupport(client)
    );
  });
}
var LinkedEditingSupport;
var init_linkedEditing = __esm({
  "src/typescript-language-features/src/languageFeatures/linkedEditing.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    LinkedEditingSupport = class {
      constructor(client) {
        this.client = client;
      }
      async provideLinkedEditingRanges(document, position, token) {
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return void 0;
        }
        const args = Position3.toFileLocationRequestArgs(filepath, position);
        const response = await this.client.execute("linkedEditingRange", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        const wordPattern = response.body.wordPattern ? new RegExp(response.body.wordPattern) : void 0;
        return new LinkedEditingRanges(response.body.ranges.map((range) => Range4.fromTextSpan(range)), wordPattern);
      }
    };
    LinkedEditingSupport.minVersion = API.v510;
  }
});

// src/typescript-language-features/src/languageFeatures/mappedCodeEditProvider.ts
var mappedCodeEditProvider_exports = {};
__export(mappedCodeEditProvider_exports, {
  register: () => register19
});
function register19(selector, client) {
  return conditionalRegistration([
    requireMinVersion(client, API.v540)
  ], () => {
    const provider = new TsMappedEditsProvider(client);
    return chat.registerMappedEditsProvider(selector.semantic, provider);
  });
}
var TsMappedEditsProvider;
var init_mappedCodeEditProvider = __esm({
  "src/typescript-language-features/src/languageFeatures/mappedCodeEditProvider.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_dependentRegistration();
    init_typeConverters();
    TsMappedEditsProvider = class {
      constructor(client) {
        this.client = client;
      }
      async provideMappedEdits(document, codeBlocks, context, token) {
        if (!this.isEnabled()) {
          return;
        }
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return;
        }
        const response = await this.client.execute("mapCode", {
          file: file2,
          mapping: {
            contents: codeBlocks,
            focusLocations: context.documents.map((documents) => {
              return documents.flatMap((contextItem) => {
                const file3 = this.client.toTsFilePath(contextItem.uri);
                if (!file3) {
                  return [];
                }
                return contextItem.ranges.map((range) => ({ file: file3, ...Range4.toTextSpan(range) }));
              });
            })
          }
        }, token);
        if (response.type !== "response" || !response.body) {
          return;
        }
        return WorkspaceEdit2.fromFileCodeEdits(this.client, response.body);
      }
      isEnabled() {
        return workspace.getConfiguration("typescript").get("experimental.mappedCodeEdits.enabled", false);
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/organizeImports.ts
var organizeImports_exports = {};
__export(organizeImports_exports, {
  register: () => register20
});
function register20(selector, client, commandManager, fileConfigurationManager, telemetryReporter) {
  const disposables = [];
  for (const command of [organizeImportsCommand, sortImportsCommand, removeUnusedImportsCommand]) {
    disposables.push(
      conditionalRegistration([
        requireMinVersion(client, command.minVersion ?? API.defaultVersion),
        requireSomeCapability(client, 2 /* Semantic */)
      ], () => {
        const provider = new ImportsCodeActionProvider(client, command, commandManager, fileConfigurationManager, telemetryReporter);
        return Disposable4.from(
          languages.registerCodeActionsProvider(selector.semantic, provider, {
            providedCodeActionKinds: [command.kind]
          }),
          ...command.commandIds.map((id) => commandManager.register({
            id,
            async execute(filePath) {
              const document = await workspace.openTextDocument(filePath);
              const importAction = provider.provideCodeActions(
                document,
                new Range(0, 0, 0, 0),
                {
                  triggerKind: 1 /* Invoke */,
                  diagnostics: [],
                  only: command.kind
                },
                nulToken
              )[0];
              const resolvedImportAction = await provider.resolveCodeAction(importAction, nulToken);
              if (resolvedImportAction == null ? void 0 : resolvedImportAction.edit) {
                return await workspace.applyEdit(resolvedImportAction.edit);
              }
            }
          }))
        );
      })
      // Always register these commands. We will show a warning if the user tries to run them on an unsupported version
    );
  }
  return Disposable4.from(...disposables);
}
var organizeImportsCommand, sortImportsCommand, removeUnusedImportsCommand, _DidOrganizeImportsCommand, DidOrganizeImportsCommand, ImportCodeAction, ImportsCodeActionProvider;
var init_organizeImports = __esm({
  "src/typescript-language-features/src/languageFeatures/organizeImports.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_protocol_const();
    init_typeConverters();
    init_typescriptService();
    init_cancellation();
    init_dependentRegistration();
    organizeImportsCommand = {
      commandIds: ["typescript.organizeImports"],
      title: l10n.t("Organize Imports"),
      kind: CodeActionKind.SourceOrganizeImports,
      mode: "All" /* All */
    };
    sortImportsCommand = {
      commandIds: ["typescript.sortImports", "javascript.sortImports"],
      minVersion: API.v430,
      title: l10n.t("Sort Imports"),
      kind: CodeActionKind.Source.append("sortImports"),
      mode: "SortAndCombine" /* SortAndCombine */
    };
    removeUnusedImportsCommand = {
      commandIds: ["typescript.removeUnusedImports", "javascript.removeUnusedImports"],
      minVersion: API.v490,
      title: l10n.t("Remove Unused Imports"),
      kind: CodeActionKind.Source.append("removeUnusedImports"),
      mode: "RemoveUnused" /* RemoveUnused */
    };
    _DidOrganizeImportsCommand = class _DidOrganizeImportsCommand {
      constructor(telemetryReporter) {
        this.telemetryReporter = telemetryReporter;
        this.id = _DidOrganizeImportsCommand.ID;
      }
      async execute() {
        this.telemetryReporter.logTelemetry("organizeImports.execute", {});
      }
    };
    _DidOrganizeImportsCommand.ID = "_typescript.didOrganizeImports";
    DidOrganizeImportsCommand = _DidOrganizeImportsCommand;
    ImportCodeAction = class extends CodeAction {
      constructor(title, kind, document) {
        super(title, kind);
        this.document = document;
      }
    };
    ImportsCodeActionProvider = class {
      constructor(client, commandMetadata, commandManager, fileConfigManager, telemetryReporter) {
        this.client = client;
        this.commandMetadata = commandMetadata;
        this.fileConfigManager = fileConfigManager;
        commandManager.register(new DidOrganizeImportsCommand(telemetryReporter));
      }
      provideCodeActions(document, _range, context, _token) {
        var _a;
        if (!((_a = context.only) == null ? void 0 : _a.contains(this.commandMetadata.kind))) {
          return [];
        }
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return [];
        }
        return [new ImportCodeAction(this.commandMetadata.title, this.commandMetadata.kind, document)];
      }
      async resolveCodeAction(codeAction, token) {
        const response = await this.client.interruptGetErr(async () => {
          await this.fileConfigManager.ensureConfigurationForDocument(codeAction.document, token);
          if (token.isCancellationRequested) {
            return;
          }
          const file2 = this.client.toOpenTsFilePath(codeAction.document);
          if (!file2) {
            return;
          }
          const args = {
            scope: {
              type: "file",
              args: { file: file2 }
            },
            // Deprecated in 4.9; `mode` takes priority
            skipDestructiveCodeActions: this.commandMetadata.mode === "SortAndCombine" /* SortAndCombine */,
            mode: OrganizeImportsMode2.toProtocolOrganizeImportsMode(this.commandMetadata.mode)
          };
          return this.client.execute("organizeImports", args, nulToken);
        });
        if ((response == null ? void 0 : response.type) !== "response" || !response.body || token.isCancellationRequested) {
          return;
        }
        if (response.body.length) {
          codeAction.edit = WorkspaceEdit2.fromFileCodeEdits(this.client, response.body);
        }
        codeAction.command = { command: DidOrganizeImportsCommand.ID, title: "", arguments: [] };
        return codeAction;
      }
    };
  }
});

// src/typescript-language-features/src/utils/memoize.ts
function memoize(_target, key, descriptor) {
  let fnKey;
  let fn;
  if (typeof descriptor.value === "function") {
    fnKey = "value";
    fn = descriptor.value;
  } else if (typeof descriptor.get === "function") {
    fnKey = "get";
    fn = descriptor.get;
  } else {
    throw new Error("not supported");
  }
  const memoizeKey = `$memoize$${key}`;
  descriptor[fnKey] = function(...args) {
    if (!this.hasOwnProperty(memoizeKey)) {
      Object.defineProperty(this, memoizeKey, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: fn.apply(this, args)
      });
    }
    return this[memoizeKey];
  };
}
var init_memoize = __esm({
  "src/typescript-language-features/src/utils/memoize.ts"() {
    "use strict";
  }
});

// src/typescript-language-features/src/languageFeatures/util/copilot.ts
function findScopeEndLineFromNavTreeWorker(startLine, navigationTree) {
  for (const node of navigationTree) {
    const range = Range4.fromTextSpan(node.spans[0]);
    if (startLine === range.start.line) {
      return range;
    } else if (startLine > range.start.line && startLine <= range.end.line && node.childItems) {
      return findScopeEndLineFromNavTreeWorker(startLine, node.childItems);
    }
  }
  return void 0;
}
async function findScopeEndLineFromNavTree(client, document, startLine) {
  var _a;
  const filepath = client.toOpenTsFilePath(document);
  if (!filepath) {
    return;
  }
  const response = await client.execute(
    "navtree",
    { file: filepath },
    nulToken
  );
  if (response.type !== "response" || !((_a = response.body) == null ? void 0 : _a.childItems)) {
    return;
  }
  return findScopeEndLineFromNavTreeWorker(startLine, response.body.childItems);
}
async function findEditScope(client, document, edits) {
  let first = Position3.fromLocation(edits[0].start);
  let firstEdit = edits[0];
  let lastEdit = edits[0];
  let last = Position3.fromLocation(edits[0].start);
  for (const edit of edits) {
    const start2 = Position3.fromLocation(edit.start);
    const end2 = Position3.fromLocation(edit.end);
    if (start2.compareTo(first) < 0) {
      first = start2;
      firstEdit = edit;
    }
    if (end2.compareTo(last) > 0) {
      last = end2;
      lastEdit = edit;
    }
  }
  const text = document.getText();
  const startIndex = text.indexOf(firstEdit.newText);
  const start = startIndex > -1 ? document.positionAt(startIndex) : first;
  const endIndex = text.lastIndexOf(lastEdit.newText);
  const end = endIndex > -1 ? document.positionAt(endIndex + lastEdit.newText.length) : last;
  const expandEnd = await findScopeEndLineFromNavTree(
    client,
    document,
    end.line
  );
  return new Range(start, (expandEnd == null ? void 0 : expandEnd.end) ?? end);
}
var _EditorChatFollowUp, EditorChatFollowUp, _CompositeCommand, CompositeCommand;
var init_copilot = __esm({
  "src/typescript-language-features/src/languageFeatures/util/copilot.ts"() {
    "use strict";
    init_shims();
    init_cancellation();
    init_typeConverters();
    _EditorChatFollowUp = class _EditorChatFollowUp {
      constructor(client, telemetryReporter) {
        this.client = client;
        this.telemetryReporter = telemetryReporter;
        this.id = _EditorChatFollowUp.ID;
      }
      async execute({ message, document, expand, action }) {
        if (action.type === "quickfix") {
          this.telemetryReporter.logTelemetry("aiQuickfix.execute", {
            action: action.quickfix.fixName
          });
        } else {
          this.telemetryReporter.logTelemetry("aiRefactor.execute", {
            action: action.refactor.name
          });
        }
        const initialRange = expand.kind === "navtree-function" ? await findScopeEndLineFromNavTree(
          this.client,
          document,
          expand.pos.line
        ) : expand.kind === "refactor-info" ? await findEditScope(
          this.client,
          document,
          expand.refactor.edits.flatMap((e) => e.textChanges)
        ) : expand.kind === "code-action" ? await findEditScope(
          this.client,
          document,
          expand.action.changes.flatMap((c) => c.textChanges)
        ) : expand.range;
        const initialSelection = initialRange ? new Selection(initialRange.start, initialRange.end) : void 0;
        await commands.executeCommand("vscode.editorChat.start", {
          initialRange,
          initialSelection,
          message,
          autoSend: true
        });
      }
    };
    _EditorChatFollowUp.ID = "_typescript.quickFix.editorChatReplacement2";
    EditorChatFollowUp = _EditorChatFollowUp;
    _CompositeCommand = class _CompositeCommand {
      constructor() {
        this.id = _CompositeCommand.ID;
      }
      async execute(...commands3) {
        for (const command of commands3) {
          await commands.executeCommand(
            command.command,
            ...command.arguments ?? []
          );
        }
      }
    };
    _CompositeCommand.ID = "_typescript.compositeCommand";
    CompositeCommand = _CompositeCommand;
  }
});

// src/typescript-language-features/src/languageFeatures/quickFix.ts
var quickFix_exports = {};
__export(quickFix_exports, {
  register: () => register21
});
function isPreferredFix(action, allActions) {
  if (action instanceof VsCodeFixAllCodeAction) {
    return false;
  }
  const fixPriority = preferredFixes.get(action.tsAction.fixName);
  if (!fixPriority) {
    return false;
  }
  return allActions.every((otherAction) => {
    if (otherAction === action) {
      return true;
    }
    if (otherAction instanceof VsCodeFixAllCodeAction) {
      return true;
    }
    const otherFixPriority = preferredFixes.get(otherAction.tsAction.fixName);
    if (!otherFixPriority || otherFixPriority.priority < fixPriority.priority) {
      return true;
    } else if (otherFixPriority.priority > fixPriority.priority) {
      return false;
    }
    if (fixPriority.thereCanOnlyBeOne && action.tsAction.fixName === otherAction.tsAction.fixName) {
      return false;
    }
    return true;
  });
}
function register21(selector, client, fileConfigurationManager, commandManager, diagnosticsManager, telemetryReporter) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerCodeActionsProvider(
      selector.semantic,
      new TypeScriptQuickFixProvider(client, fileConfigurationManager, commandManager, diagnosticsManager, telemetryReporter),
      TypeScriptQuickFixProvider.metadata
    );
  });
}
var _ApplyCodeActionCommand, ApplyCodeActionCommand, _ApplyFixAllCodeAction, ApplyFixAllCodeAction, DiagnosticsSet, VsCodeCodeAction, VsCodeFixAllCodeAction, CodeActionSet, SupportedCodeActionProvider, _TypeScriptQuickFixProvider, TypeScriptQuickFixProvider, fixAllErrorCodes, preferredFixes;
var init_quickFix = __esm({
  "src/typescript-language-features/src/languageFeatures/quickFix.ts"() {
    "use strict";
    init_shims();
    init_fixNames();
    init_typeConverters();
    init_typescriptService();
    init_cancellation();
    init_memoize();
    init_objects();
    init_codeAction();
    init_dependentRegistration();
    init_copilot();
    init_share();
    _ApplyCodeActionCommand = class _ApplyCodeActionCommand {
      constructor(client, diagnosticManager, telemetryReporter) {
        this.client = client;
        this.diagnosticManager = diagnosticManager;
        this.telemetryReporter = telemetryReporter;
        this.id = _ApplyCodeActionCommand.ID;
      }
      async execute({ document, action, diagnostic, followupAction }) {
        this.telemetryReporter.logTelemetry("quickFix.execute", {
          fixName: action.fixName
        });
        this.diagnosticManager.deleteDiagnostic(document.uri, diagnostic);
        const codeActionResult = await applyCodeActionCommands(this.client, action.commands, nulToken);
        await (followupAction == null ? void 0 : followupAction.execute());
        return codeActionResult;
      }
    };
    _ApplyCodeActionCommand.ID = "_typescript.applyCodeActionCommand";
    ApplyCodeActionCommand = _ApplyCodeActionCommand;
    _ApplyFixAllCodeAction = class _ApplyFixAllCodeAction {
      constructor(client, telemetryReporter) {
        this.client = client;
        this.telemetryReporter = telemetryReporter;
        this.id = _ApplyFixAllCodeAction.ID;
      }
      async execute(args) {
        this.telemetryReporter.logTelemetry("quickFixAll.execute", {
          fixName: args.tsAction.fixName
        });
        if (args.combinedResponse) {
          await applyCodeActionCommands(this.client, args.combinedResponse.body.commands, nulToken);
        }
      }
    };
    _ApplyFixAllCodeAction.ID = "_typescript.applyFixAllCodeAction";
    ApplyFixAllCodeAction = _ApplyFixAllCodeAction;
    DiagnosticsSet = class _DiagnosticsSet {
      constructor(_values) {
        this._values = _values;
      }
      static from(diagnostics) {
        const values = /* @__PURE__ */ new Map();
        for (const diagnostic of diagnostics) {
          values.set(_DiagnosticsSet.key(diagnostic), diagnostic);
        }
        return new _DiagnosticsSet(values);
      }
      static key(diagnostic) {
        const { start, end } = diagnostic.range;
        return `${diagnostic.code}-${start.line},${start.character}-${end.line},${end.character}`;
      }
      get values() {
        return this._values.values();
      }
      get size() {
        return this._values.size;
      }
    };
    VsCodeCodeAction = class extends CodeAction {
      constructor(tsAction, title, kind) {
        super(title, kind);
        this.tsAction = tsAction;
      }
    };
    VsCodeFixAllCodeAction = class extends VsCodeCodeAction {
      constructor(tsAction, file2, title, kind) {
        super(tsAction, title, kind);
        this.file = file2;
      }
    };
    CodeActionSet = class {
      constructor() {
        this._actions = /* @__PURE__ */ new Set();
        this._fixAllActions = /* @__PURE__ */ new Map();
        this._aiActions = /* @__PURE__ */ new Set();
      }
      *values() {
        yield* this._actions;
        yield* this._aiActions;
      }
      addAction(action) {
        if (action.isAI) {
          this._aiActions.add(action);
          return;
        }
        for (const existing of this._actions) {
          if (action.tsAction.fixName === existing.tsAction.fixName && equals2(action.edit, existing.edit)) {
            this._actions.delete(existing);
          }
        }
        this._actions.add(action);
        if (action.tsAction.fixId) {
          const existingFixAll = this._fixAllActions.get(action.tsAction.fixId);
          if (existingFixAll) {
            this._actions.delete(existingFixAll);
            this._actions.add(existingFixAll);
          }
        }
      }
      addFixAllAction(fixId, action) {
        const existing = this._fixAllActions.get(fixId);
        if (existing) {
          this._actions.delete(existing);
        }
        this.addAction(action);
        this._fixAllActions.set(fixId, action);
      }
      hasFixAllAction(fixId) {
        return this._fixAllActions.has(fixId);
      }
    };
    SupportedCodeActionProvider = class {
      constructor(client) {
        this.client = client;
      }
      async getFixableDiagnosticsForContext(diagnostics) {
        const fixableCodes = await this.fixableDiagnosticCodes;
        return DiagnosticsSet.from(
          diagnostics.filter((diagnostic) => typeof diagnostic.code !== "undefined" && fixableCodes.has(diagnostic.code + ""))
        );
      }
      get fixableDiagnosticCodes() {
        return this.client.execute("getSupportedCodeFixes", null, nulToken).then((response) => response.type === "response" ? response.body || [] : []).then((codes) => new Set(codes));
      }
    };
    __decorateClass([
      memoize
    ], SupportedCodeActionProvider.prototype, "fixableDiagnosticCodes", 1);
    _TypeScriptQuickFixProvider = class _TypeScriptQuickFixProvider {
      constructor(client, formattingConfigurationManager, commandManager, diagnosticsManager, telemetryReporter) {
        this.client = client;
        this.formattingConfigurationManager = formattingConfigurationManager;
        this.diagnosticsManager = diagnosticsManager;
        commandManager.register(new CompositeCommand());
        commandManager.register(new ApplyCodeActionCommand(client, diagnosticsManager, telemetryReporter));
        commandManager.register(new ApplyFixAllCodeAction(client, telemetryReporter));
        commandManager.register(new EditorChatFollowUp(client, telemetryReporter));
        this.supportedCodeActionProvider = new SupportedCodeActionProvider(client);
      }
      async provideCodeActions(document, range, context, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return;
        }
        let diagnostics = context.diagnostics;
        if (this.client.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {
          await new Promise((resolve) => {
            setTimeout(resolve, 500);
          });
          if (token.isCancellationRequested) {
            return;
          }
          const allDiagnostics = [];
          for (const diagnostic of this.diagnosticsManager.getDiagnostics(document.uri)) {
            if (range.intersection(diagnostic.range)) {
              const newLen = allDiagnostics.push(diagnostic);
              if (newLen > _TypeScriptQuickFixProvider._maxCodeActionsPerFile) {
                break;
              }
            }
          }
          diagnostics = allDiagnostics;
        }
        const fixableDiagnostics = await this.supportedCodeActionProvider.getFixableDiagnosticsForContext(diagnostics);
        if (!fixableDiagnostics.size || token.isCancellationRequested) {
          return;
        }
        await this.formattingConfigurationManager.ensureConfigurationForDocument(document, token);
        if (token.isCancellationRequested) {
          return;
        }
        const results = new CodeActionSet();
        for (const diagnostic of fixableDiagnostics.values) {
          await this.getFixesForDiagnostic(document, file2, diagnostic, results, token);
          if (token.isCancellationRequested) {
            return;
          }
        }
        const allActions = Array.from(results.values());
        for (const action of allActions) {
          action.isPreferred = isPreferredFix(action, allActions);
        }
        return allActions;
      }
      async resolveCodeAction(codeAction, token) {
        if (!(codeAction instanceof VsCodeFixAllCodeAction) || !codeAction.tsAction.fixId) {
          return codeAction;
        }
        const arg = {
          scope: {
            type: "file",
            args: { file: codeAction.file }
          },
          fixId: codeAction.tsAction.fixId
        };
        const response = await this.client.execute("getCombinedCodeFix", arg, token);
        if (response.type === "response") {
          codeAction.combinedResponse = response;
          codeAction.edit = WorkspaceEdit2.fromFileCodeEdits(
            this.client,
            response.body.changes
          );
          codeAction.command = {
            command: ApplyFixAllCodeAction.ID,
            arguments: [{ tsAction: codeAction.tsAction, combinedResponse: response }],
            title: ""
          };
        }
        return codeAction;
      }
      async getFixesForDiagnostic(document, file2, diagnostic, results, token) {
        const args = {
          ...Range4.toFileRangeRequestArgs(file2, diagnostic.range),
          errorCodes: [+diagnostic.code]
        };
        const response = await this.client.execute("getCodeFixes", args, token);
        if (response.type !== "response" || !response.body) {
          return results;
        }
        for (const tsCodeFix of response.body) {
          for (const action of this.getFixesForTsCodeAction(document, diagnostic, tsCodeFix)) {
            results.addAction(action);
          }
          this.addFixAllForTsCodeAction(results, document.uri, file2, diagnostic, tsCodeFix);
        }
        return results;
      }
      getFixesForTsCodeAction(document, diagnostic, action) {
        var _a;
        const actions = [];
        const codeAction = new VsCodeCodeAction(action, action.description, CodeActionKind.QuickFix);
        codeAction.edit = getEditForCodeAction(this.client, action);
        codeAction.diagnostics = [diagnostic];
        codeAction.ranges = [diagnostic.range];
        codeAction.command = {
          command: ApplyCodeActionCommand.ID,
          arguments: commandsConverter[ApplyCodeActionCommand.ID].toArgs({ action, diagnostic, document }),
          title: ""
        };
        actions.push(codeAction);
        const copilot = extensions.getExtension("github.copilot-chat");
        if (copilot == null ? void 0 : copilot.isActive) {
          let message;
          let expand;
          let title = action.description;
          if (action.fixName === classIncorrectlyImplementsInterface) {
            title += " with Copilot";
            message = `Implement the stubbed-out class members for ${document.getText(diagnostic.range)} with a useful implementation.`;
            expand = { kind: "code-action", action };
          } else if (action.fixName === fixClassDoesntImplementInheritedAbstractMember) {
            title += " with Copilot";
            message = `Implement the stubbed-out class members for ${document.getText(diagnostic.range)} with a useful implementation.`;
            expand = { kind: "code-action", action };
          } else if (action.fixName === fixMissingFunctionDeclaration) {
            title = `Implement missing function declaration '${document.getText(diagnostic.range)}' using Copilot`;
            message = `Provide a reasonable implementation of the function ${document.getText(diagnostic.range)} given its type and the context it's called in.`;
            expand = { kind: "code-action", action };
          } else if (action.fixName === inferFromUsage) {
            const inferFromBody = new VsCodeCodeAction(action, "Infer types using Copilot", CodeActionKind.QuickFix);
            inferFromBody.edit = new WorkspaceEdit();
            inferFromBody.diagnostics = [diagnostic];
            inferFromBody.ranges = [diagnostic.range];
            inferFromBody.isAI = true;
            inferFromBody.command = {
              command: EditorChatFollowUp.ID,
              arguments: [{
                message: "Add types to this code. Add separate interfaces when possible. Do not change the code except for adding types.",
                expand: { kind: "navtree-function", pos: diagnostic.range.start },
                document,
                action: { type: "quickfix", quickfix: action }
              }],
              title: ""
            };
            actions.push(inferFromBody);
          } else if (action.fixName === addNameToNamelessParameter) {
            const newText = action.changes.map((change) => change.textChanges.map((textChange) => textChange.newText).join("")).join("");
            title = "Add meaningful parameter name with Copilot";
            message = `Rename the parameter ${newText} with a more meaningful name.`;
            expand = {
              kind: "navtree-function",
              pos: diagnostic.range.start
            };
          }
          if (expand && message !== void 0) {
            const aiCodeAction = new VsCodeCodeAction(action, title, CodeActionKind.QuickFix);
            aiCodeAction.edit = getEditForCodeAction(this.client, action);
            (_a = aiCodeAction.edit) == null ? void 0 : _a.insert(document.uri, diagnostic.range.start, "");
            aiCodeAction.diagnostics = [diagnostic];
            aiCodeAction.ranges = [diagnostic.range];
            aiCodeAction.isAI = true;
            aiCodeAction.command = {
              command: CompositeCommand.ID,
              title: "",
              arguments: [{
                command: ApplyCodeActionCommand.ID,
                arguments: [{ action, diagnostic, document }],
                title: ""
              }, {
                command: EditorChatFollowUp.ID,
                title: "",
                arguments: [{
                  message,
                  expand,
                  document,
                  action: { type: "quickfix", quickfix: action }
                }]
              }]
            };
            actions.push(aiCodeAction);
          }
        }
        return actions;
      }
      addFixAllForTsCodeAction(results, resource, file2, diagnostic, tsAction) {
        if (!tsAction.fixId || results.hasFixAllAction(tsAction.fixId)) {
          return results;
        }
        if (!this.diagnosticsManager.getDiagnostics(resource).some((x) => {
          if (x === diagnostic) {
            return false;
          }
          return x.code === diagnostic.code || fixAllErrorCodes.has(x.code) && fixAllErrorCodes.get(x.code) === fixAllErrorCodes.get(diagnostic.code);
        })) {
          return results;
        }
        const action = new VsCodeFixAllCodeAction(
          tsAction,
          file2,
          tsAction.fixAllDescription || l10n.t("{0} (Fix all in file)", tsAction.description),
          CodeActionKind.QuickFix
        );
        action.diagnostics = [diagnostic];
        action.ranges = [diagnostic.range];
        action.command = {
          command: ApplyFixAllCodeAction.ID,
          arguments: [{ tsAction, combinedResponse: action.combinedResponse }],
          title: ""
        };
        results.addFixAllAction(tsAction.fixId, action);
        return results;
      }
    };
    _TypeScriptQuickFixProvider._maxCodeActionsPerFile = 1e3;
    _TypeScriptQuickFixProvider.metadata = {
      providedCodeActionKinds: [CodeActionKind.QuickFix]
    };
    TypeScriptQuickFixProvider = _TypeScriptQuickFixProvider;
    fixAllErrorCodes = /* @__PURE__ */ new Map([
      // Missing async
      [2339, 2339],
      [2345, 2339]
    ]);
    preferredFixes = /* @__PURE__ */ new Map([
      [annotateWithTypeFromJSDoc, { priority: 2 }],
      [constructorForDerivedNeedSuperCall, { priority: 2 }],
      [extendsInterfaceBecomesImplements, { priority: 2 }],
      [awaitInSyncFunction, { priority: 2 }],
      [removeUnnecessaryAwait, { priority: 2 }],
      [classIncorrectlyImplementsInterface, { priority: 3 }],
      [classDoesntImplementInheritedAbstractMember, { priority: 3 }],
      [unreachableCode2, { priority: 2 }],
      [unusedIdentifier, { priority: 2 }],
      [forgottenThisPropertyAccess, { priority: 2 }],
      [spelling, { priority: 0 }],
      [addMissingAwait, { priority: 2 }],
      [addMissingOverride, { priority: 2 }],
      [addMissingNewOperator, { priority: 2 }],
      [fixImport, { priority: 1, thereCanOnlyBeOne: true }]
    ]);
  }
});

// src/typescript-language-features/src/languageFeatures/refactor.ts
var refactor_exports = {};
__export(refactor_exports, {
  register: () => register22
});
import * as path5 from "path";
import { Utils as Utils2 } from "vscode-uri";
function toWorkspaceEdit(client, edits) {
  const workspaceEdit = new WorkspaceEdit();
  for (const edit of edits) {
    const resource = client.toResource(edit.fileName);
    if (resource.scheme === file) {
      workspaceEdit.createFile(resource, { ignoreIfExists: true });
    }
  }
  WorkspaceEdit2.withFileCodeEdits(workspaceEdit, client, edits);
  return workspaceEdit;
}
function register22(selector, client, cachedNavTree, formattingOptionsManager, commandManager, telemetryReporter) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerCodeActionsProvider(
      selector.semantic,
      new TypeScriptRefactorProvider(client, cachedNavTree, formattingOptionsManager, commandManager, telemetryReporter),
      TypeScriptRefactorProvider.metadata
    );
  });
}
var _DidApplyRefactoringCommand, DidApplyRefactoringCommand, _SelectRefactorCommand, SelectRefactorCommand, _MoveToFileRefactorCommand, MoveToFileRefactorCommand, Extract_Function, Extract_Constant, Extract_Type, Extract_Interface, Move_File, Move_NewFile, Rewrite_Import, Rewrite_Export, Rewrite_Arrow_Braces, Rewrite_Parameters_ToDestructured, Rewrite_Property_GenerateAccessors, allKnownCodeActionKinds, InlinedCodeAction, MoveToFileCodeAction, SelectCodeAction, _TypeScriptRefactorProvider, TypeScriptRefactorProvider;
var init_refactor = __esm({
  "src/typescript-language-features/src/languageFeatures/refactor.ts"() {
    "use strict";
    init_shims();
    init_learnMoreAboutRefactorings();
    init_fileSchemes();
    init_schemes();
    init_api2();
    init_protocol_const();
    init_typeConverters();
    init_typescriptService();
    init_arrays();
    init_cancellation();
    init_copilot();
    init_dependentRegistration();
    init_share();
    _DidApplyRefactoringCommand = class _DidApplyRefactoringCommand {
      constructor(telemetryReporter) {
        this.telemetryReporter = telemetryReporter;
        this.id = _DidApplyRefactoringCommand.ID;
      }
      async execute(args) {
        this.telemetryReporter.logTelemetry("refactor.execute", {
          action: args.action,
          trigger: args.trigger
        });
      }
    };
    _DidApplyRefactoringCommand.ID = "_typescript.didApplyRefactoring";
    DidApplyRefactoringCommand = _DidApplyRefactoringCommand;
    _SelectRefactorCommand = class _SelectRefactorCommand {
      constructor(client) {
        this.client = client;
        this.id = _SelectRefactorCommand.ID;
      }
      async execute(args) {
        const file2 = this.client.toOpenTsFilePath(args.document);
        if (!file2) {
          return;
        }
        const selected = await window.showQuickPick(args.refactor.actions.map((action) => ({
          action,
          label: action.name,
          description: action.description
        })));
        if (!selected) {
          return;
        }
        const tsAction = new InlinedCodeAction(this.client, args.document, args.refactor, selected.action, args.rangeOrSelection, args.trigger);
        await tsAction.resolve(nulToken);
        if (tsAction.edit) {
          if (!await workspace.applyEdit(tsAction.edit, { isRefactoring: true })) {
            window.showErrorMessage(l10n.t("Could not apply refactoring"));
            return;
          }
        }
        if (tsAction.command) {
          await commands.executeCommand(tsAction.command.command, ...tsAction.command.arguments ?? []);
        }
      }
    };
    _SelectRefactorCommand.ID = "_typescript.selectRefactoring";
    SelectRefactorCommand = _SelectRefactorCommand;
    _MoveToFileRefactorCommand = class _MoveToFileRefactorCommand {
      constructor(client, didApplyCommand) {
        this.client = client;
        this.didApplyCommand = didApplyCommand;
        this.id = _MoveToFileRefactorCommand.ID;
      }
      async execute(args) {
        const file2 = this.client.toOpenTsFilePath(args.document);
        if (!file2) {
          return;
        }
        const targetFile = args.targetFile;
        if (!targetFile || targetFile.toString() === file2.toString()) {
          return;
        }
        const fileSuggestionArgs = {
          ...Range4.toFileRangeRequestArgs(file2, args.range),
          action: "Move to file",
          refactor: "Move to file",
          interactiveRefactorArguments: { targetFile }
        };
        const response = await this.client.execute("getEditsForRefactor", fileSuggestionArgs, nulToken);
        if (response.type !== "response" || !response.body) {
          return;
        }
        const edit = toWorkspaceEdit(this.client, response.body.edits);
        if (!await workspace.applyEdit(edit, { isRefactoring: true })) {
          window.showErrorMessage(l10n.t("Could not apply refactoring"));
          return;
        }
        await this.didApplyCommand.execute({ action: args.action.name, trigger: args.trigger });
      }
      async getTargetFile(document, file2, range) {
        const args = Range4.toFileRangeRequestArgs(file2, range);
        const response = await this.client.execute("getMoveToRefactoringFileSuggestions", args, nulToken);
        if (response.type !== "response" || !response.body) {
          return;
        }
        const body = response.body;
        const selectExistingFileItem = { label: l10n.t("Select existing file...") };
        const selectNewFileItem = { label: l10n.t("Enter new file path...") };
        const workspaceFolder = workspace.getWorkspaceFolder(document.uri);
        const quickPick = window.createQuickPick();
        quickPick.ignoreFocusOut = true;
        let quickPickInRelativeMode = true;
        const updateItems = () => {
          const relativeQuery = ["./", "../"].find((str) => quickPick.value.startsWith(str));
          if (quickPickInRelativeMode === false && !!relativeQuery === false) {
            return;
          }
          quickPickInRelativeMode = !!relativeQuery;
          const destinationItems = body.files.map((file3) => {
            const uri = this.client.toResource(file3);
            const parentDir = Utils2.dirname(uri);
            const filename = Utils2.basename(uri);
            let description2;
            if (workspaceFolder) {
              if (uri.scheme === Schemes.file) {
                description2 = path5.relative(workspaceFolder.uri.fsPath, parentDir.fsPath);
              } else {
                description2 = path5.posix.relative(workspaceFolder.uri.path, parentDir.path);
              }
              if (relativeQuery) {
                const convertRelativePath = (str) => {
                  return !str.startsWith("../") ? `./${str}` : str;
                };
                const relativePath = convertRelativePath(path5.relative(path5.dirname(document.uri.fsPath), uri.fsPath));
                if (!relativePath.startsWith(relativeQuery)) {
                  return;
                }
                description2 = relativePath;
              }
            } else {
              description2 = parentDir.fsPath;
            }
            return {
              file: file3,
              label: Utils2.basename(uri),
              description: relativeQuery ? description2 : path5.join(description2, filename)
            };
          });
          quickPick.items = [
            selectExistingFileItem,
            selectNewFileItem,
            { label: l10n.t("destination files"), kind: -1 /* Separator */ },
            ...coalesce(destinationItems)
          ];
        };
        quickPick.title = l10n.t("Move to File");
        quickPick.placeholder = l10n.t("Enter file path");
        quickPick.matchOnDescription = true;
        quickPick.onDidChangeValue(updateItems);
        updateItems();
        const picked = await new Promise((resolve) => {
          quickPick.onDidAccept(() => {
            resolve(quickPick.selectedItems[0]);
            quickPick.dispose();
          });
          quickPick.onDidHide(() => {
            resolve(void 0);
            quickPick.dispose();
          });
          quickPick.show();
        });
        if (!picked) {
          return;
        }
        if (picked === selectExistingFileItem) {
          const picked2 = await window.showOpenDialog({
            title: l10n.t("Select move destination"),
            openLabel: l10n.t("Move to File"),
            defaultUri: Utils2.dirname(document.uri)
          });
          return (picked2 == null ? void 0 : picked2.length) ? this.client.toTsFilePath(picked2[0]) : void 0;
        } else if (picked === selectNewFileItem) {
          const picked2 = await window.showSaveDialog({
            title: l10n.t("Select move destination"),
            saveLabel: l10n.t("Move to File"),
            defaultUri: this.client.toResource(response.body.newFileName)
          });
          return picked2 ? this.client.toTsFilePath(picked2) : void 0;
        } else {
          return picked.file;
        }
      }
    };
    _MoveToFileRefactorCommand.ID = "_typescript.moveToFileRefactoring";
    MoveToFileRefactorCommand = _MoveToFileRefactorCommand;
    Extract_Function = Object.freeze({
      kind: CodeActionKind.RefactorExtract.append("function"),
      matches: (refactor) => refactor.name.startsWith("function_")
    });
    Extract_Constant = Object.freeze({
      kind: CodeActionKind.RefactorExtract.append("constant"),
      matches: (refactor) => refactor.name.startsWith("constant_")
    });
    Extract_Type = Object.freeze({
      kind: CodeActionKind.RefactorExtract.append("type"),
      matches: (refactor) => refactor.name.startsWith("Extract to type alias")
    });
    Extract_Interface = Object.freeze({
      kind: CodeActionKind.RefactorExtract.append("interface"),
      matches: (refactor) => refactor.name.startsWith("Extract to interface")
    });
    Move_File = Object.freeze({
      kind: CodeActionKind.RefactorMove.append("file"),
      matches: (refactor) => refactor.name.startsWith("Move to file")
    });
    Move_NewFile = Object.freeze({
      kind: CodeActionKind.RefactorMove.append("newFile"),
      matches: (refactor) => refactor.name.startsWith("Move to a new file")
    });
    Rewrite_Import = Object.freeze({
      kind: CodeActionKind.RefactorRewrite.append("import"),
      matches: (refactor) => refactor.name.startsWith("Convert namespace import") || refactor.name.startsWith("Convert named imports")
    });
    Rewrite_Export = Object.freeze({
      kind: CodeActionKind.RefactorRewrite.append("export"),
      matches: (refactor) => refactor.name.startsWith("Convert default export") || refactor.name.startsWith("Convert named export")
    });
    Rewrite_Arrow_Braces = Object.freeze({
      kind: CodeActionKind.RefactorRewrite.append("arrow").append("braces"),
      matches: (refactor) => refactor.name.startsWith("Convert default export") || refactor.name.startsWith("Convert named export")
    });
    Rewrite_Parameters_ToDestructured = Object.freeze({
      kind: CodeActionKind.RefactorRewrite.append("parameters").append("toDestructured"),
      matches: (refactor) => refactor.name.startsWith("Convert parameters to destructured object")
    });
    Rewrite_Property_GenerateAccessors = Object.freeze({
      kind: CodeActionKind.RefactorRewrite.append("property").append("generateAccessors"),
      matches: (refactor) => refactor.name.startsWith("Generate 'get' and 'set' accessors")
    });
    allKnownCodeActionKinds = [
      Extract_Function,
      Extract_Constant,
      Extract_Type,
      Extract_Interface,
      Move_File,
      Move_NewFile,
      Rewrite_Import,
      Rewrite_Export,
      Rewrite_Arrow_Braces,
      Rewrite_Parameters_ToDestructured,
      Rewrite_Property_GenerateAccessors
    ];
    InlinedCodeAction = class _InlinedCodeAction extends CodeAction {
      constructor(client, document, refactor, action, range, trigger) {
        const title = action.description;
        super(title, _InlinedCodeAction.getKind(action));
        this.client = client;
        this.document = document;
        this.refactor = refactor;
        this.action = action;
        this.range = range;
        if (action.notApplicableReason) {
          this.disabled = { reason: action.notApplicableReason };
        }
        this.command = {
          title,
          command: DidApplyRefactoringCommand.ID,
          arguments: [{ action: action.name, trigger }]
        };
      }
      async resolve(token) {
        const file2 = this.client.toOpenTsFilePath(this.document);
        if (!file2) {
          return;
        }
        const args = {
          ...Range4.toFileRangeRequestArgs(file2, this.range),
          refactor: this.refactor.name,
          action: this.action.name
        };
        const response = await this.client.execute("getEditsForRefactor", args, token);
        if (response.type !== "response" || !response.body) {
          return;
        }
        this.edit = toWorkspaceEdit(this.client, response.body.edits);
        if (!this.edit.size) {
          window.showErrorMessage(l10n.t("Could not apply refactoring"));
          return;
        }
        if (response.body.renameLocation) {
          if (this.document.uri.scheme !== walkThroughSnippet) {
            this.command = {
              title: "",
              command: "editor.action.rename",
              arguments: commandsConverter["editor.action.rename"].toArgs(...[[
                this.document.uri,
                Position3.fromLocation(response.body.renameLocation)
              ]])
            };
          }
        }
      }
      static getKind(refactor) {
        if (refactor.kind) {
          return CodeActionKind.Empty.append(refactor.kind);
        }
        const match = allKnownCodeActionKinds.find((kind) => kind.matches(refactor));
        return match ? match.kind : CodeActionKind.Refactor;
      }
    };
    MoveToFileCodeAction = class extends CodeAction {
      constructor(document, action, range, trigger) {
        super(action.description, Move_File.kind);
        if (action.notApplicableReason) {
          this.disabled = { reason: action.notApplicableReason };
        }
        this.command = {
          title: action.description,
          command: MoveToFileRefactorCommand.ID,
          arguments: commandsConverter[MoveToFileRefactorCommand.ID].toArgs(...[{ action, document, range, trigger }])
        };
      }
    };
    SelectCodeAction = class extends CodeAction {
      constructor(info, document, rangeOrSelection, trigger) {
        super(info.description, CodeActionKind.Refactor);
        this.command = {
          title: info.description,
          command: SelectRefactorCommand.ID,
          arguments: commandsConverter[SelectRefactorCommand.ID].toArgs(...[{ action: this, document, refactor: info, rangeOrSelection, trigger }])
        };
      }
    };
    _TypeScriptRefactorProvider = class _TypeScriptRefactorProvider {
      constructor(client, cachedNavTree, formattingOptionsManager, commandManager, telemetryReporter) {
        this.client = client;
        this.cachedNavTree = cachedNavTree;
        this.formattingOptionsManager = formattingOptionsManager;
        const didApplyRefactoringCommand = new DidApplyRefactoringCommand(telemetryReporter);
        commandManager.register(didApplyRefactoringCommand);
        commandManager.register(new CompositeCommand());
        commandManager.register(new SelectRefactorCommand(this.client));
        commandManager.register(new MoveToFileRefactorCommand(this.client, didApplyRefactoringCommand));
        commandManager.register(new EditorChatFollowUp(this.client, telemetryReporter));
      }
      static isOnSignatureName(node, range) {
        var _a;
        if (this._declarationKinds.has(node.kind)) {
          if (node.nameSpan) {
            const convertedSpan = Range4.fromTextSpan(node.nameSpan);
            if (range.intersection(convertedSpan)) {
              return true;
            }
          }
          if (!node.nameSpan && /\bexport\b/.test(node.kindModifiers) && node.spans.length) {
            const convertedSpan = Range4.fromTextSpan(node.spans[0]);
            if (range.intersection(new Range(convertedSpan.start.line, 0, convertedSpan.start.line, Number.MAX_SAFE_INTEGER))) {
              return true;
            }
          }
        }
        return ((_a = node.childItems) == null ? void 0 : _a.some((child) => this.isOnSignatureName(child, range))) ?? false;
      }
      async provideCodeActions(document, rangeOrSelection, context, token) {
        if (!this.shouldTrigger(context, rangeOrSelection)) {
          return void 0;
        }
        if (!this.client.toOpenTsFilePath(document)) {
          return void 0;
        }
        const response = await this.interruptGetErrIfNeeded(context, () => {
          var _a;
          const file2 = this.client.toOpenTsFilePath(document);
          if (!file2) {
            return void 0;
          }
          this.formattingOptionsManager.ensureConfigurationForDocument(document, token);
          const args = {
            ...Range4.toFileRangeRequestArgs(file2, rangeOrSelection),
            triggerReason: this.toTsTriggerReason(context),
            kind: (_a = context.only) == null ? void 0 : _a.value,
            includeInteractiveActions: this.client.apiVersion.gte(API.v520)
          };
          return this.client.execute("getApplicableRefactors", args, token);
        });
        if ((response == null ? void 0 : response.type) !== "response" || !response.body) {
          return void 0;
        }
        const applicableRefactors = this.convertApplicableRefactors(document, context, response.body, rangeOrSelection);
        const actions = coalesce(await Promise.all(Array.from(applicableRefactors, async (action) => {
          var _a, _b, _c;
          if (this.client.apiVersion.lt(API.v430)) {
            if (!context.only && ((_a = action.kind) == null ? void 0 : _a.value) === "refactor.rewrite.function.returnType") {
              return void 0;
            }
          }
          if (this.client.apiVersion.lt(API.v540) && context.triggerKind === 2 /* Automatic */) {
            if (((_b = action.kind) == null ? void 0 : _b.value) === Move_NewFile.kind.value || ((_c = action.kind) == null ? void 0 : _c.value) === Move_File.kind.value) {
              const file2 = this.client.toOpenTsFilePath(document);
              if (!file2) {
                return void 0;
              }
              const navTree = await this.cachedNavTree.execute(document, () => this.client.execute("navtree", { file: file2 }, token));
              if (navTree.type !== "response" || !navTree.body || !_TypeScriptRefactorProvider.isOnSignatureName(navTree.body, rangeOrSelection)) {
                return void 0;
              }
            }
          }
          return action;
        })));
        if (!context.only) {
          return actions;
        }
        return this.pruneInvalidActions(
          this.appendInvalidActions(actions),
          context.only,
          /* numberOfInvalid = */
          5
        );
      }
      interruptGetErrIfNeeded(context, f) {
        if (context.triggerKind === 1 /* Invoke */) {
          return this.client.interruptGetErr(f);
        } else {
          return f();
        }
      }
      async resolveCodeAction(codeAction, token) {
        if (codeAction instanceof InlinedCodeAction) {
          await codeAction.resolve(token);
        }
        return codeAction;
      }
      toTsTriggerReason(context) {
        return context.triggerKind === 1 /* Invoke */ ? "invoked" : "implicit";
      }
      *convertApplicableRefactors(document, context, refactors, rangeOrSelection) {
        for (const refactor of refactors) {
          if (refactor.inlineable === false) {
            yield new SelectCodeAction(refactor, document, rangeOrSelection, context.triggerKind);
          } else {
            for (const action of refactor.actions) {
              for (const codeAction of this.refactorActionToCodeActions(document, context, refactor, action, rangeOrSelection, refactor.actions)) {
                yield codeAction;
              }
            }
          }
        }
      }
      refactorActionToCodeActions(document, context, refactor, action, rangeOrSelection, allActions) {
        const codeActions = [];
        if (action.name === "Move to file") {
          codeActions.push(new MoveToFileCodeAction(document, action, rangeOrSelection, context.triggerKind));
        } else {
          codeActions.push(new InlinedCodeAction(this.client, document, refactor, action, rangeOrSelection, context.triggerKind));
        }
        for (const codeAction of codeActions) {
          codeAction.isPreferred = _TypeScriptRefactorProvider.isPreferred(action, allActions);
        }
        return codeActions;
      }
      shouldTrigger(context, rangeOrSelection) {
        if (context.only && !CodeActionKind.Refactor.contains(context.only)) {
          return false;
        }
        if (context.triggerKind === 1 /* Invoke */) {
          return true;
        }
        return rangeOrSelection instanceof Selection;
      }
      static isPreferred(action, allActions) {
        if (Extract_Constant.matches(action)) {
          const getScope = (name) => {
            var _a;
            const scope2 = (_a = name.match(/scope_(\d)/)) == null ? void 0 : _a[1];
            return scope2 ? +scope2 : void 0;
          };
          const scope = getScope(action.name);
          if (typeof scope !== "number") {
            return false;
          }
          return allActions.filter((otherAtion) => otherAtion !== action && Extract_Constant.matches(otherAtion)).every((otherAction) => {
            const otherScope = getScope(otherAction.name);
            return typeof otherScope === "number" ? scope < otherScope : true;
          });
        }
        if (Extract_Type.matches(action) || Extract_Interface.matches(action)) {
          return true;
        }
        return false;
      }
      appendInvalidActions(actions) {
        if (this.client.apiVersion.gte(API.v400)) {
          return actions;
        }
        if (!actions.some((action) => action.kind && Extract_Constant.kind.contains(action.kind))) {
          const disabledAction = new CodeAction(
            l10n.t("Extract to constant"),
            Extract_Constant.kind
          );
          disabledAction.disabled = {
            reason: l10n.t("The current selection cannot be extracted")
          };
          disabledAction.isPreferred = true;
          actions.push(disabledAction);
        }
        if (!actions.some((action) => action.kind && Extract_Function.kind.contains(action.kind))) {
          const disabledAction = new CodeAction(
            l10n.t("Extract to function"),
            Extract_Function.kind
          );
          disabledAction.disabled = {
            reason: l10n.t("The current selection cannot be extracted")
          };
          actions.push(disabledAction);
        }
        return actions;
      }
      pruneInvalidActions(actions, only, numberOfInvalid) {
        if (this.client.apiVersion.lt(API.v400)) {
          return actions;
        }
        const availableActions = [];
        const invalidCommonActions = [];
        const invalidUncommonActions = [];
        for (const action of actions) {
          if (!action.disabled) {
            availableActions.push(action);
            continue;
          }
          if (action.kind && (Extract_Constant.kind.contains(action.kind) || Extract_Function.kind.contains(action.kind))) {
            invalidCommonActions.push(action);
            continue;
          }
          invalidUncommonActions.push(action);
        }
        const prioritizedActions = [];
        prioritizedActions.push(...invalidCommonActions);
        prioritizedActions.push(...invalidUncommonActions);
        const topNInvalid = prioritizedActions.filter((action) => !only || action.kind && only.contains(action.kind)).slice(0, numberOfInvalid);
        availableActions.push(...topNInvalid);
        return availableActions;
      }
    };
    _TypeScriptRefactorProvider._declarationKinds = /* @__PURE__ */ new Set([
      Kind.module,
      Kind.class,
      Kind.interface,
      Kind.function,
      Kind.enum,
      Kind.type,
      Kind.const,
      Kind.variable,
      Kind.let
    ]);
    _TypeScriptRefactorProvider.metadata = {
      providedCodeActionKinds: [
        CodeActionKind.Refactor,
        ...allKnownCodeActionKinds.map((x) => x.kind)
      ],
      documentation: [
        {
          kind: CodeActionKind.Refactor,
          command: {
            command: LearnMoreAboutRefactoringsCommand.id,
            title: l10n.t("Learn more about JS/TS refactorings")
          }
        }
      ]
    };
    TypeScriptRefactorProvider = _TypeScriptRefactorProvider;
  }
});

// src/typescript-language-features/src/languageFeatures/references.ts
var references_exports = {};
__export(references_exports, {
  register: () => register23
});
function register23(selector, client) {
  return conditionalRegistration([
    requireSomeCapability(client, 1 /* EnhancedSyntax */, 2 /* Semantic */)
  ], () => {
    return languages.registerReferenceProvider(
      selector.syntax,
      new TypeScriptReferenceSupport(client)
    );
  });
}
var TypeScriptReferenceSupport;
var init_references = __esm({
  "src/typescript-language-features/src/languageFeatures/references.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    TypeScriptReferenceSupport = class {
      constructor(client) {
        this.client = client;
      }
      async provideReferences(document, position, options, token) {
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return [];
        }
        const args = Position3.toFileLocationRequestArgs(filepath, position);
        const response = await this.client.execute("references", args, token);
        if (response.type !== "response" || !response.body) {
          return [];
        }
        const result = [];
        for (const ref of response.body.refs) {
          if (!options.includeDeclaration && ref.isDefinition) {
            continue;
          }
          const url = this.client.toResource(ref.file);
          const location = Location2.fromTextSpan(url, ref);
          result.push(location);
        }
        return result;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/rename.ts
var rename_exports = {};
__export(rename_exports, {
  register: () => register24
});
import * as path6 from "path";
function register24(selector, language, client, fileConfigurationManager) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return languages.registerRenameProvider(
      selector.semantic,
      new TypeScriptRenameProvider(language, client, fileConfigurationManager)
    );
  });
}
var TypeScriptRenameProvider;
var init_rename = __esm({
  "src/typescript-language-features/src/languageFeatures/rename.ts"() {
    "use strict";
    init_shims();
    init_languageIds();
    init_api2();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    TypeScriptRenameProvider = class {
      constructor(language, client, fileConfigurationManager) {
        this.language = language;
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
      }
      async prepareRename(document, position, token) {
        const response = await this.execRename(document, position, token);
        if (!response) {
          return void 0;
        }
        switch (response.type) {
          case "rename": {
            const renameInfo = response.body.info;
            if (!renameInfo.canRename) {
              return Promise.reject(renameInfo.localizedErrorMessage);
            }
            return Range4.fromTextSpan(renameInfo.triggerSpan);
          }
          case "jsxLinkedEditing": {
            return response.spans.map(Range4.fromTextSpan).find((range) => range.contains(position));
          }
        }
      }
      async provideRenameEdits(document, position, newName, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        const response = await this.execRename(document, position, token);
        if (!response || token.isCancellationRequested) {
          return void 0;
        }
        switch (response.type) {
          case "rename": {
            const renameInfo = response.body.info;
            if (!renameInfo.canRename) {
              return Promise.reject(renameInfo.localizedErrorMessage);
            }
            if (renameInfo.fileToRename) {
              const edits = await this.renameFile(renameInfo.fileToRename, renameInfo.fullDisplayName, newName, token);
              if (edits) {
                return edits;
              } else {
                return Promise.reject(l10n.t("An error occurred while renaming file"));
              }
            }
            return this.updateLocs(response.body.locs, newName);
          }
          case "jsxLinkedEditing": {
            return this.updateLocs([{
              file: file2,
              locs: response.spans.map((span) => ({ ...span }))
            }], newName);
          }
        }
      }
      async execRename(document, position, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        if (this.client.apiVersion.gte(API.v510) && workspace.getConfiguration(this.language.id).get("preferences.renameMatchingJsxTags", true) && this.looksLikePotentialJsxTagContext(document, position)) {
          const args2 = Position3.toFileLocationRequestArgs(file2, position);
          const response = await this.client.execute("linkedEditingRange", args2, token);
          if (response.type !== "response" || !response.body) {
            return void 0;
          }
          return { type: "jsxLinkedEditing", spans: response.body.ranges };
        }
        const args = {
          ...Position3.toFileLocationRequestArgs(file2, position),
          findInStrings: false,
          findInComments: false
        };
        return this.client.interruptGetErr(async () => {
          this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
          const response = await this.client.execute("rename", args, token);
          if (response.type !== "response" || !response.body) {
            return void 0;
          }
          return { type: "rename", body: response.body };
        });
      }
      looksLikePotentialJsxTagContext(document, position) {
        if (![typescriptreact, javascript, javascriptreact].includes(document.languageId)) {
          return false;
        }
        const prefix = document.getText(new Range(position.line, 0, position.line, position.character));
        return /\<\/?\s*[\w\d_$.]*$/.test(prefix);
      }
      updateLocs(locations, newName) {
        const edit = new WorkspaceEdit();
        for (const spanGroup of locations) {
          const resource = this.client.toResource(spanGroup.file);
          for (const textSpan of spanGroup.locs) {
            edit.replace(
              resource,
              Range4.fromTextSpan(textSpan),
              (textSpan.prefixText || "") + newName + (textSpan.suffixText || "")
            );
          }
        }
        return edit;
      }
      async renameFile(fileToRename, fullDisplayName, newName, token) {
        if (!path6.extname(newName)) {
          newName += path6.extname(fileToRename);
        } else if (path6.extname(newName) === path6.extname(fullDisplayName)) {
          newName = newName.slice(0, newName.length - path6.extname(newName).length) + path6.extname(fileToRename);
        }
        const dirname5 = path6.dirname(fileToRename);
        const newFilePath = path6.join(dirname5, newName);
        const args = {
          file: fileToRename,
          oldFilePath: fileToRename,
          newFilePath
        };
        const response = await this.client.execute("getEditsForFileRename", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        const edits = WorkspaceEdit2.fromFileCodeEdits(this.client, response.body);
        edits.renameFile(Uri.file(fileToRename), Uri.file(newFilePath));
        return edits;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/semanticTokens.ts
var semanticTokens_exports = {};
__export(semanticTokens_exports, {
  register: () => register25
});
function register25(selector, client) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    const provider = new DocumentSemanticTokensProvider(client);
    return Disposable4.from(
      languages.registerDocumentRangeSemanticTokensProvider(selector.semantic, provider, provider.getLegend()),
      languages.registerDocumentSemanticTokensProvider(selector.semantic, provider, provider.getLegend())
    );
  });
}
function waitForDocumentChangesToEnd(document) {
  let version = document.version;
  return new Promise((resolve) => {
    const iv = setInterval((_) => {
      if (document.version === version) {
        clearInterval(iv);
        resolve();
      }
      version = document.version;
    }, 400);
  });
}
function getTokenTypeFromClassification(tsClassification) {
  if (tsClassification > 255 /* modifierMask */) {
    return (tsClassification >> 8 /* typeOffset */) - 1;
  }
  return void 0;
}
function getTokenModifierFromClassification(tsClassification) {
  return tsClassification & 255 /* modifierMask */;
}
var CONTENT_LENGTH_LIMIT, DocumentSemanticTokensProvider, tokenTypes, tokenModifiers;
var init_semanticTokens = __esm({
  "src/typescript-language-features/src/languageFeatures/semanticTokens.ts"() {
    "use strict";
    init_shims();
    init_typescriptService();
    init_dependentRegistration();
    CONTENT_LENGTH_LIMIT = 1e5;
    DocumentSemanticTokensProvider = class {
      constructor(client) {
        this.client = client;
      }
      getLegend() {
        return new SemanticTokensLegend(tokenTypes, tokenModifiers);
      }
      async provideDocumentSemanticTokens(document, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2 || document.getText().length > CONTENT_LENGTH_LIMIT) {
          return null;
        }
        return this.provideSemanticTokens(document, { file: file2, start: 0, length: document.getText().length }, token);
      }
      async provideDocumentRangeSemanticTokens(document, range, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2 || document.offsetAt(range.end) - document.offsetAt(range.start) > CONTENT_LENGTH_LIMIT) {
          return null;
        }
        const start = document.offsetAt(range.start);
        const length = document.offsetAt(range.end) - start;
        return this.provideSemanticTokens(document, { file: file2, start, length }, token);
      }
      async provideSemanticTokens(document, requestArg, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return null;
        }
        const versionBeforeRequest = document.version;
        const response = await this.client.execute("encodedSemanticClassifications-full", { ...requestArg, format: "2020" }, token, {
          cancelOnResourceChange: document.uri
        });
        if (response.type !== "response" || !response.body) {
          return null;
        }
        const versionAfterRequest = document.version;
        if (versionBeforeRequest !== versionAfterRequest) {
          await waitForDocumentChangesToEnd(document);
          throw new CancellationError();
        }
        const tokenSpan = response.body.spans;
        const builder = new SemanticTokensBuilder();
        for (let i = 0; i < tokenSpan.length; ) {
          const offset = tokenSpan[i++];
          const length = tokenSpan[i++];
          const tsClassification = tokenSpan[i++];
          const tokenType = getTokenTypeFromClassification(tsClassification);
          if (tokenType === void 0) {
            continue;
          }
          const tokenModifiers2 = getTokenModifierFromClassification(tsClassification);
          const startPos = document.positionAt(offset);
          const endPos = document.positionAt(offset + length);
          for (let line = startPos.line; line <= endPos.line; line++) {
            const startCharacter = line === startPos.line ? startPos.character : 0;
            const endCharacter = line === endPos.line ? endPos.character : document.lineAt(line).text.length;
            builder.push(line, startCharacter, endCharacter - startCharacter, tokenType, tokenModifiers2);
          }
        }
        return builder.build();
      }
    };
    tokenTypes = [];
    tokenTypes[0 /* class */] = "class";
    tokenTypes[1 /* enum */] = "enum";
    tokenTypes[2 /* interface */] = "interface";
    tokenTypes[3 /* namespace */] = "namespace";
    tokenTypes[4 /* typeParameter */] = "typeParameter";
    tokenTypes[5 /* type */] = "type";
    tokenTypes[6 /* parameter */] = "parameter";
    tokenTypes[7 /* variable */] = "variable";
    tokenTypes[8 /* enumMember */] = "enumMember";
    tokenTypes[9 /* property */] = "property";
    tokenTypes[10 /* function */] = "function";
    tokenTypes[11 /* method */] = "method";
    tokenModifiers = [];
    tokenModifiers[2 /* async */] = "async";
    tokenModifiers[0 /* declaration */] = "declaration";
    tokenModifiers[3 /* readonly */] = "readonly";
    tokenModifiers[1 /* static */] = "static";
    tokenModifiers[5 /* local */] = "local";
    tokenModifiers[4 /* defaultLibrary */] = "defaultLibrary";
  }
});

// src/typescript-language-features/src/languageFeatures/signatureHelp.ts
var signatureHelp_exports = {};
__export(signatureHelp_exports, {
  register: () => register26
});
function toTsTriggerReason(context) {
  switch (context.triggerKind) {
    case 2 /* TriggerCharacter */:
      if (context.triggerCharacter) {
        if (context.isRetrigger) {
          return { kind: "retrigger", triggerCharacter: context.triggerCharacter };
        } else {
          return { kind: "characterTyped", triggerCharacter: context.triggerCharacter };
        }
      } else {
        return { kind: "invoked" };
      }
    case 3 /* ContentChange */:
      return context.isRetrigger ? { kind: "retrigger" } : { kind: "invoked" };
    case 1 /* Invoke */:
    default:
      return { kind: "invoked" };
  }
}
function register26(selector, client) {
  return conditionalRegistration([
    requireSomeCapability(client, 1 /* EnhancedSyntax */, 2 /* Semantic */)
  ], () => {
    return languages.registerSignatureHelpProvider(
      selector.syntax,
      new TypeScriptSignatureHelpProvider(client),
      {
        triggerCharacters: TypeScriptSignatureHelpProvider.triggerCharacters,
        retriggerCharacters: TypeScriptSignatureHelpProvider.retriggerCharacters
      }
    );
  });
}
var TypeScriptSignatureHelpProvider;
var init_signatureHelp = __esm({
  "src/typescript-language-features/src/languageFeatures/signatureHelp.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    init_typescriptService();
    init_dependentRegistration();
    init_textRendering();
    TypeScriptSignatureHelpProvider = class {
      constructor(client) {
        this.client = client;
      }
      async provideSignatureHelp(document, position, token, context) {
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return void 0;
        }
        const args = {
          ...Position3.toFileLocationRequestArgs(filepath, position),
          triggerReason: toTsTriggerReason(context)
        };
        const response = await this.client.interruptGetErr(() => this.client.execute("signatureHelp", args, token));
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        const info = response.body;
        const result = new SignatureHelp();
        result.signatures = info.items.map((signature) => this.convertSignature(signature, document.uri));
        result.activeSignature = this.getActiveSignature(context, info, result.signatures);
        result.activeParameter = this.getActiveParameter(info);
        return result;
      }
      getActiveSignature(context, info, signatures) {
        var _a;
        const previouslyActiveSignature = (_a = context.activeSignatureHelp) == null ? void 0 : _a.signatures[context.activeSignatureHelp.activeSignature];
        if (previouslyActiveSignature && context.isRetrigger) {
          const existingIndex = signatures.findIndex((other) => other.label === (previouslyActiveSignature == null ? void 0 : previouslyActiveSignature.label));
          if (existingIndex >= 0) {
            return existingIndex;
          }
        }
        return info.selectedItemIndex;
      }
      getActiveParameter(info) {
        const activeSignature = info.items[info.selectedItemIndex];
        if (activeSignature == null ? void 0 : activeSignature.isVariadic) {
          return Math.min(info.argumentIndex, activeSignature.parameters.length - 1);
        }
        return info.argumentIndex;
      }
      convertSignature(item, baseUri) {
        const signature = new SignatureInformation(
          asPlainTextWithLinks(item.prefixDisplayParts, this.client),
          documentationToMarkdown(item.documentation, item.tags.filter((x) => x.name !== "param"), this.client, baseUri)
        );
        let textIndex = signature.label.length;
        const separatorLabel = asPlainTextWithLinks(item.separatorDisplayParts, this.client);
        for (let i = 0; i < item.parameters.length; ++i) {
          const parameter = item.parameters[i];
          const label = asPlainTextWithLinks(parameter.displayParts, this.client);
          signature.parameters.push(
            new ParameterInformation(
              [textIndex, textIndex + label.length],
              documentationToMarkdown(parameter.documentation, [], this.client, baseUri)
            )
          );
          textIndex += label.length;
          signature.label += label;
          if (i !== item.parameters.length - 1) {
            signature.label += separatorLabel;
            textIndex += separatorLabel.length;
          }
        }
        signature.label += asPlainTextWithLinks(item.suffixDisplayParts, this.client);
        return signature;
      }
    };
    TypeScriptSignatureHelpProvider.triggerCharacters = ["(", ",", "<"];
    TypeScriptSignatureHelpProvider.retriggerCharacters = [")"];
  }
});

// src/typescript-language-features/src/languageFeatures/smartSelect.ts
var smartSelect_exports = {};
__export(smartSelect_exports, {
  register: () => register27
});
function register27(selector, client) {
  return languages.registerSelectionRangeProvider(selector.syntax, new SmartSelection(client));
}
var SmartSelection;
var init_smartSelect = __esm({
  "src/typescript-language-features/src/languageFeatures/smartSelect.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    SmartSelection = class _SmartSelection {
      constructor(client) {
        this.client = client;
      }
      async provideSelectionRanges(document, positions, token) {
        const file2 = this.client.toOpenTsFilePath(document);
        if (!file2) {
          return void 0;
        }
        const args = {
          file: file2,
          locations: positions.map(Position3.toLocation)
        };
        const response = await this.client.execute("selectionRange", args, token);
        if (response.type !== "response" || !response.body) {
          return void 0;
        }
        return response.body.map(_SmartSelection.convertSelectionRange);
      }
      static convertSelectionRange(selectionRange) {
        return new SelectionRange(
          Range4.fromTextSpan(selectionRange.textSpan),
          selectionRange.parent ? _SmartSelection.convertSelectionRange(selectionRange.parent) : void 0
        );
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/sourceDefinition.ts
var sourceDefinition_exports = {};
__export(sourceDefinition_exports, {
  register: () => register28
});
function register28(client, commandManager) {
  function updateContext() {
    commands.executeCommand("setContext", SourceDefinitionCommand.context, client.apiVersion.gte(SourceDefinitionCommand.minVersion));
  }
  updateContext();
  commandManager.register(new SourceDefinitionCommand(client));
  return client.onTsServerStarted(() => updateContext());
}
var _SourceDefinitionCommand, SourceDefinitionCommand;
var init_sourceDefinition = __esm({
  "src/typescript-language-features/src/languageFeatures/sourceDefinition.ts"() {
    "use strict";
    init_shims();
    init_api2();
    init_typeConverters();
    _SourceDefinitionCommand = class _SourceDefinitionCommand {
      constructor(client) {
        this.client = client;
        this.id = "typescript.goToSourceDefinition";
      }
      async execute(document, position) {
        if (this.client.apiVersion.lt(_SourceDefinitionCommand.minVersion)) {
          window.showErrorMessage(l10n.t("Go to Source Definition failed. Requires TypeScript 4.7+."));
          return;
        }
        const resource = document.uri;
        const openedFiledPath = this.client.toOpenTsFilePath(document);
        if (!openedFiledPath) {
          window.showErrorMessage(l10n.t("Go to Source Definition failed. Unknown file type."));
          return;
        }
        return await window.withProgress({
          location: 10 /* Window */,
          title: l10n.t("Finding source definitions")
        }, async (_progress, token) => {
          const args = Position3.toFileLocationRequestArgs(openedFiledPath, position);
          const response = await this.client.execute("findSourceDefinition", args, token);
          if (response.type === "response" && response.body) {
            const locations = response.body.map((reference) => Location2.fromTextSpan(this.client.toResource(reference.file), reference));
            return locations;
            if (locations.length) {
              if (locations.length === 1) {
                commands.executeCommand("vscode.open", locations[0].uri.with({
                  fragment: `L${locations[0].range.start.line + 1},${locations[0].range.start.character + 1}`
                }));
              } else {
                commands.executeCommand("editor.action.showReferences", resource, position, locations);
              }
              return;
            }
          }
          window.showErrorMessage(l10n.t("No source definitions found."));
        });
      }
    };
    _SourceDefinitionCommand.context = "tsSupportsSourceDefinition";
    _SourceDefinitionCommand.minVersion = API.v470;
    SourceDefinitionCommand = _SourceDefinitionCommand;
  }
});

// src/typescript-language-features/src/languageFeatures/tagClosing.ts
var tagClosing_exports = {};
__export(tagClosing_exports, {
  register: () => register29
});
function requireActiveDocumentSetting(selector, language) {
  return new Condition(
    () => {
      const editor = window.activeTextEditor;
      if (!editor || !languages.match(selector, editor.document)) {
        return false;
      }
      return !!workspace.getConfiguration(language.id, editor.document).get("autoClosingTags");
    },
    (handler) => {
      return Disposable4.from(
        window.onDidChangeActiveTextEditor(handler),
        workspace.onDidOpenTextDocument(handler),
        workspace.onDidChangeConfiguration(handler)
      );
    }
  );
}
function register29(selector, language, client) {
  return conditionalRegistration([
    requireActiveDocumentSetting(selector.syntax, language)
  ], () => new TagClosing(client));
}
var TagClosing;
var init_tagClosing = __esm({
  "src/typescript-language-features/src/languageFeatures/tagClosing.ts"() {
    "use strict";
    init_shims();
    init_typeConverters();
    init_dispose();
    init_dependentRegistration();
    TagClosing = class extends Disposable {
      constructor(client) {
        super();
        this.client = client;
        this._disposed = false;
        this._timeout = void 0;
        this._cancel = void 0;
        workspace.onDidChangeTextDocument(
          (event) => this.onDidChangeTextDocument(event),
          null,
          this._disposables
        );
      }
      dispose() {
        super.dispose();
        this._disposed = true;
        if (this._timeout) {
          clearTimeout(this._timeout);
          this._timeout = void 0;
        }
        if (this._cancel) {
          this._cancel.cancel();
          this._cancel.dispose();
          this._cancel = void 0;
        }
      }
      onDidChangeTextDocument({ document, contentChanges, reason }) {
        var _a;
        if (contentChanges.length === 0 || reason === 1 /* Undo */ || reason === 2 /* Redo */) {
          return;
        }
        const activeDocument = (_a = window.activeTextEditor) == null ? void 0 : _a.document;
        if (document !== activeDocument) {
          return;
        }
        const filepath = this.client.toOpenTsFilePath(document);
        if (!filepath) {
          return;
        }
        if (typeof this._timeout !== "undefined") {
          clearTimeout(this._timeout);
        }
        if (this._cancel) {
          this._cancel.cancel();
          this._cancel.dispose();
          this._cancel = void 0;
        }
        const lastChange = contentChanges[contentChanges.length - 1];
        const lastCharacter = lastChange.text[lastChange.text.length - 1];
        if (lastChange.rangeLength > 0 || lastCharacter !== ">" && lastCharacter !== "/") {
          return;
        }
        const priorCharacter = lastChange.range.start.character > 0 ? document.getText(new Range(lastChange.range.start.translate({ characterDelta: -1 }), lastChange.range.start)) : "";
        if (priorCharacter === ">") {
          return;
        }
        const version = document.version;
        this._timeout = setTimeout(async () => {
          this._timeout = void 0;
          if (this._disposed) {
            return;
          }
          const addedLines = lastChange.text.split(/\r\n|\n/g);
          const position = addedLines.length <= 1 ? lastChange.range.start.translate({ characterDelta: lastChange.text.length }) : new Position(lastChange.range.start.line + addedLines.length - 1, addedLines[addedLines.length - 1].length);
          const args = Position3.toFileLocationRequestArgs(filepath, position);
          this._cancel = new CancellationTokenSource();
          const response = await this.client.execute("jsxClosingTag", args, this._cancel.token);
          if (response.type !== "response" || !response.body) {
            return;
          }
          if (this._disposed) {
            return;
          }
          const activeEditor = window.activeTextEditor;
          if (!activeEditor) {
            return;
          }
          const insertion = response.body;
          const activeDocument2 = activeEditor.document;
          if (document === activeDocument2 && activeDocument2.version === version) {
            activeEditor.insertSnippet(
              this.getTagSnippet(insertion),
              this.getInsertionPositions(activeEditor, position)
            );
          }
        }, 100);
      }
      getTagSnippet(closingTag) {
        const snippet = new SnippetString();
        snippet.appendPlaceholder("", 0);
        snippet.appendText(closingTag.newText);
        return snippet;
      }
      getInsertionPositions(editor, position) {
        const activeSelectionPositions = editor.selections.map((s) => s.active);
        return activeSelectionPositions.some((p) => p.isEqual(position)) ? activeSelectionPositions : position;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/typeDefinitions.ts
var typeDefinitions_exports = {};
__export(typeDefinitions_exports, {
  default: () => TypeScriptTypeDefinitionProvider,
  register: () => register30
});
function register30(selector, client) {
  return conditionalRegistration([
    requireSomeCapability(client, 1 /* EnhancedSyntax */, 2 /* Semantic */)
  ], () => {
    return languages.registerTypeDefinitionProvider(
      selector.syntax,
      new TypeScriptTypeDefinitionProvider(client)
    );
  });
}
var TypeScriptTypeDefinitionProvider;
var init_typeDefinitions = __esm({
  "src/typescript-language-features/src/languageFeatures/typeDefinitions.ts"() {
    "use strict";
    init_shims();
    init_typescriptService();
    init_definitionProviderBase();
    init_dependentRegistration();
    TypeScriptTypeDefinitionProvider = class extends TypeScriptDefinitionProviderBase {
      provideTypeDefinition(document, position, token) {
        return this.getSymbolLocations("typeDefinition", document, position, token);
      }
    };
  }
});

// src/typescript-language-features/src/languageProvider.ts
import { basename as basename3, extname as extname2 } from "path";
var validateSetting, suggestionSetting, LanguageProvider;
var init_languageProvider = __esm({
  "src/typescript-language-features/src/languageProvider.ts"() {
    "use strict";
    init_shims();
    init_fileSchemes();
    init_schemes();
    init_diagnostics2();
    init_cachedResponse();
    init_typescriptService();
    init_dispose();
    init_platform();
    validateSetting = "validate.enable";
    suggestionSetting = "suggestionActions.enabled";
    LanguageProvider = class extends Disposable {
      constructor(client, description2, commandManager, telemetryReporter, typingsStatus, fileConfigurationManager, onCompletionAccepted) {
        super();
        this.client = client;
        this.description = description2;
        this.commandManager = commandManager;
        this.telemetryReporter = telemetryReporter;
        this.typingsStatus = typingsStatus;
        this.fileConfigurationManager = fileConfigurationManager;
        this.onCompletionAccepted = onCompletionAccepted;
        workspace.onDidChangeConfiguration(this.configurationChanged, this, this._disposables);
        this.configurationChanged();
        client.onReady(() => this.registerProviders());
      }
      get documentSelector() {
        const semantic = [];
        const syntax = [];
        for (const language of this.description.languageIds) {
          syntax.push({ language });
          for (const scheme of getSemanticSupportedSchemes()) {
            semantic.push({ language, scheme });
          }
        }
        return { semantic, syntax };
      }
      async registerProviders() {
        const selector = this.documentSelector;
        const cachedNavTreeResponse = new CachedResponse();
        await Promise.all([
          Promise.resolve().then(() => (init_callHierarchy(), callHierarchy_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_implementationsCodeLens(), implementationsCodeLens_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, cachedNavTreeResponse))),
          Promise.resolve().then(() => (init_referencesCodeLens(), referencesCodeLens_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, cachedNavTreeResponse))),
          Promise.resolve().then(() => (init_completions(), completions_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, this.typingsStatus, this.fileConfigurationManager, this.commandManager, this.telemetryReporter, this.onCompletionAccepted))),
          Promise.resolve().then(() => (init_copyPaste(), copyPaste_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, this.fileConfigurationManager))),
          Promise.resolve().then(() => (init_definitions(), definitions_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_directiveCommentCompletions(), directiveCommentCompletions_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_documentHighlight(), documentHighlight_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_documentSymbol(), documentSymbol_exports)).then((provider) => this._register(provider.register(selector, this.client, cachedNavTreeResponse))),
          Promise.resolve().then(() => (init_fileReferences(), fileReferences_exports)).then((provider) => this._register(provider.register(this.client, this.commandManager))),
          Promise.resolve().then(() => (init_fixAll(), fixAll_exports)).then((provider) => this._register(provider.register(selector, this.client, this.fileConfigurationManager, this.client.diagnosticsManager))),
          Promise.resolve().then(() => (init_folding(), folding_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_formatting(), formatting_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, this.fileConfigurationManager))),
          Promise.resolve().then(() => (init_hover(), hover_exports)).then((provider) => this._register(provider.register(selector, this.client, this.fileConfigurationManager))),
          Promise.resolve().then(() => (init_implementations(), implementations_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_inlayHints(), inlayHints_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, this.fileConfigurationManager, this.telemetryReporter))),
          Promise.resolve().then(() => (init_jsDocCompletions(), jsDocCompletions_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, this.fileConfigurationManager))),
          Promise.resolve().then(() => (init_linkedEditing(), linkedEditing_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_mappedCodeEditProvider(), mappedCodeEditProvider_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_organizeImports(), organizeImports_exports)).then((provider) => this._register(provider.register(selector, this.client, this.commandManager, this.fileConfigurationManager, this.telemetryReporter))),
          Promise.resolve().then(() => (init_quickFix(), quickFix_exports)).then((provider) => this._register(provider.register(selector, this.client, this.fileConfigurationManager, this.commandManager, this.client.diagnosticsManager, this.telemetryReporter))),
          Promise.resolve().then(() => (init_refactor(), refactor_exports)).then((provider) => this._register(provider.register(selector, this.client, cachedNavTreeResponse, this.fileConfigurationManager, this.commandManager, this.telemetryReporter))),
          Promise.resolve().then(() => (init_references(), references_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_rename(), rename_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client, this.fileConfigurationManager))),
          Promise.resolve().then(() => (init_semanticTokens(), semanticTokens_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_signatureHelp(), signatureHelp_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_smartSelect(), smartSelect_exports)).then((provider) => this._register(provider.register(selector, this.client))),
          Promise.resolve().then(() => (init_sourceDefinition(), sourceDefinition_exports)).then((provider) => this._register(provider.register(this.client, this.commandManager))),
          Promise.resolve().then(() => (init_tagClosing(), tagClosing_exports)).then((provider) => this._register(provider.register(selector, this.description, this.client))),
          Promise.resolve().then(() => (init_typeDefinitions(), typeDefinitions_exports)).then((provider) => this._register(provider.register(selector, this.client)))
        ]);
        languages.$triggerStaticFeaturesRegistered();
      }
      configurationChanged() {
        const config3 = workspace.getConfiguration(this.id, null);
        this.updateValidate(config3.get(validateSetting, true));
        this.updateSuggestionDiagnostics(config3.get(suggestionSetting, true));
      }
      handlesUri(resource) {
        const ext = extname2(resource.path).slice(1).toLowerCase();
        return this.description.standardFileExtensions.includes(ext) || this.handlesConfigFile(resource);
      }
      handlesDocument(doc) {
        return this.description.languageIds.includes(doc.languageId) || this.handlesConfigFile(doc.uri);
      }
      handlesConfigFile(resource) {
        const base = basename3(resource.fsPath);
        return !!base && (!!this.description.configFilePattern && this.description.configFilePattern.test(base));
      }
      get id() {
        return this.description.id;
      }
      get diagnosticSource() {
        return this.description.diagnosticSource;
      }
      updateValidate(value) {
        this.client.diagnosticsManager.setValidate(this._diagnosticLanguage, value);
      }
      updateSuggestionDiagnostics(value) {
        this.client.diagnosticsManager.setEnableSuggestions(this._diagnosticLanguage, value);
      }
      reInitialize() {
        this.client.diagnosticsManager.reInitialize();
      }
      triggerAllDiagnostics() {
        this.client.bufferSyncSupport.requestAllDiagnostics();
      }
      diagnosticsReceived(diagnosticsKind, file2, diagnostics, ranges) {
        if (diagnosticsKind !== 0 /* Syntax */ && !this.client.hasCapabilityForResource(file2, 2 /* Semantic */)) {
          return;
        }
        if (diagnosticsKind === 1 /* Semantic */ && isWeb()) {
          if (!isWebAndHasSharedArrayBuffers() || !supportsReadableByteStreams() || this.client.configuration.webProjectWideIntellisenseSuppressSemanticErrors || !this.client.configuration.webProjectWideIntellisenseEnabled) {
            return;
          }
        }
        if (diagnosticsKind === 1 /* Semantic */ && file2.scheme === Schemes.notebookCell) {
          return;
        }
        const config3 = workspace.getConfiguration(this.id, file2);
        const reportUnnecessary = config3.get("showUnused", true);
        const reportDeprecated = config3.get("showDeprecated", true);
        this.client.diagnosticsManager.updateDiagnostics(file2, this._diagnosticLanguage, diagnosticsKind, diagnostics.filter((diag) => {
          if (!reportUnnecessary) {
            if (diag.reportUnnecessary && diag.severity === 3 /* Hint */) {
              return false;
            }
          }
          if (!reportDeprecated) {
            if (diag.reportDeprecated && diag.severity === 3 /* Hint */) {
              return false;
            }
          }
          return true;
        }), ranges);
      }
      configFileDiagnosticsReceived(file2, diagnostics) {
        this.client.diagnosticsManager.configFileDiagnosticsReceived(file2, diagnostics);
      }
      get _diagnosticLanguage() {
        return this.description.diagnosticLanguage;
      }
    };
  }
});

// src/typescript-language-features/src/configuration/configuration.ts
function areServiceConfigurationsEqual(a, b) {
  return equals2(a, b);
}
var TsServerLogLevel, ImplicitProjectConfiguration, vscodeWatcherName, BaseServiceConfigurationProvider;
var init_configuration2 = __esm({
  "src/typescript-language-features/src/configuration/configuration.ts"() {
    "use strict";
    init_shims();
    init_objects();
    TsServerLogLevel = /* @__PURE__ */ ((TsServerLogLevel2) => {
      TsServerLogLevel2[TsServerLogLevel2["Off"] = 0] = "Off";
      TsServerLogLevel2[TsServerLogLevel2["Normal"] = 1] = "Normal";
      TsServerLogLevel2[TsServerLogLevel2["Terse"] = 2] = "Terse";
      TsServerLogLevel2[TsServerLogLevel2["Verbose"] = 3] = "Verbose";
      return TsServerLogLevel2;
    })(TsServerLogLevel || {});
    ((TsServerLogLevel2) => {
      function fromString(value) {
        switch (value == null ? void 0 : value.toLowerCase()) {
          case "normal":
            return 1 /* Normal */;
          case "terse":
            return 2 /* Terse */;
          case "verbose":
            return 3 /* Verbose */;
          case "off":
          default:
            return 0 /* Off */;
        }
      }
      TsServerLogLevel2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case 1 /* Normal */:
            return "normal";
          case 2 /* Terse */:
            return "terse";
          case 3 /* Verbose */:
            return "verbose";
          case 0 /* Off */:
          default:
            return "off";
        }
      }
      TsServerLogLevel2.toString = toString;
    })(TsServerLogLevel || (TsServerLogLevel = {}));
    ImplicitProjectConfiguration = class _ImplicitProjectConfiguration {
      constructor(configuration) {
        this.target = _ImplicitProjectConfiguration.readTarget(configuration);
        this.module = _ImplicitProjectConfiguration.readModule(configuration);
        this.checkJs = _ImplicitProjectConfiguration.readCheckJs(configuration);
        this.experimentalDecorators = _ImplicitProjectConfiguration.readExperimentalDecorators(configuration);
        this.strictNullChecks = _ImplicitProjectConfiguration.readImplicitStrictNullChecks(configuration);
        this.strictFunctionTypes = _ImplicitProjectConfiguration.readImplicitStrictFunctionTypes(configuration);
      }
      isEqualTo(other) {
        return equals2(this, other);
      }
      static readTarget(configuration) {
        return configuration.get("js/ts.implicitProjectConfig.target");
      }
      static readModule(configuration) {
        return configuration.get("js/ts.implicitProjectConfig.module");
      }
      static readCheckJs(configuration) {
        return configuration.get("js/ts.implicitProjectConfig.checkJs") ?? configuration.get("javascript.implicitProjectConfig.checkJs", false);
      }
      static readExperimentalDecorators(configuration) {
        return configuration.get("js/ts.implicitProjectConfig.experimentalDecorators") ?? configuration.get("javascript.implicitProjectConfig.experimentalDecorators", false);
      }
      static readImplicitStrictNullChecks(configuration) {
        return configuration.get("js/ts.implicitProjectConfig.strictNullChecks", true);
      }
      static readImplicitStrictFunctionTypes(configuration) {
        return configuration.get("js/ts.implicitProjectConfig.strictFunctionTypes", true);
      }
    };
    vscodeWatcherName = "vscode";
    BaseServiceConfigurationProvider = class {
      loadFromWorkspace() {
        const configuration = workspace.getConfiguration();
        return {
          autoUseWorkspaceTsdk: !!configuration.get("vtsls.autoUseWorkspaceTsdk"),
          locale: this.readLocale(configuration),
          globalTsdk: this.readGlobalTsdk(configuration),
          localTsdk: this.readLocalTsdk(configuration),
          npmLocation: this.readNpmLocation(configuration),
          tsServerLogLevel: this.readTsServerLogLevel(configuration),
          tsServerPluginPaths: this.readTsServerPluginPaths(configuration),
          implicitProjectConfiguration: new ImplicitProjectConfiguration(configuration),
          disableAutomaticTypeAcquisition: this.readDisableAutomaticTypeAcquisition(configuration),
          useSyntaxServer: this.readUseSyntaxServer(configuration),
          webProjectWideIntellisenseEnabled: this.readWebProjectWideIntellisenseEnable(configuration),
          webProjectWideIntellisenseSuppressSemanticErrors: this.readWebProjectWideIntellisenseSuppressSemanticErrors(configuration),
          webTypeAcquisitionEnabled: this.readWebTypeAcquisition(configuration),
          enableDiagnosticsTelemetry: this.readEnableDiagnosticsTelemetry(configuration),
          enableProjectDiagnostics: this.readEnableProjectDiagnostics(configuration),
          maxTsServerMemory: this.readMaxTsServerMemory(configuration),
          enablePromptUseWorkspaceTsdk: this.readEnablePromptUseWorkspaceTsdk(configuration),
          useVsCodeWatcher: this.readUseVsCodeWatcher(configuration),
          watchOptions: this.readWatchOptions(configuration),
          includePackageJsonAutoImports: this.readIncludePackageJsonAutoImports(configuration),
          enableTsServerTracing: this.readEnableTsServerTracing(configuration),
          localNodePath: this.readLocalNodePath(configuration),
          globalNodePath: this.readGlobalNodePath(configuration),
          workspaceSymbolsExcludeLibrarySymbols: this.readWorkspaceSymbolsExcludeLibrarySymbols(configuration),
          enableRegionDiagnostics: this.readEnableRegionDiagnostics(configuration)
        };
      }
      readTsServerLogLevel(configuration) {
        const setting = configuration.get("typescript.tsserver.log", "off");
        return TsServerLogLevel.fromString(setting);
      }
      readTsServerPluginPaths(configuration) {
        return configuration.get("typescript.tsserver.pluginPaths", []);
      }
      readNpmLocation(configuration) {
        return configuration.get("typescript.npm", null);
      }
      readDisableAutomaticTypeAcquisition(configuration) {
        return configuration.get("typescript.disableAutomaticTypeAcquisition", false);
      }
      readLocale(configuration) {
        const value = configuration.get("typescript.locale", "auto");
        return !value || value === "auto" ? null : value;
      }
      readUseSyntaxServer(configuration) {
        const value = configuration.get("typescript.tsserver.useSyntaxServer");
        switch (value) {
          case "never":
            return 0 /* Never */;
          case "always":
            return 1 /* Always */;
          case "auto":
            return 2 /* Auto */;
        }
        const deprecatedValue = configuration.get("typescript.tsserver.useSeparateSyntaxServer", true);
        if (deprecatedValue === "forAllRequests") {
          return 1 /* Always */;
        }
        if (deprecatedValue === true) {
          return 2 /* Auto */;
        }
        return 0 /* Never */;
      }
      readEnableDiagnosticsTelemetry(configuration) {
        return configuration.get("typescript.enableDiagnosticsTelemetry", false);
      }
      readEnableProjectDiagnostics(configuration) {
        return configuration.get("typescript.tsserver.experimental.enableProjectDiagnostics", false);
      }
      readUseVsCodeWatcher(configuration) {
        const watcherExcludes = configuration.get("files.watcherExclude") ?? {};
        if (watcherExcludes["**/node_modules/*/**"] === true || // VS Code default prior to 1.94.x
        watcherExcludes["**/node_modules/**"] === true || watcherExcludes["**/node_modules"] === true || watcherExcludes["**"] === true) {
          return false;
        }
        const experimentalConfig = configuration.inspect("typescript.tsserver.experimental.useVsCodeWatcher");
        if (typeof (experimentalConfig == null ? void 0 : experimentalConfig.globalValue) === "boolean") {
          return experimentalConfig.globalValue;
        }
        if (typeof (experimentalConfig == null ? void 0 : experimentalConfig.workspaceValue) === "boolean") {
          return experimentalConfig.workspaceValue;
        }
        if (typeof (experimentalConfig == null ? void 0 : experimentalConfig.workspaceFolderValue) === "boolean") {
          return experimentalConfig.workspaceFolderValue;
        }
        return configuration.get("typescript.tsserver.watchOptions", vscodeWatcherName) === vscodeWatcherName;
      }
      readWatchOptions(configuration) {
        const watchOptions = configuration.get("typescript.tsserver.watchOptions");
        if (watchOptions === vscodeWatcherName) {
          return void 0;
        }
        return { ...watchOptions ?? {} };
      }
      readIncludePackageJsonAutoImports(configuration) {
        return configuration.get("typescript.preferences.includePackageJsonAutoImports");
      }
      readMaxTsServerMemory(configuration) {
        const defaultMaxMemory = 3072;
        const minimumMaxMemory = 128;
        const memoryInMB = configuration.get("typescript.tsserver.maxTsServerMemory", defaultMaxMemory);
        if (!Number.isSafeInteger(memoryInMB)) {
          return defaultMaxMemory;
        }
        return Math.max(memoryInMB, minimumMaxMemory);
      }
      readEnablePromptUseWorkspaceTsdk(configuration) {
        return configuration.get("typescript.enablePromptUseWorkspaceTsdk", false);
      }
      readEnableTsServerTracing(configuration) {
        return configuration.get("typescript.tsserver.enableTracing", false);
      }
      readWorkspaceSymbolsExcludeLibrarySymbols(configuration) {
        return configuration.get("typescript.workspaceSymbols.excludeLibrarySymbols", true);
      }
      readWebProjectWideIntellisenseEnable(configuration) {
        return configuration.get("typescript.tsserver.web.projectWideIntellisense.enabled", true);
      }
      readWebProjectWideIntellisenseSuppressSemanticErrors(configuration) {
        return this.readWebTypeAcquisition(configuration) && configuration.get("typescript.tsserver.web.projectWideIntellisense.suppressSemanticErrors", false);
      }
      readWebTypeAcquisition(configuration) {
        return configuration.get("typescript.tsserver.web.typeAcquisition.enabled", true);
      }
      readEnableRegionDiagnostics(configuration) {
        return configuration.get("typescript.tsserver.enableRegionDiagnostics", true);
      }
    };
  }
});

// src/typescript-language-features/src/logging/logLevelMonitor.ts
var _LogLevelMonitor, LogLevelMonitor;
var init_logLevelMonitor = __esm({
  "src/typescript-language-features/src/logging/logLevelMonitor.ts"() {
    "use strict";
    init_shims();
    init_configuration2();
    init_dispose();
    _LogLevelMonitor = class _LogLevelMonitor extends Disposable {
      constructor(context) {
        super();
        this.context = context;
        this._register(workspace.onDidChangeConfiguration(this.onConfigurationChange, this, this._disposables));
        if (this.shouldNotifyExtendedLogging()) {
          this.notifyExtendedLogging();
        }
      }
      onConfigurationChange(event) {
        const logLevelChanged = event.affectsConfiguration(_LogLevelMonitor.logLevelConfigKey);
        if (!logLevelChanged) {
          return;
        }
        this.context.globalState.update(_LogLevelMonitor.logLevelChangedStorageKey, /* @__PURE__ */ new Date());
      }
      get logLevel() {
        return TsServerLogLevel.fromString(workspace.getConfiguration().get(_LogLevelMonitor.logLevelConfigKey, "off"));
      }
      /**
       * Last date change if it exists and can be parsed as a date,
       * otherwise undefined.
       */
      get lastLogLevelChange() {
        const lastChange = this.context.globalState.get(_LogLevelMonitor.logLevelChangedStorageKey);
        if (lastChange) {
          const date = new Date(lastChange);
          if (date instanceof Date && !isNaN(date.valueOf())) {
            return date;
          }
        }
        return void 0;
      }
      get doNotPrompt() {
        return this.context.globalState.get(_LogLevelMonitor.doNotPromptLogLevelStorageKey) || false;
      }
      shouldNotifyExtendedLogging() {
        const lastChangeMilliseconds = this.lastLogLevelChange ? new Date(this.lastLogLevelChange).valueOf() : 0;
        const lastChangePlusOneWeek = new Date(lastChangeMilliseconds + /* 7 days in milliseconds */
        864e5 * 7);
        if (!this.doNotPrompt && this.logLevel !== 0 /* Off */ && lastChangePlusOneWeek.valueOf() < Date.now()) {
          return true;
        }
        return false;
      }
      notifyExtendedLogging() {
        let Choice;
        ((Choice2) => {
          Choice2[Choice2["DisableLogging"] = 0] = "DisableLogging";
          Choice2[Choice2["DoNotShowAgain"] = 1] = "DoNotShowAgain";
        })(Choice || (Choice = {}));
        window.showInformationMessage(
          l10n.t("TS Server logging is currently enabled which may impact performance."),
          {
            title: l10n.t("Disable logging"),
            choice: 0 /* DisableLogging */
          },
          {
            title: l10n.t("Don't show again"),
            choice: 1 /* DoNotShowAgain */
          }
        ).then((selection) => {
          if (!selection) {
            return;
          }
          if (selection.choice === 0 /* DisableLogging */) {
            return workspace.getConfiguration().update(_LogLevelMonitor.logLevelConfigKey, "off", true);
          } else if (selection.choice === 1 /* DoNotShowAgain */) {
            return this.context.globalState.update(_LogLevelMonitor.doNotPromptLogLevelStorageKey, true);
          }
          return;
        });
      }
    };
    _LogLevelMonitor.logLevelConfigKey = "typescript.tsserver.log";
    _LogLevelMonitor.logLevelChangedStorageKey = "typescript.tsserver.logLevelChanged";
    _LogLevelMonitor.doNotPromptLogLevelStorageKey = "typescript.tsserver.doNotPromptLogLevel";
    LogLevelMonitor = _LogLevelMonitor;
  }
});

// src/typescript-language-features/src/logging/telemetry.ts
var VSCodeTelemetryReporter;
var init_telemetry = __esm({
  "src/typescript-language-features/src/logging/telemetry.ts"() {
    "use strict";
    VSCodeTelemetryReporter = class {
      constructor(reporter, clientVersionDelegate) {
        this.reporter = reporter;
        this.clientVersionDelegate = clientVersionDelegate;
      }
      logTelemetry(eventName, properties = {}) {
        const reporter = this.reporter;
        if (!reporter) {
          return;
        }
        properties["version"] = this.clientVersionDelegate();
        reporter.postEventObj(eventName, properties);
      }
    };
  }
});

// src/typescript-language-features/src/logging/tracer.ts
var Tracer;
var init_tracer = __esm({
  "src/typescript-language-features/src/logging/tracer.ts"() {
    "use strict";
    init_shims();
    init_dispose();
    Tracer = class extends Disposable {
      constructor(logger) {
        super();
        this.logger = logger;
      }
      traceRequest(serverId, request, responseExpected, queueLength) {
        if (this.logger.logLevel === 1 /* Trace */) {
          this.trace(serverId, `Sending request: ${request.command} (${request.seq}). Response expected: ${responseExpected ? "yes" : "no"}. Current queue length: ${queueLength}`, request.arguments);
        }
      }
      traceResponse(serverId, response, meta) {
        if (this.logger.logLevel === 1 /* Trace */) {
          this.trace(serverId, `Response received: ${response.command} (${response.request_seq}). Request took ${Date.now() - meta.queuingStartTime} ms. Success: ${response.success} ${!response.success ? ". Message: " + response.message : ""}`, response.body);
        }
      }
      traceRequestCompleted(serverId, command, request_seq, meta) {
        if (this.logger.logLevel === 1 /* Trace */) {
          this.trace(serverId, `Async response received: ${command} (${request_seq}). Request took ${Date.now() - meta.queuingStartTime} ms.`);
        }
      }
      traceEvent(serverId, event) {
        if (this.logger.logLevel === 1 /* Trace */) {
          this.trace(serverId, `Event received: ${event.event} (${event.seq}).`, event.body);
        }
      }
      trace(serverId, message, data) {
        this.logger.trace(`<${serverId}> ${message}`, ...data ? [JSON.stringify(data, null, 4)] : []);
      }
    };
  }
});

// src/typescript-language-features/src/utils/async.ts
function setImmediate(callback, ...args) {
  if (global.setImmediate) {
    const handle = global.setImmediate(callback, ...args);
    return { dispose: () => global.clearImmediate(handle) };
  } else {
    const handle = setTimeout(callback, 0, ...args);
    return { dispose: () => clearTimeout(handle) };
  }
}
var Delayer;
var init_async = __esm({
  "src/typescript-language-features/src/utils/async.ts"() {
    "use strict";
    Delayer = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = null;
        this.completionPromise = null;
        this.onSuccess = null;
        this.task = null;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
          this.cancelTimeout();
        }
        if (!this.completionPromise) {
          this.completionPromise = new Promise((resolve) => {
            this.onSuccess = resolve;
          }).then(() => {
            var _a;
            this.completionPromise = null;
            this.onSuccess = null;
            const result = (_a = this.task) == null ? void 0 : _a.call(this);
            this.task = null;
            return result;
          });
        }
        if (delay >= 0 || this.timeout === null) {
          this.timeout = setTimeout(() => {
            var _a;
            this.timeout = null;
            (_a = this.onSuccess) == null ? void 0 : _a.call(this, void 0);
          }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
      }
      cancelTimeout() {
        if (this.timeout !== null) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/bufferSyncSupport.ts
function mode2ScriptKind(mode) {
  switch (mode) {
    case typescript:
      return "TS";
    case typescriptreact:
      return "TSX";
    case javascript:
      return "JS";
    case javascriptreact:
      return "JSX";
  }
  return void 0;
}
var CloseOperation, OpenOperation, ChangeOperation, BufferSynchronizer, SyncedBuffer, SyncedBufferMap, PendingDiagnostics, GetErrRequest, TabResourceTracker, BufferSyncSupport;
var init_bufferSyncSupport = __esm({
  "src/typescript-language-features/src/tsServer/bufferSyncSupport.ts"() {
    "use strict";
    init_shims();
    init_fileSchemes();
    init_languageIds();
    init_typeConverters();
    init_typescriptService();
    init_typescriptServiceClient();
    init_arrays();
    init_async();
    init_cancellation();
    init_dispose();
    init_resourceMap();
    init_api2();
    CloseOperation = class {
      constructor(args, scriptKind) {
        this.args = args;
        this.scriptKind = scriptKind;
        this.type = 0 /* Close */;
      }
    };
    OpenOperation = class {
      constructor(args, scriptKind) {
        this.args = args;
        this.scriptKind = scriptKind;
        this.type = 1 /* Open */;
      }
    };
    ChangeOperation = class {
      constructor(args) {
        this.args = args;
        this.type = 2 /* Change */;
      }
    };
    BufferSynchronizer = class {
      constructor(client, pathNormalizer, onCaseInsensitiveFileSystem2) {
        this.client = client;
        this._pending = new ResourceMap(pathNormalizer, {
          onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2
        });
      }
      open(resource, args) {
        this.updatePending(resource, new OpenOperation(args, args.scriptKindName));
      }
      /**
       * @return Was the buffer open?
       */
      close(resource, filepath, scriptKind) {
        return this.updatePending(resource, new CloseOperation(filepath, scriptKind));
      }
      change(resource, filepath, events) {
        if (!events.length) {
          return;
        }
        this.updatePending(resource, new ChangeOperation({
          fileName: filepath,
          textChanges: events.map((change) => ({
            newText: change.text,
            start: Position3.toLocation(change.range.start),
            end: Position3.toLocation(change.range.end)
          })).reverse()
          // Send the edits end-of-document to start-of-document order
        }));
      }
      reset() {
        this._pending.clear();
      }
      beforeCommand(command) {
        if (command === "updateOpen") {
          return;
        }
        this.flush();
      }
      flush() {
        if (this._pending.size > 0) {
          const closedFiles = [];
          const openFiles = [];
          const changedFiles = [];
          for (const change of this._pending.values()) {
            switch (change.type) {
              case 2 /* Change */:
                changedFiles.push(change.args);
                break;
              case 1 /* Open */:
                openFiles.push(change.args);
                break;
              case 0 /* Close */:
                closedFiles.push(change.args);
                break;
            }
          }
          this.client.execute("updateOpen", { changedFiles, closedFiles, openFiles }, nulToken, { nonRecoverable: true });
          this._pending.clear();
        }
      }
      updatePending(resource, op) {
        switch (op.type) {
          case 0 /* Close */: {
            const existing = this._pending.get(resource);
            switch (existing == null ? void 0 : existing.type) {
              case 1 /* Open */:
                if (existing.scriptKind === op.scriptKind) {
                  this._pending.delete(resource);
                  return false;
                }
            }
            break;
          }
        }
        if (this._pending.has(resource)) {
          this.flush();
        }
        this._pending.set(resource, op);
        return true;
      }
    };
    SyncedBuffer = class {
      constructor(document, filepath, client, synchronizer) {
        this.document = document;
        this.filepath = filepath;
        this.client = client;
        this.synchronizer = synchronizer;
        this.state = 0 /* Initial */;
      }
      open() {
        const args = {
          file: this.filepath,
          fileContent: this.document.getText(),
          projectRootPath: this.getProjectRootPath(this.document.uri)
        };
        const scriptKind = mode2ScriptKind(this.document.languageId);
        if (scriptKind) {
          args.scriptKindName = scriptKind;
        }
        const tsPluginsForDocument = this.client.pluginManager.plugins.filter((x) => x.languages.indexOf(this.document.languageId) >= 0);
        if (tsPluginsForDocument.length) {
          args.plugins = tsPluginsForDocument.map((plugin) => plugin.name);
        }
        this.synchronizer.open(this.resource, args);
        this.state = 1 /* Open */;
      }
      getProjectRootPath(resource) {
        const workspaceRoot = this.client.getWorkspaceRootForResource(resource);
        if (workspaceRoot) {
          const tsRoot = this.client.toTsFilePath(workspaceRoot);
          return (tsRoot == null ? void 0 : tsRoot.startsWith(inMemoryResourcePrefix)) ? void 0 : tsRoot;
        }
        return isOfScheme(resource, officeScript, chatCodeBlock) ? "/" : void 0;
      }
      get resource() {
        return this.document.uri;
      }
      get lineCount() {
        return this.document.lineCount;
      }
      get languageId() {
        return this.document.languageId;
      }
      /**
       * @return Was the buffer open?
       */
      close() {
        if (this.state !== 1 /* Open */) {
          this.state = 2 /* Closed */;
          return false;
        }
        this.state = 2 /* Closed */;
        return this.synchronizer.close(this.resource, this.filepath, mode2ScriptKind(this.document.languageId));
      }
      onContentChanged(events) {
        if (this.state !== 1 /* Open */) {
          console.error(`Unexpected buffer state: ${this.state}`);
        }
        this.synchronizer.change(this.resource, this.filepath, events);
      }
    };
    SyncedBufferMap = class extends ResourceMap {
      getForPath(filePath) {
        return this.get(Uri.file(filePath));
      }
      get allBuffers() {
        return this.values();
      }
    };
    PendingDiagnostics = class extends ResourceMap {
      getOrderedFileSet() {
        const orderedResources = Array.from(this.entries()).sort((a, b) => a.value - b.value).map((entry) => entry.resource);
        const map = new ResourceMap(this._normalizePath, this.config);
        for (const resource of orderedResources) {
          map.set(resource, void 0);
        }
        return map;
      }
    };
    GetErrRequest = class _GetErrRequest {
      constructor(client, files, onDone) {
        this.client = client;
        this.files = files;
        this._done = false;
        this._token = new CancellationTokenSource();
        if (!this.isErrorReportingEnabled()) {
          this._done = true;
          setImmediate(onDone);
          return;
        }
        const supportsSyntaxGetErr = this.client.apiVersion.gte(API.v440);
        const fileEntries = Array.from(files.entries()).filter((entry) => supportsSyntaxGetErr || client.hasCapabilityForResource(entry.resource, 2 /* Semantic */));
        const allFiles = coalesce(fileEntries.map((entry) => client.toTsFilePath(entry.resource)));
        if (!allFiles.length) {
          this._done = true;
          setImmediate(onDone);
        } else {
          let request;
          if (this.areProjectDiagnosticsEnabled()) {
            request = client.executeAsync("geterrForProject", { delay: 0, file: allFiles[0] }, this._token.token);
          } else {
            let requestFiles;
            if (this.areRegionDiagnosticsEnabled()) {
              requestFiles = coalesce(fileEntries.map((entry) => {
                const file2 = client.toTsFilePath(entry.resource);
                const ranges = entry.value;
                if (file2 && ranges) {
                  return Range4.toFileRangesRequestArgs(file2, ranges);
                }
                return file2;
              }));
            } else {
              requestFiles = allFiles;
            }
            request = client.executeAsync("geterr", { delay: 0, files: requestFiles }, this._token.token);
          }
          request.finally(() => {
            if (this._done) {
              return;
            }
            this._done = true;
            onDone();
          });
        }
      }
      static executeGetErrRequest(client, files, onDone) {
        return new _GetErrRequest(client, files, onDone);
      }
      isErrorReportingEnabled() {
        if (this.client.apiVersion.gte(API.v440)) {
          return true;
        } else {
          return this.client.capabilities.has(2 /* Semantic */);
        }
      }
      areProjectDiagnosticsEnabled() {
        return this.client.configuration.enableProjectDiagnostics && this.client.capabilities.has(2 /* Semantic */);
      }
      areRegionDiagnosticsEnabled() {
        return this.client.configuration.enableRegionDiagnostics && this.client.apiVersion.gte(API.v560);
      }
      cancel() {
        if (!this._done) {
          this._token.cancel();
        }
        this._token.dispose();
      }
    };
    TabResourceTracker = class extends Disposable {
      constructor(normalizePath, config3) {
        super();
        this._onDidChange = this._register(new EventEmitter());
        this.onDidChange = this._onDidChange.event;
        this._tabResources = new ResourceMap(normalizePath, config3);
        for (const tabGroup of window.tabGroups.all) {
          for (const tab of tabGroup.tabs) {
            this.add(tab);
          }
        }
        this._register(window.tabGroups.onDidChangeTabs((e) => {
          const closed = e.closed.flatMap((tab) => this.delete(tab));
          const opened = e.opened.flatMap((tab) => this.add(tab));
          if (closed.length || opened.length) {
            this._onDidChange.fire({ closed, opened });
          }
        }));
      }
      has(resource) {
        if (resource.scheme === vscodeNotebookCell) {
          const notebook = workspace.notebookDocuments.find((doc) => doc.getCells().some((cell) => cell.document.uri.toString() === resource.toString()));
          return !!notebook && this.has(notebook.uri);
        }
        const entry = this._tabResources.get(resource);
        return !!entry && entry.tabs.size > 0;
      }
      add(tab) {
        const addedResources = [];
        for (const uri of this.getResourcesForTab(tab)) {
          const entry = this._tabResources.get(uri);
          if (entry) {
            entry.tabs.add(tab);
          } else {
            this._tabResources.set(uri, { tabs: /* @__PURE__ */ new Set([tab]) });
            addedResources.push(uri);
          }
        }
        return addedResources;
      }
      delete(tab) {
        const closedResources = [];
        for (const uri of this.getResourcesForTab(tab)) {
          const entry = this._tabResources.get(uri);
          if (!entry) {
            continue;
          }
          entry.tabs.delete(tab);
          if (entry.tabs.size === 0) {
            this._tabResources.delete(uri);
            closedResources.push(uri);
          }
        }
        return closedResources;
      }
      getResourcesForTab(tab) {
        if (tab.input instanceof TabInputText) {
          return [tab.input.uri];
        } else if (tab.input instanceof TabInputTextDiff) {
          return [tab.input.original, tab.input.modified];
        } else if (tab.input instanceof TabInputNotebook) {
          return [tab.input.uri];
        } else {
          return [];
        }
      }
    };
    BufferSyncSupport = class extends Disposable {
      constructor(client, modeIds, onCaseInsensitiveFileSystem2) {
        super();
        this._validateJavaScript = true;
        this._validateTypeScript = true;
        this.listening = false;
        this._onDelete = this._register(new EventEmitter());
        this.onDelete = this._onDelete.event;
        this._onWillChange = this._register(new EventEmitter());
        this.onWillChange = this._onWillChange.event;
        this.client = client;
        this.modeIds = new Set(modeIds);
        this.diagnosticDelayer = new Delayer(300);
        const pathNormalizer = (path15) => this.client.toTsFilePath(path15);
        this.syncedBuffers = new SyncedBufferMap(pathNormalizer, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 });
        this.pendingDiagnostics = new PendingDiagnostics(pathNormalizer, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 });
        this.synchronizer = new BufferSynchronizer(client, pathNormalizer, onCaseInsensitiveFileSystem2);
        this._tabResources = this._register(new TabResourceTracker(pathNormalizer, { onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem2 }));
        this._register(this._tabResources.onDidChange((e) => {
          var _a;
          if (this.client.configuration.enableProjectDiagnostics) {
            return;
          }
          for (const closed of e.closed) {
            const syncedBuffer = this.syncedBuffers.get(closed);
            if (syncedBuffer) {
              this.pendingDiagnostics.delete(closed);
              (_a = this.pendingGetErr) == null ? void 0 : _a.files.delete(closed);
            }
          }
          for (const opened of e.opened) {
            const syncedBuffer = this.syncedBuffers.get(opened);
            if (syncedBuffer) {
              this.requestDiagnostic(syncedBuffer);
            }
          }
        }));
        this.updateConfiguration();
        workspace.onDidChangeConfiguration(this.updateConfiguration, this, this._disposables);
      }
      listen() {
        if (this.listening) {
          return;
        }
        this.listening = true;
        workspace.onDidOpenTextDocument(this.openTextDocument, this, this._disposables);
        workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this._disposables);
        workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this._disposables);
        window.onDidChangeVisibleTextEditors((e) => {
          for (const { document } of e) {
            const syncedBuffer = this.syncedBuffers.get(document.uri);
            if (syncedBuffer) {
              this.requestDiagnostic(syncedBuffer);
            }
          }
        }, this, this._disposables);
        workspace.textDocuments.forEach(this.openTextDocument, this);
      }
      handles(resource) {
        return this.syncedBuffers.has(resource);
      }
      ensureHasBuffer(resource) {
        if (this.syncedBuffers.has(resource)) {
          return true;
        }
        const existingDocument = workspace.textDocuments.find((doc) => doc.uri.toString() === resource.toString());
        if (existingDocument) {
          return this.openTextDocument(existingDocument);
        }
        return false;
      }
      toVsCodeResource(resource) {
        const filepath = this.client.toTsFilePath(resource);
        for (const buffer of this.syncedBuffers.allBuffers) {
          if (buffer.filepath === filepath) {
            return buffer.resource;
          }
        }
        return resource;
      }
      toResource(filePath) {
        const buffer = this.syncedBuffers.getForPath(filePath);
        if (buffer) {
          return buffer.resource;
        }
        return Uri.file(filePath);
      }
      reset() {
        var _a;
        (_a = this.pendingGetErr) == null ? void 0 : _a.cancel();
        this.pendingDiagnostics.clear();
        this.synchronizer.reset();
      }
      reinitialize() {
        this.reset();
        for (const buffer of this.syncedBuffers.allBuffers) {
          buffer.open();
        }
      }
      openTextDocument(document) {
        if (!this.modeIds.has(document.languageId)) {
          return false;
        }
        const resource = document.uri;
        const filepath = this.client.toTsFilePath(resource);
        if (!filepath) {
          return false;
        }
        if (this.syncedBuffers.has(resource)) {
          return true;
        }
        const syncedBuffer = new SyncedBuffer(document, filepath, this.client, this.synchronizer);
        this.syncedBuffers.set(resource, syncedBuffer);
        syncedBuffer.open();
        this.requestDiagnostic(syncedBuffer);
        return true;
      }
      closeResource(resource) {
        var _a;
        const syncedBuffer = this.syncedBuffers.get(resource);
        if (!syncedBuffer) {
          return;
        }
        this.pendingDiagnostics.delete(resource);
        (_a = this.pendingGetErr) == null ? void 0 : _a.files.delete(resource);
        this.syncedBuffers.delete(resource);
        const wasBufferOpen = syncedBuffer.close();
        this._onDelete.fire(resource);
        if (wasBufferOpen) {
          this.requestAllDiagnostics();
        }
      }
      interruptGetErr(f) {
        if (!this.pendingGetErr || this.client.configuration.enableProjectDiagnostics) {
          return f();
        }
        this.pendingGetErr.cancel();
        this.pendingGetErr = void 0;
        const result = f();
        this.triggerDiagnostics();
        return result;
      }
      beforeCommand(command) {
        this.synchronizer.beforeCommand(command);
      }
      lineCount(resource) {
        var _a;
        return (_a = this.syncedBuffers.get(resource)) == null ? void 0 : _a.lineCount;
      }
      onDidCloseTextDocument(document) {
        this.closeResource(document.uri);
      }
      onDidChangeTextDocument(e) {
        const syncedBuffer = this.syncedBuffers.get(e.document.uri);
        if (!syncedBuffer) {
          return;
        }
        this._onWillChange.fire(syncedBuffer.resource);
        syncedBuffer.onContentChanged(e.contentChanges);
        const didTrigger = this.requestDiagnostic(syncedBuffer);
        if (!didTrigger && this.pendingGetErr) {
          this.pendingGetErr.cancel();
          this.pendingGetErr = void 0;
          this.triggerDiagnostics();
        }
      }
      requestAllDiagnostics() {
        for (const buffer of this.syncedBuffers.allBuffers) {
          if (this.shouldValidate(buffer)) {
            this.pendingDiagnostics.set(buffer.resource, Date.now());
          }
        }
        this.triggerDiagnostics();
      }
      getErr(resources) {
        const handledResources = resources.filter((resource) => this.handles(resource));
        if (!handledResources.length) {
          return;
        }
        for (const resource of handledResources) {
          this.pendingDiagnostics.set(resource, Date.now());
        }
        this.triggerDiagnostics();
      }
      triggerDiagnostics(delay = 200) {
        this.diagnosticDelayer.trigger(() => {
          this.sendPendingDiagnostics();
        }, delay);
      }
      requestDiagnostic(buffer) {
        if (!this.shouldValidate(buffer)) {
          return false;
        }
        this.pendingDiagnostics.set(buffer.resource, Date.now());
        const delay = Math.min(Math.max(Math.ceil(buffer.lineCount / 20), 300), 800);
        this.triggerDiagnostics(delay);
        return true;
      }
      hasPendingDiagnostics(resource) {
        return this.pendingDiagnostics.has(resource);
      }
      sendPendingDiagnostics() {
        const orderedFileSet = this.pendingDiagnostics.getOrderedFileSet();
        if (this.pendingGetErr) {
          this.pendingGetErr.cancel();
          for (const { resource } of this.pendingGetErr.files.entries()) {
            if (this.syncedBuffers.get(resource)) {
              orderedFileSet.set(resource, void 0);
            }
          }
          this.pendingGetErr = void 0;
        }
        for (const buffer of this.syncedBuffers.values()) {
          const editors = window.visibleTextEditors.filter((editor) => editor.document.uri.toString() === buffer.resource.toString());
          const visibleRanges = editors.flatMap((editor) => editor.visibleRanges);
          orderedFileSet.set(buffer.resource, visibleRanges.length ? visibleRanges : void 0);
        }
        for (const { resource } of orderedFileSet.entries()) {
          const buffer = this.syncedBuffers.get(resource);
          if (buffer && !this.shouldValidate(buffer)) {
            orderedFileSet.delete(resource);
          }
        }
        if (orderedFileSet.size) {
          const getErr = this.pendingGetErr = GetErrRequest.executeGetErrRequest(this.client, orderedFileSet, () => {
            if (this.pendingGetErr === getErr) {
              this.pendingGetErr = void 0;
            }
          });
        }
        this.pendingDiagnostics.clear();
      }
      updateConfiguration() {
        const jsConfig = workspace.getConfiguration("javascript", null);
        const tsConfig = workspace.getConfiguration("typescript", null);
        this._validateJavaScript = jsConfig.get("validate.enable", true);
        this._validateTypeScript = tsConfig.get("validate.enable", true);
      }
      shouldValidate(buffer) {
        if (isOfScheme(buffer.resource, chatCodeBlock)) {
          return false;
        }
        switch (buffer.languageId) {
          case javascript:
          case javascriptreact:
            return this._validateJavaScript;
          case typescript:
          case typescriptreact:
          default:
            return this._validateTypeScript;
        }
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/nodeManager.ts
var useWorkspaceNodeStorageKey, lastKnownWorkspaceNodeStorageKey, NodeVersionManager;
var init_nodeManager = __esm({
  "src/typescript-language-features/src/tsServer/nodeManager.ts"() {
    "use strict";
    init_shims();
    init_async();
    init_dispose();
    useWorkspaceNodeStorageKey = "typescript.useWorkspaceNode";
    lastKnownWorkspaceNodeStorageKey = "typescript.lastKnownWorkspaceNode";
    NodeVersionManager = class extends Disposable {
      constructor(configuration, workspaceState) {
        super();
        this.configuration = configuration;
        this.workspaceState = workspaceState;
        this._onDidPickNewVersion = this._register(new EventEmitter());
        this.onDidPickNewVersion = this._onDidPickNewVersion.event;
        this._currentVersion = this.configuration.globalNodePath || void 0;
        if (workspace.isTrusted) {
          const workspaceVersion = this.configuration.localNodePath;
          if (workspaceVersion) {
            const useWorkspaceNode = this.canUseWorkspaceNode(workspaceVersion);
            if (useWorkspaceNode === void 0) {
              setImmediate(() => {
                this.promptAndSetWorkspaceNode();
              });
            } else if (useWorkspaceNode) {
              this._currentVersion = workspaceVersion;
            }
          }
        } else {
          this._disposables.push(workspace.onDidGrantWorkspaceTrust(() => {
            const workspaceVersion = this.configuration.localNodePath;
            if (workspaceVersion) {
              const useWorkspaceNode = this.canUseWorkspaceNode(workspaceVersion);
              if (useWorkspaceNode === void 0) {
                setImmediate(() => {
                  this.promptAndSetWorkspaceNode();
                });
              } else if (useWorkspaceNode) {
                this.updateActiveVersion(workspaceVersion);
              }
            }
          }));
        }
      }
      get currentVersion() {
        return this._currentVersion;
      }
      async updateConfiguration(nextConfiguration) {
        const oldConfiguration = this.configuration;
        this.configuration = nextConfiguration;
        if (oldConfiguration.globalNodePath !== nextConfiguration.globalNodePath || oldConfiguration.localNodePath !== nextConfiguration.localNodePath) {
          await this.computeNewVersion();
        }
      }
      async computeNewVersion() {
        let version = this.configuration.globalNodePath || void 0;
        const workspaceVersion = this.configuration.localNodePath;
        if (workspace.isTrusted && workspaceVersion) {
          const useWorkspaceNode = this.canUseWorkspaceNode(workspaceVersion);
          if (useWorkspaceNode === void 0) {
            version = await this.promptUseWorkspaceNode() || version;
          } else if (useWorkspaceNode) {
            version = workspaceVersion;
          }
        }
        this.updateActiveVersion(version);
      }
      async promptUseWorkspaceNode() {
        const workspaceVersion = this.configuration.localNodePath;
        if (workspaceVersion === null) {
          throw new Error("Could not prompt to use workspace Node installation because no workspace Node installation is specified");
        }
        const allow = l10n.t("Yes");
        const disallow = l10n.t("No");
        const dismiss = l10n.t("Not now");
        const result = allow;
        let version = void 0;
        switch (result) {
          case allow:
            await this.setUseWorkspaceNodeState(true, workspaceVersion);
            version = workspaceVersion;
            break;
          case disallow:
            await this.setUseWorkspaceNodeState(false, workspaceVersion);
            break;
          case dismiss:
            await this.setUseWorkspaceNodeState(void 0, workspaceVersion);
            break;
        }
        return version;
      }
      async promptAndSetWorkspaceNode() {
        const version = await this.promptUseWorkspaceNode();
        if (version !== void 0) {
          this.updateActiveVersion(version);
        }
      }
      updateActiveVersion(pickedVersion) {
        const oldVersion = this.currentVersion;
        this._currentVersion = pickedVersion;
        if (oldVersion !== pickedVersion) {
          this._onDidPickNewVersion.fire();
        }
      }
      canUseWorkspaceNode(nodeVersion) {
        const lastKnownWorkspaceNode = this.workspaceState.get(lastKnownWorkspaceNodeStorageKey);
        if (lastKnownWorkspaceNode === nodeVersion) {
          return this.workspaceState.get(useWorkspaceNodeStorageKey);
        }
        return void 0;
      }
      async setUseWorkspaceNodeState(allow, nodeVersion) {
        await this.workspaceState.update(lastKnownWorkspaceNodeStorageKey, nodeVersion);
        await this.workspaceState.update(useWorkspaceNodeStorageKey, allow);
      }
    };
  }
});

// src/typescript-language-features/src/utils/relativePathResolver.ts
import * as path7 from "path";
var RelativeWorkspacePathResolver;
var init_relativePathResolver = __esm({
  "src/typescript-language-features/src/utils/relativePathResolver.ts"() {
    "use strict";
    init_shims();
    RelativeWorkspacePathResolver = class {
      static asAbsoluteWorkspacePath(relativePath) {
        for (const root of workspace.workspaceFolders || []) {
          const rootPrefixes = [`./${root.name}/`, `${root.name}/`, `.\\${root.name}\\`, `${root.name}\\`];
          for (const rootPrefix of rootPrefixes) {
            if (relativePath.startsWith(rootPrefix)) {
              return path7.join(root.uri.fsPath, relativePath.replace(rootPrefix, ""));
            }
          }
        }
        return void 0;
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/pluginPathsProvider.ts
import * as path8 from "path";
var TypeScriptPluginPathsProvider;
var init_pluginPathsProvider = __esm({
  "src/typescript-language-features/src/tsServer/pluginPathsProvider.ts"() {
    "use strict";
    init_shims();
    init_relativePathResolver();
    TypeScriptPluginPathsProvider = class {
      constructor(configuration) {
        this.configuration = configuration;
      }
      updateConfiguration(configuration) {
        this.configuration = configuration;
      }
      getPluginPaths() {
        const pluginPaths = [];
        for (const pluginPath of this.configuration.tsServerPluginPaths) {
          pluginPaths.push(...this.resolvePluginPath(pluginPath));
        }
        return pluginPaths;
      }
      resolvePluginPath(pluginPath) {
        if (path8.isAbsolute(pluginPath)) {
          return [pluginPath];
        }
        const workspacePath = RelativeWorkspacePathResolver.asAbsoluteWorkspacePath(pluginPath);
        if (workspacePath !== void 0) {
          return [workspacePath];
        }
        return (workspace.workspaceFolders || []).map((workspaceFolder) => path8.join(workspaceFolder.uri.fsPath, pluginPath));
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/spawner.ts
var _TypeScriptServerSpawner, TypeScriptServerSpawner;
var init_spawner = __esm({
  "src/typescript-language-features/src/tsServer/spawner.ts"() {
    "use strict";
    init_shims();
    init_configuration2();
    init_typescriptService();
    init_memoize();
    init_platform();
    init_api2();
    init_server();
    _TypeScriptServerSpawner = class _TypeScriptServerSpawner {
      constructor(_versionProvider, _versionManager, _nodeVersionManager, _logDirectoryProvider, _pluginPathsProvider, _logger, _telemetryReporter, _tracer, _factory) {
        this._versionProvider = _versionProvider;
        this._versionManager = _versionManager;
        this._nodeVersionManager = _nodeVersionManager;
        this._logDirectoryProvider = _logDirectoryProvider;
        this._pluginPathsProvider = _pluginPathsProvider;
        this._logger = _logger;
        this._telemetryReporter = _telemetryReporter;
        this._tracer = _tracer;
        this._factory = _factory;
      }
      static get tsServerLogOutputChannel() {
        return window.createOutputChannel(l10n.t("TypeScript Server Log"));
      }
      spawn(version, capabilities, configuration, pluginManager, cancellerFactory, delegate) {
        let primaryServer;
        const serverType = this.getCompositeServerType(version, capabilities, configuration);
        const shouldUseSeparateDiagnosticsServer = this.shouldUseSeparateDiagnosticsServer(configuration);
        switch (serverType) {
          case 1 /* SeparateSyntax */:
          case 2 /* DynamicSeparateSyntax */: {
            const enableDynamicRouting = !shouldUseSeparateDiagnosticsServer && serverType === 2 /* DynamicSeparateSyntax */;
            primaryServer = new SyntaxRoutingTsServer({
              syntax: this.spawnTsServer("syntax" /* Syntax */, version, configuration, pluginManager, cancellerFactory),
              semantic: this.spawnTsServer("semantic" /* Semantic */, version, configuration, pluginManager, cancellerFactory)
            }, delegate, enableDynamicRouting);
            break;
          }
          case 0 /* Single */: {
            primaryServer = this.spawnTsServer("main" /* Main */, version, configuration, pluginManager, cancellerFactory);
            break;
          }
          case 3 /* SyntaxOnly */: {
            primaryServer = this.spawnTsServer("syntax" /* Syntax */, version, configuration, pluginManager, cancellerFactory);
            break;
          }
        }
        if (shouldUseSeparateDiagnosticsServer) {
          return new GetErrRoutingTsServer({
            getErr: this.spawnTsServer("diagnostics" /* Diagnostics */, version, configuration, pluginManager, cancellerFactory),
            primary: primaryServer
          }, delegate);
        }
        return primaryServer;
      }
      getCompositeServerType(version, capabilities, configuration) {
        var _a;
        if (!capabilities.has(2 /* Semantic */)) {
          return 3 /* SyntaxOnly */;
        }
        switch (configuration.useSyntaxServer) {
          case 1 /* Always */:
            return 3 /* SyntaxOnly */;
          case 0 /* Never */:
            return 0 /* Single */;
          case 2 /* Auto */:
            return ((_a = version.apiVersion) == null ? void 0 : _a.gte(API.v400)) ? 2 /* DynamicSeparateSyntax */ : 1 /* SeparateSyntax */;
        }
      }
      shouldUseSeparateDiagnosticsServer(configuration) {
        return configuration.enableProjectDiagnostics;
      }
      spawnTsServer(kind, version, configuration, pluginManager, cancellerFactory) {
        const apiVersion = version.apiVersion || API.defaultVersion;
        const canceller = cancellerFactory.create(kind, this._tracer);
        const { args, tsServerLog, tsServerTraceDirectory } = this.getTsServerArgs(kind, configuration, version, apiVersion, pluginManager, canceller.cancellationPipeName);
        if (_TypeScriptServerSpawner.isLoggingEnabled(configuration)) {
          if ((tsServerLog == null ? void 0 : tsServerLog.type) === "file") {
            this._logger.info(`<${kind}> Log file: ${tsServerLog.uri.fsPath}`);
          } else if ((tsServerLog == null ? void 0 : tsServerLog.type) === "output") {
            this._logger.info(`<${kind}> Logging to output`);
          } else {
            this._logger.error(`<${kind}> Could not create TS Server log`);
          }
        }
        if (configuration.enableTsServerTracing) {
          if (tsServerTraceDirectory) {
            this._logger.info(`<${kind}> Trace directory: ${tsServerTraceDirectory.fsPath}`);
          } else {
            this._logger.error(`<${kind}> Could not create trace directory`);
          }
        }
        this._logger.info(`<${kind}> Forking...`);
        const process2 = this._factory.fork(version, args, kind, configuration, this._versionManager, this._nodeVersionManager, tsServerLog);
        this._logger.info(`<${kind}> Starting...`);
        return new SingleTsServer(
          kind,
          this.kindToServerType(kind),
          process2,
          tsServerLog,
          canceller,
          version,
          this._telemetryReporter,
          this._tracer
        );
      }
      kindToServerType(kind) {
        switch (kind) {
          case "syntax" /* Syntax */:
            return "syntax" /* Syntax */;
          case "main" /* Main */:
          case "semantic" /* Semantic */:
          case "diagnostics" /* Diagnostics */:
          default:
            return "semantic" /* Semantic */;
        }
      }
      getTsServerArgs(kind, configuration, currentVersion, apiVersion, pluginManager, cancellationPipeName) {
        const args = [];
        let tsServerLog;
        let tsServerTraceDirectory;
        if (kind === "syntax" /* Syntax */) {
          if (apiVersion.gte(API.v401)) {
            args.push("--serverMode", "partialSemantic");
          } else {
            args.push("--syntaxOnly");
          }
        }
        args.push("--useInferredProjectPerProjectRoot");
        if (configuration.disableAutomaticTypeAcquisition || kind === "syntax" /* Syntax */ || kind === "diagnostics" /* Diagnostics */) {
          args.push("--disableAutomaticTypingAcquisition");
        }
        if (kind === "semantic" /* Semantic */ || kind === "main" /* Main */) {
          args.push("--enableTelemetry");
        }
        if (cancellationPipeName) {
          args.push("--cancellationPipeName", cancellationPipeName + "*");
        }
        if (_TypeScriptServerSpawner.isLoggingEnabled(configuration)) {
          if (isWeb()) {
            args.push("--logVerbosity", TsServerLogLevel.toString(configuration.tsServerLogLevel));
            tsServerLog = { type: "output", output: _TypeScriptServerSpawner.tsServerLogOutputChannel };
          } else {
            const logDir = this._logDirectoryProvider.getNewLogDirectory();
            if (logDir) {
              const logFilePath = Uri.joinPath(logDir, `tsserver.log`);
              tsServerLog = { type: "file", uri: logFilePath };
              args.push("--logVerbosity", TsServerLogLevel.toString(configuration.tsServerLogLevel));
              args.push("--logFile", logFilePath.fsPath);
            }
          }
        }
        if (configuration.enableTsServerTracing && !isWeb()) {
          tsServerTraceDirectory = this._logDirectoryProvider.getNewLogDirectory();
          if (tsServerTraceDirectory) {
            args.push("--traceDirectory", `"${tsServerTraceDirectory.fsPath}"`);
          }
        }
        const pluginPaths = isWeb() ? [] : this._pluginPathsProvider.getPluginPaths();
        if (pluginManager.plugins.length) {
          args.push("--globalPlugins", pluginManager.plugins.map((x) => x.name).join(","));
          const isUsingBundledTypeScriptVersion = currentVersion.path === this._versionProvider.defaultVersion.path;
          for (const plugin of pluginManager.plugins) {
            if ((isUsingBundledTypeScriptVersion || plugin.enableForWorkspaceTypeScriptVersions) && plugin.uri) {
              pluginPaths.push(isWeb() ? plugin.uri.toString() : plugin.uri.fsPath);
            }
          }
        }
        if (pluginPaths.length !== 0) {
          args.push("--pluginProbeLocations", pluginPaths.join(","));
        }
        if (configuration.npmLocation && !isWeb()) {
          args.push("--npmLocation", `"${configuration.npmLocation}"`);
        }
        args.push("--locale", _TypeScriptServerSpawner.getTsLocale(configuration));
        args.push("--noGetErrOnBackgroundUpdate");
        const configUseVsCodeWatcher = configuration.useVsCodeWatcher;
        const isYarnPnp = apiVersion.isYarnPnp();
        if (apiVersion.gte(API.v544) && configUseVsCodeWatcher && !isYarnPnp) {
          args.push("--canUseWatchEvents");
        } else {
          if (!configUseVsCodeWatcher) {
            this._logger.info(`<${kind}> Falling back to legacy node.js based file watching because of user settings.`);
          } else if (isYarnPnp) {
            this._logger.info(`<${kind}> Falling back to legacy node.js based file watching because of Yarn PnP.`);
          }
        }
        args.push("--validateDefaultNpmLocation");
        if (isWebAndHasSharedArrayBuffers()) {
          args.push("--enableProjectWideIntelliSenseOnWeb");
        }
        return { args, tsServerLog, tsServerTraceDirectory };
      }
      static isLoggingEnabled(configuration) {
        return configuration.tsServerLogLevel !== 0 /* Off */;
      }
      static getTsLocale(configuration) {
        return configuration.locale ? configuration.locale : env.language;
      }
    };
    __decorateClass([
      memoize
    ], _TypeScriptServerSpawner, "tsServerLogOutputChannel", 1);
    TypeScriptServerSpawner = _TypeScriptServerSpawner;
  }
});

// src/typescript-language-features/src/tsServer/versionManager.ts
var useWorkspaceTsdkStorageKey, suppressPromptWorkspaceTsdkStorageKey, TypeScriptVersionManager, LearnMorePickItem;
var init_versionManager = __esm({
  "src/typescript-language-features/src/tsServer/versionManager.ts"() {
    "use strict";
    init_shims();
    init_async();
    init_dispose();
    useWorkspaceTsdkStorageKey = "typescript.useWorkspaceTsdk";
    suppressPromptWorkspaceTsdkStorageKey = "typescript.suppressPromptWorkspaceTsdk";
    TypeScriptVersionManager = class extends Disposable {
      constructor(configuration, versionProvider, workspaceState) {
        super();
        this.configuration = configuration;
        this.versionProvider = versionProvider;
        this.workspaceState = workspaceState;
        this._onDidPickNewVersion = this._register(new EventEmitter());
        this.onDidPickNewVersion = this._onDidPickNewVersion.event;
        this._currentVersion = this.versionProvider.defaultVersion;
        if (this.useWorkspaceTsdkSetting) {
          if (workspace.isTrusted) {
            const localVersion = this.versionProvider.localVersion;
            if (localVersion) {
              this._currentVersion = localVersion;
            }
          } else {
            this._disposables.push(workspace.onDidGrantWorkspaceTrust(() => {
              if (this.versionProvider.localVersion) {
                this.updateActiveVersion(this.versionProvider.localVersion);
              }
            }));
          }
        }
        if (this.isInPromptWorkspaceTsdkState(configuration)) {
          setImmediate(() => {
            this.promptUseWorkspaceTsdk();
          });
        }
      }
      updateConfiguration(nextConfiguration) {
        const lastConfiguration = this.configuration;
        this.configuration = nextConfiguration;
        if (!this.isInPromptWorkspaceTsdkState(lastConfiguration) && this.isInPromptWorkspaceTsdkState(nextConfiguration)) {
          this.promptUseWorkspaceTsdk();
        }
      }
      get currentVersion() {
        return this._currentVersion;
      }
      reset() {
        this._currentVersion = this.versionProvider.bundledVersion;
      }
      pickItemToMessage(item) {
        let title = item.label;
        if (item.description) {
          title += ` (${item.description})`;
        }
        if (item.detail) {
          title += ` [${item.detail}]`;
        }
        return {
          title,
          run: item.run
        };
      }
      async promptUserForVersion() {
        const selected = await window.showInformationMessage(
          l10n.t("Select the TypeScript version used for JavaScript and TypeScript language features"),
          ...[
            this.getBundledPickItem(),
            ...this.getLocalPickItems(),
            LearnMorePickItem
          ].map(this.pickItemToMessage)
        );
        return selected == null ? void 0 : selected.run();
      }
      getBundledPickItem() {
        const bundledVersion = this.versionProvider.defaultVersion;
        return {
          label: (!this.useWorkspaceTsdkSetting || !workspace.isTrusted ? "\u2022 " : "") + l10n.t("Use VS Code's Version"),
          description: bundledVersion.displayName,
          detail: bundledVersion.pathLabel,
          run: async () => {
            await this.workspaceState.update(useWorkspaceTsdkStorageKey, false);
            this.updateActiveVersion(bundledVersion);
          }
        };
      }
      getLocalPickItems() {
        return this.versionProvider.localVersions.map((version) => {
          return {
            label: (this.useWorkspaceTsdkSetting && workspace.isTrusted && this.currentVersion.eq(version) ? "\u2022 " : "") + l10n.t("Use Workspace Version"),
            description: version.displayName,
            detail: version.pathLabel,
            run: async () => {
              const trusted = await workspace.requestWorkspaceTrust();
              if (trusted) {
                await this.workspaceState.update(useWorkspaceTsdkStorageKey, true);
                const tsConfig = workspace.getConfiguration("typescript");
                await tsConfig.update("tsdk", version.pathLabel, false);
                this.updateActiveVersion(version);
              }
            }
          };
        });
      }
      async promptUseWorkspaceTsdk() {
        const workspaceVersion = this.versionProvider.localVersion;
        if (workspaceVersion === void 0) {
          throw new Error("Could not prompt to use workspace TypeScript version because no workspace version is specified");
        }
        const allowIt = l10n.t("Allow");
        const dismissPrompt = l10n.t("Dismiss");
        const suppressPrompt = l10n.t("Never in this Workspace");
        const result = await window.showInformationMessage(
          l10n.t("This workspace contains a TypeScript version. Would you like to use the workspace TypeScript version for TypeScript and JavaScript language features?"),
          allowIt,
          dismissPrompt,
          suppressPrompt
        );
        if (result === allowIt) {
          await this.workspaceState.update(useWorkspaceTsdkStorageKey, true);
          this.updateActiveVersion(workspaceVersion);
        } else if (result === suppressPrompt) {
          await this.workspaceState.update(suppressPromptWorkspaceTsdkStorageKey, true);
        }
      }
      updateActiveVersion(pickedVersion) {
        const oldVersion = this.currentVersion;
        this._currentVersion = pickedVersion;
        if (!oldVersion.eq(pickedVersion)) {
          this._onDidPickNewVersion.fire();
        }
      }
      get useWorkspaceTsdkSetting() {
        return this.workspaceState.get(useWorkspaceTsdkStorageKey, this.configuration.autoUseWorkspaceTsdk);
      }
      get suppressPromptWorkspaceTsdkSetting() {
        return this.workspaceState.get(suppressPromptWorkspaceTsdkStorageKey, false);
      }
      isInPromptWorkspaceTsdkState(configuration) {
        return configuration.localTsdk !== null && configuration.enablePromptUseWorkspaceTsdk === true && this.suppressPromptWorkspaceTsdkSetting === false && this.useWorkspaceTsdkSetting === false;
      }
    };
    LearnMorePickItem = {
      label: l10n.t("Learn more about managing TypeScript versions"),
      description: "",
      run: () => {
        env.openExternal(Uri.parse("https://go.microsoft.com/fwlink/?linkid=839919"));
      }
    };
  }
});

// src/typescript-language-features/src/utils/hash.ts
function hash(obj, hashVal = 0) {
  switch (typeof obj) {
    case "object":
      if (obj === null) {
        return numberHash(349, hashVal);
      } else if (Array.isArray(obj)) {
        return arrayHash(obj, hashVal);
      }
      return objectHash(obj, hashVal);
    case "string":
      return stringHash(obj, hashVal);
    case "boolean":
      return booleanHash(obj, hashVal);
    case "number":
      return numberHash(obj, hashVal);
    case "undefined":
      return 937 * 31;
    default:
      return numberHash(obj, 617);
  }
}
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0;
}
function booleanHash(b, initialHashVal) {
  return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
  hashVal = numberHash(149417, hashVal);
  for (let i = 0, length = s.length; i < length; i++) {
    hashVal = numberHash(s.charCodeAt(i), hashVal);
  }
  return hashVal;
}
function arrayHash(arr, initialHashVal) {
  initialHashVal = numberHash(104579, initialHashVal);
  return arr.reduce((hashVal, item) => hash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
  initialHashVal = numberHash(181387, initialHashVal);
  return Object.keys(obj).sort().reduce((hashVal, key) => {
    hashVal = stringHash(key, hashVal);
    return hash(obj[key], hashVal);
  }, initialHashVal);
}
var init_hash = __esm({
  "src/typescript-language-features/src/utils/hash.ts"() {
    "use strict";
  }
});

// src/typescript-language-features/src/typescriptServiceClient.ts
import { homedir } from "os";
import * as path9 from "path";
function getDiagnosticsKind(event) {
  switch (event.event) {
    case "syntaxDiag":
      return 0 /* Syntax */;
    case "semanticDiag":
      return 1 /* Semantic */;
    case "suggestionDiag":
      return 2 /* Suggestion */;
    case "regionSemanticDiag":
      return 3 /* RegionSemantic */;
  }
  throw new Error("Unknown dignostics kind");
}
var ServerState, emptyAuthority, inMemoryResourcePrefix, TypeScriptServiceClient, ServerInitializingIndicator;
var init_typescriptServiceClient = __esm({
  "src/typescript-language-features/src/typescriptServiceClient.ts"() {
    "use strict";
    init_shims();
    init_configuration2();
    init_fileSchemes();
    init_schemes();
    init_diagnostics2();
    init_telemetry();
    init_tracer();
    init_tsconfig();
    init_api2();
    init_bufferSyncSupport();
    init_nodeManager();
    init_pluginPathsProvider();
    init_protocol_const();
    init_serverError();
    init_spawner();
    init_versionManager();
    init_typescriptService();
    init_dispose();
    init_hash();
    init_platform();
    ((ServerState2) => {
      let Type;
      ((Type2) => {
        Type2[Type2["None"] = 0] = "None";
        Type2[Type2["Running"] = 1] = "Running";
        Type2[Type2["Errored"] = 2] = "Errored";
      })(Type = ServerState2.Type || (ServerState2.Type = {}));
      ServerState2.None = { type: 0 /* None */ };
      class Running {
        constructor(server, apiVersion, tsserverVersion, languageServiceEnabled) {
          this.server = server;
          this.apiVersion = apiVersion;
          this.tsserverVersion = tsserverVersion;
          this.languageServiceEnabled = languageServiceEnabled;
          this.type = 1 /* Running */;
          this.toCancelOnResourceChange = /* @__PURE__ */ new Set();
        }
        updateTsserverVersion(tsserverVersion) {
          this.tsserverVersion = tsserverVersion;
        }
        updateLanguageServiceEnabled(enabled) {
          this.languageServiceEnabled = enabled;
        }
      }
      ServerState2.Running = Running;
      class Errored {
        constructor(error, tsServerLog) {
          this.error = error;
          this.tsServerLog = tsServerLog;
          this.type = 2 /* Errored */;
        }
      }
      ServerState2.Errored = Errored;
    })(ServerState || (ServerState = {}));
    emptyAuthority = "ts-nul-authority";
    inMemoryResourcePrefix = "^";
    TypeScriptServiceClient = class extends Disposable {
      constructor(context, onCaseInsensitiveFileSystem2, services, allModeIds) {
        super();
        this.context = context;
        this.serverState = ServerState.None;
        this._isPromptingAfterCrash = false;
        this.isRestarting = false;
        this.hasServerFatallyCrashedTooManyTimes = false;
        this.watches = /* @__PURE__ */ new Map();
        this.watchEvents = /* @__PURE__ */ new Map();
        this._onDidChangeCapabilities = this._register(new EventEmitter());
        this.onDidChangeCapabilities = this._onDidChangeCapabilities.event;
        this._onTsServerStarted = this._register(new EventEmitter());
        this.onTsServerStarted = this._onTsServerStarted.event;
        this._onDiagnosticsReceived = this._register(new EventEmitter());
        this.onDiagnosticsReceived = this._onDiagnosticsReceived.event;
        this._onConfigDiagnosticsReceived = this._register(new EventEmitter());
        this.onConfigDiagnosticsReceived = this._onConfigDiagnosticsReceived.event;
        this._onResendModelsRequested = this._register(new EventEmitter());
        this.onResendModelsRequested = this._onResendModelsRequested.event;
        this._onProjectLanguageServiceStateChanged = this._register(new EventEmitter());
        this.onProjectLanguageServiceStateChanged = this._onProjectLanguageServiceStateChanged.event;
        this._onDidBeginInstallTypings = this._register(new EventEmitter());
        this.onDidBeginInstallTypings = this._onDidBeginInstallTypings.event;
        this._onDidEndInstallTypings = this._register(new EventEmitter());
        this.onDidEndInstallTypings = this._onDidEndInstallTypings.event;
        this._onTypesInstallerInitializationFailed = this._register(new EventEmitter());
        this.onTypesInstallerInitializationFailed = this._onTypesInstallerInitializationFailed.event;
        this._onSurveyReady = this._register(new EventEmitter());
        this.onSurveyReady = this._onSurveyReady.event;
        this.token = 0;
        this.loadingIndicator = this._register(new ServerInitializingIndicator(this));
        this.logger = services.logger;
        this.tracer = new Tracer(this.logger);
        this.pluginManager = services.pluginManager;
        this.logDirectoryProvider = services.logDirectoryProvider;
        this.cancellerFactory = services.cancellerFactory;
        this.versionProvider = services.versionProvider;
        this.processFactory = services.processFactory;
        this.lastStart = Date.now();
        let resolve;
        let reject;
        const p = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        this._onReady = { promise: p, resolve, reject };
        this.numberRestarts = 0;
        this._configuration = services.serviceConfigurationProvider.loadFromWorkspace();
        this.versionProvider.updateConfiguration(this._configuration);
        this.pluginPathsProvider = new TypeScriptPluginPathsProvider(this._configuration);
        this._versionManager = this._register(new TypeScriptVersionManager(this._configuration, this.versionProvider, context.workspaceState));
        this._register(this._versionManager.onDidPickNewVersion(() => {
          this.restartTsServer();
        }));
        this._nodeVersionManager = this._register(new NodeVersionManager(this._configuration, context.workspaceState));
        this._register(this._nodeVersionManager.onDidPickNewVersion(() => {
          this.restartTsServer();
        }));
        this.bufferSyncSupport = new BufferSyncSupport(this, allModeIds, onCaseInsensitiveFileSystem2);
        this.onReady(() => {
          this.bufferSyncSupport.listen();
        });
        this.bufferSyncSupport.onDelete((resource) => {
          this.cancelInflightRequestsForResource(resource);
          this.diagnosticsManager.deleteAllDiagnosticsInFile(resource);
        }, null, this._disposables);
        this.bufferSyncSupport.onWillChange((resource) => {
          this.cancelInflightRequestsForResource(resource);
        });
        workspace.onDidChangeConfiguration(() => {
          const oldConfiguration = this._configuration;
          this._configuration = services.serviceConfigurationProvider.loadFromWorkspace();
          this.versionProvider.updateConfiguration(this._configuration);
          this._versionManager.updateConfiguration(this._configuration);
          this.pluginPathsProvider.updateConfiguration(this._configuration);
          this._nodeVersionManager.updateConfiguration(this._configuration);
          if (this.serverState.type === 1 /* Running */) {
            if (!this._configuration.implicitProjectConfiguration.isEqualTo(oldConfiguration.implicitProjectConfiguration)) {
              this.setCompilerOptionsForInferredProjects(this._configuration);
            }
            if (!areServiceConfigurationsEqual(this._configuration, oldConfiguration)) {
              this.restartTsServer();
            }
          }
        }, this, this._disposables);
        this.telemetryReporter = new VSCodeTelemetryReporter(services.experimentTelemetryReporter, () => {
          if (this.serverState.type === 1 /* Running */) {
            if (this.serverState.tsserverVersion) {
              return this.serverState.tsserverVersion;
            }
          }
          return this.apiVersion.fullVersionString;
        });
        this.diagnosticsManager = new DiagnosticsManager("typescript", this._configuration, this.telemetryReporter, onCaseInsensitiveFileSystem2);
        this.typescriptServerSpawner = new TypeScriptServerSpawner(this.versionProvider, this._versionManager, this._nodeVersionManager, this.logDirectoryProvider, this.pluginPathsProvider, this.logger, this.telemetryReporter, this.tracer, this.processFactory);
        this._register(this.pluginManager.onDidUpdateConfig((update2) => {
          this.configurePlugin(update2.pluginId, update2.config);
        }));
        this._register(this.pluginManager.onDidChangePlugins(() => {
          this.restartTsServer();
        }));
      }
      get capabilities() {
        if (this._configuration.useSyntaxServer === 1 /* Always */) {
          return new ClientCapabilities(
            0 /* Syntax */,
            1 /* EnhancedSyntax */
          );
        }
        if (isWeb()) {
          if (this.isProjectWideIntellisenseOnWebEnabled()) {
            return new ClientCapabilities(
              0 /* Syntax */,
              1 /* EnhancedSyntax */,
              2 /* Semantic */
            );
          } else {
            return new ClientCapabilities(
              0 /* Syntax */,
              1 /* EnhancedSyntax */
            );
          }
        }
        if (this.apiVersion.gte(API.v400)) {
          return new ClientCapabilities(
            0 /* Syntax */,
            1 /* EnhancedSyntax */,
            2 /* Semantic */
          );
        }
        return new ClientCapabilities(
          0 /* Syntax */,
          2 /* Semantic */
        );
      }
      isProjectWideIntellisenseOnWebEnabled() {
        return isWebAndHasSharedArrayBuffers() && this._configuration.webProjectWideIntellisenseEnabled;
      }
      cancelInflightRequestsForResource(resource) {
        if (this.serverState.type !== 1 /* Running */) {
          return;
        }
        for (const request of this.serverState.toCancelOnResourceChange) {
          if (request.resource.toString() === resource.toString()) {
            request.cancel();
          }
        }
      }
      get configuration() {
        return this._configuration;
      }
      dispose() {
        super.dispose();
        this.bufferSyncSupport.dispose();
        if (this.serverState.type === 1 /* Running */) {
          this.serverState.server.kill();
        }
        this.loadingIndicator.reset();
        this.resetWatchers();
      }
      restartTsServer(fromUserAction = false) {
        if (this.serverState.type === 1 /* Running */) {
          this.logger.info("Killing TS Server");
          this.isRestarting = true;
          this.serverState.server.kill();
        }
        if (fromUserAction) {
          this.hasServerFatallyCrashedTooManyTimes = false;
          this.numberRestarts = 0;
          this.lastStart = Date.now();
        }
        this.serverState = this.startService(true);
      }
      get apiVersion() {
        if (this.serverState.type === 1 /* Running */) {
          return this.serverState.apiVersion;
        }
        return API.defaultVersion;
      }
      onReady(f) {
        return this._onReady.promise.then(f);
      }
      ensureServiceStarted() {
        if (this.serverState.type !== 1 /* Running */) {
          this.startService();
        }
      }
      startService(resendModels = false) {
        this.logger.info(`Starting TS Server`);
        if (this.isDisposed) {
          this.logger.info(`Not starting server: disposed`);
          return ServerState.None;
        }
        if (this.hasServerFatallyCrashedTooManyTimes) {
          this.logger.info(`Not starting server: too many crashes`);
          return ServerState.None;
        }
        let version = this._versionManager.currentVersion;
        if (!version.isValid) {
          window.showWarningMessage(l10n.t("The path {0} doesn't point to a valid tsserver install. Falling back to bundled TypeScript version.", version.path));
          this._versionManager.reset();
          version = this._versionManager.currentVersion;
        }
        this.logger.info(`Using tsserver from: ${version.path}`);
        const nodePath = this._nodeVersionManager.currentVersion;
        if (nodePath) {
          this.logger.info(`Using Node installation from ${nodePath} to run TS Server`);
        }
        this.resetWatchers();
        const apiVersion = version.apiVersion || API.defaultVersion;
        const mytoken = ++this.token;
        const handle = this.typescriptServerSpawner.spawn(version, this.capabilities, this.configuration, this.pluginManager, this.cancellerFactory, {
          onFatalError: (command, err) => this.fatalError(command, err)
        });
        this.serverState = new ServerState.Running(handle, apiVersion, void 0, true);
        this.lastStart = Date.now();
        const typeScriptServerEnvCommonProperties = {
          hasGlobalPlugins: this.pluginManager.plugins.length > 0,
          globalPluginNameHashes: JSON.stringify(this.pluginManager.plugins.map((plugin) => hash(plugin.name)))
        };
        this.telemetryReporter.logTelemetry("tsserver.spawned", {
          ...typeScriptServerEnvCommonProperties,
          localTypeScriptVersion: this.versionProvider.localVersion ? this.versionProvider.localVersion.displayName : "",
          typeScriptVersionSource: version.source
        });
        handle.onError((err) => {
          var _a;
          if (this.token !== mytoken) {
            return;
          }
          if (err) {
            window.showErrorMessage(l10n.t("TypeScript language server exited with error. Error message is: {0}", err.message || err.name));
          }
          this.serverState = new ServerState.Errored(err, handle.tsServerLog);
          this.logger.error("TSServer errored with error.", err);
          if (((_a = handle.tsServerLog) == null ? void 0 : _a.type) === "file") {
            this.logger.error(`TSServer log file: ${handle.tsServerLog.uri.fsPath}`);
          }
          this.telemetryReporter.logTelemetry("tsserver.error", {
            ...typeScriptServerEnvCommonProperties
          });
          this.serviceExited(false, apiVersion);
        });
        handle.onExit((data) => {
          var _a;
          const { code, signal } = data;
          this.logger.error(`TSServer exited. Code: ${code}. Signal: ${signal}`);
          this.telemetryReporter.logTelemetry("tsserver.exitWithCode", {
            ...typeScriptServerEnvCommonProperties,
            code: code ?? void 0,
            signal: signal ?? void 0
          });
          if (this.token !== mytoken) {
            return;
          }
          if (((_a = handle.tsServerLog) == null ? void 0 : _a.type) === "file") {
            this.logger.info(`TSServer log file: ${handle.tsServerLog.uri.fsPath}`);
          }
          this.serviceExited(!this.isRestarting, apiVersion);
          this.isRestarting = false;
        });
        handle.onEvent((event) => this.dispatchEvent(event));
        this.serviceStarted(resendModels);
        this._onReady.resolve();
        this._onTsServerStarted.fire({ version, usedApiVersion: apiVersion });
        this._onDidChangeCapabilities.fire();
        return this.serverState;
      }
      resetWatchers() {
        clearTimeout(this.watchChangeTimeout);
        disposeAll(Array.from(this.watches.values()));
      }
      async showVersionPicker() {
        this._versionManager.promptUserForVersion();
      }
      async openTsServerLogFile() {
        if (this._configuration.tsServerLogLevel === 0 /* Off */) {
          window.showErrorMessage(
            l10n.t("TS Server logging is off. Please set 'typescript.tsserver.log' and restart the TS server to enable logging"),
            {
              title: l10n.t("Enable logging and restart TS server")
            }
          ).then((selection) => {
            if (selection) {
              return workspace.getConfiguration().update("typescript.tsserver.log", "verbose", true).then(() => {
                this.restartTsServer();
              });
            }
            return void 0;
          });
          return false;
        }
        if (this.serverState.type !== 1 /* Running */ || !this.serverState.server.tsServerLog) {
          window.showWarningMessage(l10n.t("TS Server has not started logging."));
          return false;
        }
        switch (this.serverState.server.tsServerLog.type) {
          case "output": {
            this.serverState.server.tsServerLog.output.show();
            return true;
          }
          case "file": {
            try {
              const doc = await workspace.openTextDocument(this.serverState.server.tsServerLog.uri);
              await window.showTextDocument(doc);
              return true;
            } catch {
            }
            try {
              await commands.executeCommand("revealFileInOS", this.serverState.server.tsServerLog.uri);
              return true;
            } catch {
              window.showWarningMessage(l10n.t("Could not open TS Server log file"));
              return false;
            }
          }
        }
      }
      serviceStarted(resendModels) {
        this.bufferSyncSupport.reset();
        const watchOptions = this.apiVersion.gte(API.v380) ? this.configuration.watchOptions : void 0;
        const configureOptions = {
          hostInfo: this.context.hostInfo || "vscode",
          preferences: {
            providePrefixAndSuffixTextForRename: true,
            allowRenameOfImportPath: true,
            includePackageJsonAutoImports: this._configuration.includePackageJsonAutoImports,
            excludeLibrarySymbolsInNavTo: this._configuration.workspaceSymbolsExcludeLibrarySymbols
          },
          watchOptions
        };
        this.executeWithoutWaitingForResponse("configure", configureOptions);
        this.setCompilerOptionsForInferredProjects(this._configuration);
        if (resendModels) {
          this._onResendModelsRequested.fire();
          this.bufferSyncSupport.reinitialize();
          this.bufferSyncSupport.requestAllDiagnostics();
        }
        for (const [pluginName, config3] of this.pluginManager.configurations()) {
          this.configurePlugin(pluginName, config3);
        }
      }
      setCompilerOptionsForInferredProjects(configuration) {
        const args = {
          options: this.getCompilerOptionsForInferredProjects(configuration)
        };
        this.executeWithoutWaitingForResponse("compilerOptionsForInferredProjects", args);
      }
      getCompilerOptionsForInferredProjects(configuration) {
        return {
          ...inferredProjectCompilerOptions(this.apiVersion, 0 /* TypeScript */, configuration),
          allowJs: true,
          allowSyntheticDefaultImports: true,
          allowNonTsExtensions: true,
          resolveJsonModule: true
        };
      }
      serviceExited(restart, tsVersion) {
        this.resetWatchers();
        this.loadingIndicator.reset();
        this.serverState = ServerState.None;
        if (restart) {
          const diff = Date.now() - this.lastStart;
          this.numberRestarts++;
          let startService = true;
          const pluginExtensionList = this.pluginManager.plugins.map((plugin) => plugin.extension.id).join(", ");
          const reportIssueItem = {
            title: l10n.t("Report Issue")
          };
          let prompt = void 0;
          if (this.numberRestarts > 5) {
            this.numberRestarts = 0;
            if (diff < 10 * 1e3) {
              this.lastStart = Date.now();
              startService = false;
              this.hasServerFatallyCrashedTooManyTimes = true;
              if (this.pluginManager.plugins.length) {
                prompt = window.showErrorMessage(
                  l10n.t("The JS/TS language service immediately crashed 5 times. The service will not be restarted.\nThis may be caused by a plugin contributed by one of these extensions: {0}.\nPlease try disabling these extensions before filing an issue against VS Code.", pluginExtensionList)
                );
              } else {
                prompt = window.showErrorMessage(
                  l10n.t("The JS/TS language service immediately crashed 5 times. The service will not be restarted."),
                  reportIssueItem
                );
              }
              this.telemetryReporter.logTelemetry("serviceExited");
            } else if (diff < 60 * 1e3 * 5) {
              this.lastStart = Date.now();
              if (!this._isPromptingAfterCrash) {
                if (this.pluginManager.plugins.length) {
                  prompt = window.showWarningMessage(
                    l10n.t("The JS/TS language service crashed 5 times in the last 5 Minutes.\nThis may be caused by a plugin contributed by one of these extensions: {0}\nPlease try disabling these extensions before filing an issue against VS Code.", pluginExtensionList)
                  );
                } else {
                  prompt = window.showWarningMessage(
                    l10n.t("The JS/TS language service crashed 5 times in the last 5 Minutes."),
                    reportIssueItem
                  );
                }
              }
            }
          } else if (["vscode-insiders", "code-oss"].includes(env.uriScheme)) {
            this.numberRestarts = 0;
            if (!this._isPromptingAfterCrash) {
              if (this.pluginManager.plugins.length) {
                prompt = window.showWarningMessage(
                  l10n.t("The JS/TS language service crashed.\nThis may be caused by a plugin contributed by one of these extensions: {0}.\nPlease try disabling these extensions before filing an issue against VS Code.", pluginExtensionList)
                );
              } else {
                prompt = window.showWarningMessage(
                  l10n.t("The JS/TS language service crashed."),
                  reportIssueItem
                );
              }
            }
          }
          if (prompt) {
            this._isPromptingAfterCrash = true;
          }
          prompt == null ? void 0 : prompt.then(async (item) => {
            this._isPromptingAfterCrash = false;
            if (item === reportIssueItem) {
              const minModernTsVersion = this.versionProvider.bundledVersion.apiVersion;
              if (tsVersion.isYarnPnp()) {
                const reportIssue = {
                  title: l10n.t("Report issue against Yarn PnP")
                };
                const response = await window.showWarningMessage(
                  l10n.t("Please report an issue against Yarn PnP"),
                  {
                    modal: true,
                    detail: l10n.t("The workspace is using a version of the TypeScript Server that has been patched by Yarn PnP. This patching is a common source of bugs.")
                  },
                  reportIssue
                );
                if (response === reportIssue) {
                  env.openExternal(Uri.parse("https://github.com/yarnpkg/berry/issues"));
                }
              } else if (minModernTsVersion && tsVersion.lt(minModernTsVersion)) {
                window.showWarningMessage(
                  l10n.t("Please update your TypeScript version"),
                  {
                    modal: true,
                    detail: l10n.t(
                      "The workspace is using an old version of TypeScript ({0}).\n\nBefore reporting an issue, please update the workspace to use TypeScript {1} or newer to make sure the bug has not already been fixed.",
                      tsVersion.displayName,
                      minModernTsVersion.displayName
                    )
                  }
                );
              } else {
                env.openExternal(Uri.parse("https://github.com/microsoft/vscode/wiki/TypeScript-Issues"));
              }
            }
          });
          if (startService) {
            this.startService(true);
          }
        }
      }
      toTsFilePath(resource) {
        if (disabledSchemes.has(resource.scheme)) {
          return void 0;
        }
        if (resource.scheme === file && !isWeb()) {
          return resource.fsPath;
        }
        if (resource.scheme === zipfile) {
          return resource.scheme + "://" + (resource.path.startsWith("/") ? resource.path : "/" + resource.path);
        }
        return (this.isProjectWideIntellisenseOnWebEnabled() ? "" : inMemoryResourcePrefix) + "/" + resource.scheme + "/" + (resource.authority || emptyAuthority) + (resource.path.startsWith("/") ? resource.path : "/" + resource.path) + (resource.fragment ? "#" + resource.fragment : "");
      }
      toOpenTsFilePath(document, options = {}) {
        const uri = document instanceof Uri ? document : document.uri;
        if (!this.bufferSyncSupport.ensureHasBuffer(uri)) {
          if (!options.suppressAlertOnFailure && !disabledSchemes.has(uri.scheme)) {
            console.error(`Unexpected resource ${uri}`);
          }
          return void 0;
        }
        return this.toTsFilePath(uri);
      }
      hasCapabilityForResource(resource, capability) {
        if (!this.capabilities.has(capability)) {
          return false;
        }
        switch (capability) {
          case 2 /* Semantic */: {
            return getSemanticSupportedSchemes().includes(resource.scheme);
          }
          case 0 /* Syntax */:
          case 1 /* EnhancedSyntax */: {
            return true;
          }
        }
      }
      toResource(filepath) {
        if (isWeb()) {
          if (filepath.startsWith("/lib.") && filepath.endsWith(".d.ts")) {
            return Uri.joinPath(this.context.extensionUri, "dist", "browser", "typescript", filepath.slice(1));
          }
          const parts = filepath.match(/^\/([^\/]+)\/([^\/]*)\/(.+)$/);
          if (parts) {
            const resource = Uri.parse(parts[1] + "://" + (parts[2] === emptyAuthority ? "" : parts[2]) + "/" + parts[3]);
            return this.bufferSyncSupport.toVsCodeResource(resource);
          }
        }
        if (filepath.startsWith(zipfile)) {
          const uri = Uri.parse(filepath, false);
          return new Proxy(uri, {
            get(target, p) {
              if (p === "toString") {
                return () => filepath;
              }
              return target[p];
            }
          });
        }
        if (filepath.startsWith(inMemoryResourcePrefix)) {
          const parts = filepath.match(/^\^\/([^\/]+)\/([^\/]*)\/(.+)$/);
          if (parts) {
            const resource = Uri.parse(parts[1] + "://" + (parts[2] === emptyAuthority ? "" : parts[2]) + "/" + parts[3]);
            return this.bufferSyncSupport.toVsCodeResource(resource);
          }
        }
        return this.bufferSyncSupport.toResource(filepath);
      }
      getWorkspaceRootForResource(resource) {
        var _a;
        const roots = workspace.workspaceFolders ? Array.from(workspace.workspaceFolders) : void 0;
        if (!(roots == null ? void 0 : roots.length)) {
          return void 0;
        }
        if (resource.scheme === Schemes.notebookCell) {
          for (const notebook of workspace.notebookDocuments) {
            for (const cell of notebook.getCells()) {
              if (cell.document.uri.toString() === resource.toString()) {
                resource = notebook.uri;
                break;
              }
            }
          }
        }
        for (const root of roots.sort((a, b) => a.uri.fsPath.length - b.uri.fsPath.length)) {
          if (root.uri.scheme === resource.scheme && root.uri.authority === resource.authority) {
            if (resource.fsPath.startsWith(root.uri.fsPath + path9.sep)) {
              return root.uri;
            }
          }
        }
        return (_a = workspace.getWorkspaceFolder(resource)) == null ? void 0 : _a.uri;
      }
      execute(command, args, token, config3) {
        var _a;
        let executions;
        if (config3 == null ? void 0 : config3.cancelOnResourceChange) {
          const runningServerState = this.serverState;
          if (runningServerState.type === 1 /* Running */) {
            const source = new CancellationTokenSource();
            token.onCancellationRequested(() => source.cancel());
            const inFlight = {
              resource: config3.cancelOnResourceChange,
              cancel: () => source.cancel()
            };
            runningServerState.toCancelOnResourceChange.add(inFlight);
            executions = this.executeImpl(command, args, {
              isAsync: false,
              token: source.token,
              expectsResult: true,
              ...config3
            });
            executions[0] = executions[0].finally(() => {
              runningServerState.toCancelOnResourceChange.delete(inFlight);
              source.dispose();
            });
          }
        }
        if (!executions) {
          executions = this.executeImpl(command, args, {
            isAsync: false,
            token,
            expectsResult: true,
            ...config3
          });
        }
        if (config3 == null ? void 0 : config3.nonRecoverable) {
          executions[0].catch((err) => this.fatalError(command, err));
        }
        if (command === "updateOpen") {
          const updateOpenTask = Promise.all(executions).then(() => {
            this.loadingIndicator.reset();
          });
          const updateOpenArgs = args;
          if (((_a = updateOpenArgs.openFiles) == null ? void 0 : _a.length) === 1) {
            this.loadingIndicator.startedLoadingFile(updateOpenArgs.openFiles[0].file, updateOpenTask);
          }
        }
        return executions[0];
      }
      executeWithoutWaitingForResponse(command, args) {
        this.executeImpl(command, args, {
          isAsync: false,
          token: void 0,
          expectsResult: false
        });
      }
      executeAsync(command, args, token) {
        return this.executeImpl(command, args, {
          isAsync: true,
          token,
          expectsResult: true
        })[0];
      }
      executeImpl(command, args, executeInfo) {
        const serverState = this.serverState;
        if (serverState.type === 1 /* Running */) {
          this.bufferSyncSupport.beforeCommand(command);
          return serverState.server.executeImpl(command, args, executeInfo);
        } else {
          return [Promise.resolve(ServerResponse.NoServer)];
        }
      }
      interruptGetErr(f) {
        return this.bufferSyncSupport.interruptGetErr(f);
      }
      fatalError(command, error) {
        this.telemetryReporter.logTelemetry("fatalError", { ...error instanceof TypeScriptServerError ? error.telemetry : { command } });
        console.error(`A non-recoverable error occurred while executing tsserver command: ${command}`);
        if (error instanceof TypeScriptServerError && error.serverErrorText) {
          console.error(error.serverErrorText);
        }
        if (this.serverState.type === 1 /* Running */) {
          this.logger.info("Killing TS Server");
          const logfile = this.serverState.server.tsServerLog;
          this.serverState.server.kill();
          if (error instanceof TypeScriptServerError) {
            this.serverState = new ServerState.Errored(error, logfile);
          }
        }
      }
      dispatchEvent(event) {
        var _a, _b;
        switch (event.event) {
          case "syntaxDiag" /* syntaxDiag */:
          case "semanticDiag" /* semanticDiag */:
          case "suggestionDiag" /* suggestionDiag */:
          case "regionSemanticDiag" /* regionSemanticDiag */: {
            this.loadingIndicator.reset();
            const diagnosticEvent = event;
            if ((_a = diagnosticEvent.body) == null ? void 0 : _a.diagnostics) {
              this._onDiagnosticsReceived.fire({
                kind: getDiagnosticsKind(event),
                resource: this.toResource(diagnosticEvent.body.file),
                diagnostics: diagnosticEvent.body.diagnostics,
                spans: diagnosticEvent.body.spans
              });
            }
            return;
          }
          case "configFileDiag" /* configFileDiag */:
            this._onConfigDiagnosticsReceived.fire(event);
            return;
          case "telemetry" /* telemetry */: {
            const body = event.body;
            this.dispatchTelemetryEvent(body);
            return;
          }
          case "projectLanguageServiceState" /* projectLanguageServiceState */: {
            const body = event.body;
            if (this.serverState.type === 1 /* Running */) {
              this.serverState.updateLanguageServiceEnabled(body.languageServiceEnabled);
            }
            this._onProjectLanguageServiceStateChanged.fire(body);
            return;
          }
          case "projectsUpdatedInBackground" /* projectsUpdatedInBackground */: {
            this.loadingIndicator.reset();
            const body = event.body;
            const resources = body.openFiles.map((file2) => this.toResource(file2));
            this.bufferSyncSupport.getErr(resources);
            return;
          }
          case "beginInstallTypes" /* beginInstallTypes */:
            this._onDidBeginInstallTypings.fire(event.body);
            return;
          case "endInstallTypes" /* endInstallTypes */:
            this._onDidEndInstallTypings.fire(event.body);
            return;
          case "typesInstallerInitializationFailed" /* typesInstallerInitializationFailed */:
            this._onTypesInstallerInitializationFailed.fire(event.body);
            return;
          case "surveyReady" /* surveyReady */:
            this._onSurveyReady.fire(event.body);
            return;
          case "projectLoadingStart" /* projectLoadingStart */:
            this.loadingIndicator.startedLoadingProject(event.body.projectName);
            return;
          case "projectLoadingFinish" /* projectLoadingFinish */:
            this.loadingIndicator.finishedLoadingProject(event.body.projectName);
            return;
          case "createDirectoryWatcher" /* createDirectoryWatcher */: {
            const fpath = event.body.path;
            if (fpath.startsWith(inMemoryResourcePrefix)) {
              return;
            }
            if (process.platform === "darwin" && fpath === path9.join(homedir(), "Library")) {
              return;
            }
            this.createFileSystemWatcher(
              event.body.id,
              new RelativePattern(
                Uri.file(fpath),
                event.body.recursive ? "**" : "*"
              ),
              event.body.ignoreUpdate
            );
            return;
          }
          case "createFileWatcher" /* createFileWatcher */: {
            const path15 = event.body.path;
            if (path15.startsWith(inMemoryResourcePrefix)) {
              return;
            }
            this.createFileSystemWatcher(
              event.body.id,
              new RelativePattern(
                Uri.file(path15),
                "*"
              )
            );
            return;
          }
          case "closeFileWatcher" /* closeFileWatcher */:
            this.closeFileSystemWatcher(event.body.id);
            return;
          case "requestCompleted" /* requestCompleted */: {
            const diagnosticsDuration = (_b = event.body.performanceData) == null ? void 0 : _b.diagnosticsDuration;
            if (diagnosticsDuration) {
              this.diagnosticsManager.logDiagnosticsPerformanceTelemetry(
                diagnosticsDuration.map((fileData) => {
                  const resource = this.toResource(fileData.file);
                  return {
                    ...fileData,
                    fileLineCount: this.bufferSyncSupport.lineCount(resource)
                  };
                })
              );
            }
            return;
          }
        }
      }
      scheduleExecuteWatchChangeRequest() {
        if (!this.watchChangeTimeout) {
          this.watchChangeTimeout = setTimeout(() => {
            this.watchChangeTimeout = void 0;
            const allEvents = Array.from(this.watchEvents, ([id, event]) => ({
              id,
              updated: event.updated && Array.from(event.updated),
              created: event.created && Array.from(event.created),
              deleted: event.deleted && Array.from(event.deleted)
            }));
            this.watchEvents.clear();
            this.executeWithoutWaitingForResponse("watchChange", allEvents);
          }, 100);
        }
      }
      addWatchEvent(id, eventType, path15) {
        var _a;
        let event = this.watchEvents.get(id);
        const removeEvent = (typeOfEventToRemove) => {
          var _a2;
          if (((_a2 = event == null ? void 0 : event[typeOfEventToRemove]) == null ? void 0 : _a2.delete(path15)) && event[typeOfEventToRemove].size === 0) {
            event[typeOfEventToRemove] = void 0;
          }
        };
        const aggregateEvent = () => {
          if (!event) {
            this.watchEvents.set(id, event = {});
          }
          (event[eventType] ??= /* @__PURE__ */ new Set()).add(path15);
        };
        switch (eventType) {
          case "created":
            removeEvent("deleted");
            removeEvent("updated");
            aggregateEvent();
            break;
          case "deleted":
            removeEvent("created");
            removeEvent("updated");
            aggregateEvent();
            break;
          case "updated":
            if ((_a = event == null ? void 0 : event.created) == null ? void 0 : _a.has(path15)) {
              return;
            }
            removeEvent("deleted");
            aggregateEvent();
            break;
        }
        this.scheduleExecuteWatchChangeRequest();
      }
      createFileSystemWatcher(id, pattern, ignoreChangeEvents) {
        const disposable = new DisposableStore();
        const watcher = disposable.add(workspace.createFileSystemWatcher(pattern, void 0, ignoreChangeEvents));
        disposable.add(watcher.onDidChange(
          (changeFile) => this.addWatchEvent(id, "updated", changeFile.fsPath)
        ));
        disposable.add(watcher.onDidCreate(
          (createFile) => this.addWatchEvent(id, "created", createFile.fsPath)
        ));
        disposable.add(watcher.onDidDelete(
          (deletedFile) => this.addWatchEvent(id, "deleted", deletedFile.fsPath)
        ));
        disposable.add({
          dispose: () => {
            this.watchEvents.delete(id);
            this.watches.delete(id);
          }
        });
        if (this.watches.has(id)) {
          this.closeFileSystemWatcher(id);
        }
        this.watches.set(id, disposable);
      }
      closeFileSystemWatcher(id) {
        const existing = this.watches.get(id);
        existing == null ? void 0 : existing.dispose();
      }
      dispatchTelemetryEvent(telemetryData) {
        const properties = /* @__PURE__ */ Object.create(null);
        switch (telemetryData.telemetryEventName) {
          case "typingsInstalled": {
            const typingsInstalledPayload = telemetryData.payload;
            properties["installedPackages"] = typingsInstalledPayload.installedPackages;
            if (typeof typingsInstalledPayload.installSuccess === "boolean") {
              properties["installSuccess"] = typingsInstalledPayload.installSuccess.toString();
            }
            if (typeof typingsInstalledPayload.typingsInstallerVersion === "string") {
              properties["typingsInstallerVersion"] = typingsInstalledPayload.typingsInstallerVersion;
            }
            break;
          }
          default: {
            const payload = telemetryData.payload;
            if (payload) {
              Object.keys(payload).forEach((key) => {
                try {
                  if (payload.hasOwnProperty(key)) {
                    properties[key] = typeof payload[key] === "string" ? payload[key] : JSON.stringify(payload[key]);
                  }
                } catch (e) {
                }
              });
            }
            break;
          }
        }
        if (telemetryData.telemetryEventName === "projectInfo") {
          if (this.serverState.type === 1 /* Running */) {
            this.serverState.updateTsserverVersion(properties["version"]);
          }
        }
        this.telemetryReporter.logTelemetry(telemetryData.telemetryEventName, properties);
      }
      configurePlugin(pluginName, configuration) {
        this.executeWithoutWaitingForResponse("configurePlugin", { pluginName, configuration });
      }
    };
    ServerInitializingIndicator = class extends Disposable {
      constructor(client) {
        super();
        this.client = client;
      }
      reset() {
        if (this._task) {
          this._task.resolve();
          this._task = void 0;
        }
      }
      /**
       * Signal that a project has started loading.
       */
      startedLoadingProject(projectName) {
        this.reset();
        const projectDisplayName = this.getProjectDisplayName(projectName);
        window.withProgress({
          location: 10 /* Window */,
          title: l10n.t("Initializing '{0}'", projectDisplayName)
        }, () => new Promise((resolve) => {
          this._task = { project: projectName, resolve };
        }));
      }
      getProjectDisplayName(projectName) {
        const projectUri = this.client.toResource(projectName);
        const relPath = workspace.asRelativePath(projectUri);
        const maxDisplayLength = 60;
        if (relPath.length > maxDisplayLength) {
          return "..." + relPath.slice(-maxDisplayLength);
        }
        return relPath;
      }
      startedLoadingFile(fileName, task) {
        if (!this._task) {
          window.withProgress({
            location: 10 /* Window */,
            title: l10n.t("Analyzing '{0}' and its dependencies", path9.basename(fileName))
          }, () => task);
        }
      }
      finishedLoadingProject(projectName) {
        if (this._task && this._task.project === projectName) {
          this._task.resolve();
          this._task = void 0;
        }
      }
    };
  }
});

// src/typescript-language-features/src/ui/intellisenseStatus.ts
var IntellisenseState, IntellisenseStatus;
var init_intellisenseStatus = __esm({
  "src/typescript-language-features/src/ui/intellisenseStatus.ts"() {
    "use strict";
    init_shims();
    init_languageIds();
    init_tsconfig();
    init_typescriptService();
    init_dispose();
    ((IntellisenseState2) => {
      let Type;
      ((Type2) => {
        Type2[Type2["None"] = 0] = "None";
        Type2[Type2["Pending"] = 1] = "Pending";
        Type2[Type2["Resolved"] = 2] = "Resolved";
        Type2[Type2["SyntaxOnly"] = 3] = "SyntaxOnly";
      })(Type = IntellisenseState2.Type || (IntellisenseState2.Type = {}));
      IntellisenseState2.None = Object.freeze({ type: 0 /* None */ });
      IntellisenseState2.SyntaxOnly = Object.freeze({ type: 3 /* SyntaxOnly */ });
      class Pending {
        constructor(resource, projectType) {
          this.resource = resource;
          this.projectType = projectType;
          this.type = 1 /* Pending */;
          this.cancellation = new CancellationTokenSource();
        }
      }
      IntellisenseState2.Pending = Pending;
      class Resolved {
        constructor(resource, projectType, configFile) {
          this.resource = resource;
          this.projectType = projectType;
          this.configFile = configFile;
          this.type = 2 /* Resolved */;
        }
      }
      IntellisenseState2.Resolved = Resolved;
    })(IntellisenseState || (IntellisenseState = {}));
    IntellisenseStatus = class extends Disposable {
      constructor(_client, commandManager, _activeTextEditorManager) {
        super();
        this._client = _client;
        this._activeTextEditorManager = _activeTextEditorManager;
        this.openOpenConfigCommandId = "_typescript.openConfig";
        this.createOrOpenConfigCommandId = "_typescript.createOrOpenConfig";
        this._ready = false;
        this._state = IntellisenseState.None;
        commandManager.register({
          id: this.openOpenConfigCommandId,
          execute: async (...[root, projectType]) => {
            if (this._state.type === 2 /* Resolved */) {
              await openProjectConfigOrPromptToCreate(projectType, this._client, root, this._state.configFile);
            } else if (this._state.type === 1 /* Pending */) {
              await openProjectConfigForFile(projectType, this._client, this._state.resource);
            }
          }
        });
        commandManager.register({
          id: this.createOrOpenConfigCommandId,
          execute: async (...[root, projectType]) => {
            await openOrCreateConfig(this._client.apiVersion, projectType, root, this._client.configuration);
          }
        });
        _activeTextEditorManager.onDidChangeActiveJsTsEditor(this.updateStatus, this, this._disposables);
        this._client.onReady(() => {
          this._ready = true;
          this.updateStatus();
        });
      }
      dispose() {
        var _a;
        super.dispose();
        (_a = this._statusItem) == null ? void 0 : _a.dispose();
      }
      async updateStatus() {
        var _a;
        const doc = (_a = this._activeTextEditorManager.activeJsTsEditor) == null ? void 0 : _a.document;
        if (!doc || !isSupportedLanguageMode(doc)) {
          this.updateState(IntellisenseState.None);
          return;
        }
        if (!this._client.hasCapabilityForResource(doc.uri, 2 /* Semantic */)) {
          this.updateState(IntellisenseState.SyntaxOnly);
          return;
        }
        const file2 = this._client.toOpenTsFilePath(doc, { suppressAlertOnFailure: true });
        if (!file2) {
          this.updateState(IntellisenseState.None);
          return;
        }
        if (!this._ready) {
          return;
        }
        const projectType = isTypeScriptDocument(doc) ? 0 /* TypeScript */ : 1 /* JavaScript */;
        const pendingState = new IntellisenseState.Pending(doc.uri, projectType);
        this.updateState(pendingState);
        const response = await this._client.execute("projectInfo", { file: file2, needFileNameList: false }, pendingState.cancellation.token);
        if (response.type === "response" && response.body) {
          if (this._state === pendingState) {
            this.updateState(new IntellisenseState.Resolved(doc.uri, projectType, response.body.configFileName));
          }
        }
      }
      updateState(newState) {
        var _a;
        if (this._state === newState) {
          return;
        }
        if (this._state.type === 1 /* Pending */) {
          this._state.cancellation.cancel();
          this._state.cancellation.dispose();
        }
        this._state = newState;
        switch (this._state.type) {
          case 0 /* None */: {
            (_a = this._statusItem) == null ? void 0 : _a.dispose();
            this._statusItem = void 0;
            break;
          }
          case 1 /* Pending */: {
            const statusItem = this.ensureStatusItem();
            statusItem.severity = 0 /* Information */;
            statusItem.text = l10n.t("Loading IntelliSense status");
            statusItem.detail = void 0;
            statusItem.command = void 0;
            statusItem.busy = true;
            break;
          }
          case 2 /* Resolved */: {
            const noConfigFileText = this._state.projectType === 0 /* TypeScript */ ? l10n.t("No tsconfig") : l10n.t("No jsconfig");
            const rootPath = this._client.getWorkspaceRootForResource(this._state.resource);
            if (!rootPath) {
              if (this._statusItem) {
                this._statusItem.text = noConfigFileText;
                this._statusItem.detail = !workspace.workspaceFolders ? l10n.t("No opened folders") : l10n.t("File is not part opened folders");
                this._statusItem.busy = false;
              }
              return;
            }
            const statusItem = this.ensureStatusItem();
            statusItem.busy = false;
            statusItem.detail = void 0;
            statusItem.severity = 0 /* Information */;
            if (isImplicitProjectConfigFile(this._state.configFile)) {
              statusItem.text = noConfigFileText;
              statusItem.detail = void 0;
              statusItem.command = {
                command: this.createOrOpenConfigCommandId,
                title: this._state.projectType === 0 /* TypeScript */ ? l10n.t("Configure tsconfig") : l10n.t("Configure jsconfig"),
                arguments: [rootPath, this._state.projectType]
              };
            } else {
              statusItem.text = workspace.asRelativePath(this._state.configFile);
              statusItem.detail = void 0;
              statusItem.command = {
                command: this.openOpenConfigCommandId,
                title: l10n.t("Open config file"),
                arguments: [rootPath, this._state.projectType]
              };
            }
            break;
          }
          case 3 /* SyntaxOnly */: {
            const statusItem = this.ensureStatusItem();
            statusItem.severity = 1 /* Warning */;
            statusItem.text = l10n.t("Partial Mode");
            statusItem.detail = l10n.t("Project Wide IntelliSense not available");
            statusItem.busy = false;
            statusItem.command = {
              title: l10n.t("Learn More"),
              command: "vscode.open",
              arguments: [
                Uri.parse("https://aka.ms/vscode/jsts/partial-mode")
              ]
            };
            break;
          }
        }
      }
      ensureStatusItem() {
        if (!this._statusItem) {
          this._statusItem = languages.createLanguageStatusItem("typescript.projectStatus", jsTsLanguageModes);
          this._statusItem.name = l10n.t("JS/TS IntelliSense Status");
        }
        return this._statusItem;
      }
    };
  }
});

// src/typescript-language-features/src/ui/typingsStatus.ts
var typingsInstallTimeout, TypingsStatus, AtaProgressReporter;
var init_typingsStatus = __esm({
  "src/typescript-language-features/src/ui/typingsStatus.ts"() {
    "use strict";
    init_shims();
    init_dispose();
    typingsInstallTimeout = 30 * 1e3;
    TypingsStatus = class extends Disposable {
      constructor(client) {
        super();
        this._acquiringTypings = /* @__PURE__ */ new Map();
        this._client = client;
        this._register(
          this._client.onDidBeginInstallTypings((event) => this.onBeginInstallTypings(event.eventId))
        );
        this._register(
          this._client.onDidEndInstallTypings((event) => this.onEndInstallTypings(event.eventId))
        );
      }
      dispose() {
        super.dispose();
        for (const timeout of this._acquiringTypings.values()) {
          clearTimeout(timeout);
        }
      }
      get isAcquiringTypings() {
        return Object.keys(this._acquiringTypings).length > 0;
      }
      onBeginInstallTypings(eventId) {
        if (this._acquiringTypings.has(eventId)) {
          return;
        }
        this._acquiringTypings.set(eventId, setTimeout(() => {
          this.onEndInstallTypings(eventId);
        }, typingsInstallTimeout));
      }
      onEndInstallTypings(eventId) {
        const timer = this._acquiringTypings.get(eventId);
        if (timer) {
          clearTimeout(timer);
        }
        this._acquiringTypings.delete(eventId);
      }
    };
    AtaProgressReporter = class extends Disposable {
      constructor(client) {
        super();
        this._promises = /* @__PURE__ */ new Map();
        this._register(client.onDidBeginInstallTypings((e) => this._onBegin(e.eventId)));
        this._register(client.onDidEndInstallTypings((e) => this._onEndOrTimeout(e.eventId)));
        this._register(client.onTypesInstallerInitializationFailed((_) => this.onTypesInstallerInitializationFailed()));
      }
      dispose() {
        super.dispose();
        this._promises.forEach((value) => value());
      }
      _onBegin(eventId) {
        const handle = setTimeout(() => this._onEndOrTimeout(eventId), typingsInstallTimeout);
        const promise = new Promise((resolve) => {
          this._promises.set(eventId, () => {
            clearTimeout(handle);
            resolve();
          });
        });
        window.withProgress({
          location: 10 /* Window */,
          title: l10n.t("Fetching data for better TypeScript IntelliSense")
        }, () => promise);
      }
      _onEndOrTimeout(eventId) {
        const resolve = this._promises.get(eventId);
        if (resolve) {
          this._promises.delete(eventId);
          resolve();
        }
      }
      async onTypesInstallerInitializationFailed() {
        const config3 = workspace.getConfiguration("typescript");
        if (config3.get("check.npmIsInstalled", true)) {
          const dontShowAgain = {
            title: l10n.t("Don't Show Again")
          };
          const selected = await window.showWarningMessage(
            l10n.t(
              "Could not install typings files for JavaScript language features. Please ensure that NPM is installed, or configure 'typescript.npm' in your user settings. Alternatively, check the [documentation]({0}) to learn more.",
              "https://go.microsoft.com/fwlink/?linkid=847635"
            ),
            dontShowAgain
          );
          if (selected === dontShowAgain) {
            config3.update("check.npmIsInstalled", false, true);
          }
        }
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/updatePathsOnRename.ts
var updatePathsOnRename_exports = {};
__export(updatePathsOnRename_exports, {
  register: () => register31
});
import * as path10 from "path";
async function isDirectory(resource) {
  try {
    return (await workspace.fs.stat(resource)).type === 2 /* Directory */;
  } catch {
    return false;
  }
}
function register31(client, fileConfigurationManager, handles) {
  return conditionalRegistration([
    requireSomeCapability(client, 2 /* Semantic */)
  ], () => {
    return new UpdateImportsOnFileRenameHandler(client, fileConfigurationManager, handles);
  });
}
var updateImportsOnFileMoveName, UpdateImportsOnFileRenameHandler;
var init_updatePathsOnRename = __esm({
  "src/typescript-language-features/src/languageFeatures/updatePathsOnRename.ts"() {
    "use strict";
    init_shims();
    init_fileSchemes();
    init_languageDescription();
    init_typeConverters();
    init_typescriptService();
    init_async();
    init_cancellation();
    init_dispose();
    init_dependentRegistration();
    updateImportsOnFileMoveName = "updateImportsOnFileMove.enabled";
    UpdateImportsOnFileRenameHandler = class extends Disposable {
      constructor(client, fileConfigurationManager, _handles) {
        super();
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
        this._handles = _handles;
        this._delayer = new Delayer(50);
        this._pendingRenames = /* @__PURE__ */ new Set();
        this._register(workspace.onDidRenameFiles(async (e) => {
          for (const { newUri, oldUri } of e.files) {
            const newFilePath = this.client.toTsFilePath(newUri);
            if (!newFilePath) {
              continue;
            }
            const oldFilePath = this.client.toTsFilePath(oldUri);
            if (!oldFilePath) {
              continue;
            }
            const config3 = this.getConfiguration(newUri);
            const setting = config3.get(updateImportsOnFileMoveName);
            if (setting === "never" /* Never */) {
              continue;
            }
            const jsTsFileThatIsBeingMoved = await this.getJsTsFileBeingMoved(newUri);
            if (!jsTsFileThatIsBeingMoved || !this.client.toTsFilePath(jsTsFileThatIsBeingMoved)) {
              continue;
            }
            this._pendingRenames.add({ oldUri, newUri, newFilePath, oldFilePath, jsTsFileThatIsBeingMoved });
            this._delayer.trigger(() => {
              window.withProgress({
                location: 10 /* Window */,
                title: l10n.t("Checking for update of JS/TS imports")
              }, () => this.flushRenames());
            });
          }
        }));
      }
      async flushRenames() {
        const renames = Array.from(this._pendingRenames);
        this._pendingRenames.clear();
        for (const group of this.groupRenames(renames)) {
          const edits = new WorkspaceEdit();
          const resourcesBeingRenamed = [];
          for (const { oldUri, newUri, newFilePath, oldFilePath, jsTsFileThatIsBeingMoved } of group) {
            this.client.bufferSyncSupport.closeResource(oldUri);
            if (await this.withEditsForFileRename(edits, oldFilePath, newFilePath)) {
              resourcesBeingRenamed.push(newUri);
            }
          }
          if (edits.size) {
            if (await this.confirmActionWithUser(resourcesBeingRenamed)) {
              await workspace.applyEdit(edits, { isRefactoring: true });
            }
          }
        }
      }
      async confirmActionWithUser(newResources) {
        if (!newResources.length) {
          return false;
        }
        const config3 = this.getConfiguration(newResources[0]);
        const setting = config3.get(updateImportsOnFileMoveName);
        switch (setting) {
          case "always" /* Always */:
            return true;
          case "never" /* Never */:
            return false;
          case "prompt" /* Prompt */:
          default:
            return this.promptUser(newResources);
        }
      }
      getConfiguration(resource) {
        return workspace.getConfiguration(doesResourceLookLikeATypeScriptFile(resource) ? "typescript" : "javascript", resource);
      }
      async promptUser(newResources) {
        if (!newResources.length) {
          return false;
        }
        const rejectItem = {
          title: l10n.t("No"),
          isCloseAffordance: true
        };
        const acceptItem = {
          title: l10n.t("Yes")
        };
        const alwaysItem = {
          title: l10n.t("Always")
        };
        const neverItem = {
          title: l10n.t("Never")
        };
        const response = await window.showInformationMessage(
          newResources.length === 1 ? l10n.t("Update imports for '{0}'?", path10.basename(newResources[0].fsPath)) : this.getConfirmMessage(l10n.t("Update imports for the following {0} files?", newResources.length), newResources),
          {
            modal: true
          },
          rejectItem,
          acceptItem,
          alwaysItem,
          neverItem
        );
        switch (response) {
          case acceptItem: {
            return true;
          }
          case rejectItem: {
            return false;
          }
          case alwaysItem: {
            const config3 = this.getConfiguration(newResources[0]);
            config3.update(
              updateImportsOnFileMoveName,
              "always" /* Always */,
              this.getConfigTargetScope(config3, updateImportsOnFileMoveName)
            );
            return true;
          }
          case neverItem: {
            const config3 = this.getConfiguration(newResources[0]);
            config3.update(
              updateImportsOnFileMoveName,
              "never" /* Never */,
              this.getConfigTargetScope(config3, updateImportsOnFileMoveName)
            );
            return false;
          }
          default: {
            return false;
          }
        }
      }
      async getJsTsFileBeingMoved(resource) {
        if (resource.scheme !== file) {
          return void 0;
        }
        if (await isDirectory(resource)) {
          return resource;
        }
        return await this._handles(resource) ? resource : void 0;
      }
      async withEditsForFileRename(edits, oldFilePath, newFilePath) {
        const response = await this.client.interruptGetErr(() => {
          const args = {
            oldFilePath,
            newFilePath
          };
          return this.client.execute("getEditsForFileRename", args, nulToken);
        });
        if (response.type !== "response" || !response.body.length) {
          return false;
        }
        WorkspaceEdit2.withFileCodeEdits(edits, this.client, response.body);
        return true;
      }
      groupRenames(renames) {
        var _a;
        const groups = /* @__PURE__ */ new Map();
        for (const rename of renames) {
          const key = `${(_a = this.client.getWorkspaceRootForResource(rename.jsTsFileThatIsBeingMoved)) == null ? void 0 : _a.fsPath}@@@${doesResourceLookLikeATypeScriptFile(rename.jsTsFileThatIsBeingMoved)}`;
          if (!groups.has(key)) {
            groups.set(key, /* @__PURE__ */ new Set());
          }
          groups.get(key).add(rename);
        }
        return groups.values();
      }
      getConfirmMessage(start, resourcesToConfirm) {
        const MAX_CONFIRM_FILES = 10;
        const paths = [start];
        paths.push("");
        paths.push(...resourcesToConfirm.slice(0, MAX_CONFIRM_FILES).map((r) => path10.basename(r.fsPath)));
        if (resourcesToConfirm.length > MAX_CONFIRM_FILES) {
          if (resourcesToConfirm.length - MAX_CONFIRM_FILES === 1) {
            paths.push(l10n.t("...1 additional file not shown"));
          } else {
            paths.push(l10n.t("...{0} additional files not shown", resourcesToConfirm.length - MAX_CONFIRM_FILES));
          }
        }
        paths.push("");
        return paths.join("\n");
      }
      getConfigTargetScope(config3, settingsName) {
        const inspected = config3.inspect(settingsName);
        if (inspected == null ? void 0 : inspected.workspaceFolderValue) {
          return 3 /* WorkspaceFolder */;
        }
        if (inspected == null ? void 0 : inspected.workspaceValue) {
          return 2 /* Workspace */;
        }
        return 1 /* Global */;
      }
    };
  }
});

// src/typescript-language-features/src/languageFeatures/workspaceSymbols.ts
var workspaceSymbols_exports = {};
__export(workspaceSymbols_exports, {
  register: () => register32
});
function getSymbolKind2(item) {
  switch (item.kind) {
    case Kind.method:
      return 5 /* Method */;
    case Kind.enum:
      return 9 /* Enum */;
    case Kind.enumMember:
      return 21 /* EnumMember */;
    case Kind.function:
      return 11 /* Function */;
    case Kind.class:
      return 4 /* Class */;
    case Kind.interface:
      return 10 /* Interface */;
    case Kind.type:
      return 4 /* Class */;
    case Kind.memberVariable:
      return 7 /* Field */;
    case Kind.memberGetAccessor:
      return 7 /* Field */;
    case Kind.memberSetAccessor:
      return 7 /* Field */;
    case Kind.variable:
      return 12 /* Variable */;
    default:
      return 12 /* Variable */;
  }
}
function register32(client, modeIds) {
  return languages.registerWorkspaceSymbolProvider(
    new TypeScriptWorkspaceSymbolProvider(client, modeIds)
  );
}
var TypeScriptWorkspaceSymbolProvider;
var init_workspaceSymbols = __esm({
  "src/typescript-language-features/src/languageFeatures/workspaceSymbols.ts"() {
    "use strict";
    init_shims();
    init_fileSchemes();
    init_languageDescription();
    init_api2();
    init_modifiers();
    init_protocol_const();
    init_typeConverters();
    init_arrays();
    TypeScriptWorkspaceSymbolProvider = class _TypeScriptWorkspaceSymbolProvider {
      constructor(client, modeIds) {
        this.client = client;
        this.modeIds = modeIds;
      }
      async provideWorkspaceSymbols(search, token) {
        let file2;
        if (this.searchAllOpenProjects) {
          file2 = void 0;
        } else {
          const document = this.getDocument();
          file2 = document ? await this.toOpenedFiledPath(document) : void 0;
          if (!file2 && this.client.apiVersion.lt(API.v390)) {
            return [];
          }
        }
        const args = {
          file: file2,
          searchValue: search,
          maxResultCount: 256
        };
        const response = await this.client.execute("navto", args, token);
        if (response.type !== "response" || !response.body) {
          return [];
        }
        return coalesce(response.body.map((item) => this.toSymbolInformation(item)));
      }
      get searchAllOpenProjects() {
        return this.client.apiVersion.gte(API.v390) && workspace.getConfiguration("typescript").get("workspaceSymbols.scope", "allOpenProjects") === "allOpenProjects";
      }
      async toOpenedFiledPath(document) {
        var _a;
        if (document.uri.scheme === git) {
          try {
            const path15 = Uri.file((_a = JSON.parse(document.uri.query)) == null ? void 0 : _a.path);
            if (doesResourceLookLikeATypeScriptFile(path15) || doesResourceLookLikeAJavaScriptFile(path15)) {
              const document2 = await workspace.openTextDocument(path15);
              return this.client.toOpenTsFilePath(document2);
            }
          } catch {
          }
        }
        return this.client.toOpenTsFilePath(document);
      }
      toSymbolInformation(item) {
        if (item.kind === "alias" && !item.containerName) {
          return;
        }
        const uri = this.client.toResource(item.file);
        if (isOfScheme(uri, chatCodeBlock)) {
          return;
        }
        const label = _TypeScriptWorkspaceSymbolProvider.getLabel(item);
        const info = new SymbolInformation(
          label,
          getSymbolKind2(item),
          item.containerName || "",
          Location2.fromTextSpan(uri, item)
        );
        const kindModifiers = item.kindModifiers ? parseKindModifier(item.kindModifiers) : void 0;
        if (kindModifiers == null ? void 0 : kindModifiers.has(KindModifiers.deprecated)) {
          info.tags = [1 /* Deprecated */];
        }
        return info;
      }
      static getLabel(item) {
        const label = item.name;
        if (item.kind === "method" || item.kind === "function") {
          return label + "()";
        }
        return label;
      }
      getDocument() {
        var _a;
        const activeDocument = (_a = window.activeTextEditor) == null ? void 0 : _a.document;
        if (activeDocument) {
          if (this.modeIds.includes(activeDocument.languageId)) {
            return activeDocument;
          }
        }
        const documents = workspace.textDocuments;
        for (const document of documents) {
          if (this.modeIds.includes(document.languageId)) {
            return document;
          }
        }
        return void 0;
      }
    };
  }
});

// src/typescript-language-features/src/typeScriptServiceClientHost.ts
var styleCheckDiagnostics, TypeScriptServiceClientHost;
var init_typeScriptServiceClientHost = __esm({
  "src/typescript-language-features/src/typeScriptServiceClientHost.ts"() {
    "use strict";
    init_shims();
    init_languageDescription();
    init_fileConfigurationManager();
    init_languageProvider();
    init_logLevelMonitor();
    init_errorCodes();
    init_protocol_const();
    init_typeConverters();
    init_typescriptServiceClient();
    init_intellisenseStatus();
    init_typingsStatus();
    init_arrays();
    init_dispose();
    styleCheckDiagnostics = /* @__PURE__ */ new Set([
      ...variableDeclaredButNeverUsed,
      ...propertyDeclaretedButNeverUsed,
      ...allImportsAreUnused,
      ...unreachableCode,
      ...unusedLabel,
      ...fallThroughCaseInSwitch,
      ...notAllCodePathsReturnAValue
    ]);
    TypeScriptServiceClientHost = class extends Disposable {
      constructor(descriptions, context, onCaseInsensitiveFileSystem2, services, onCompletionAccepted) {
        super();
        this.languages = [];
        this.languagePerId = /* @__PURE__ */ new Map();
        this.reportStyleCheckAsWarnings = true;
        this.commandManager = services.commandManager;
        const allModeIds = this.getAllModeIds(descriptions, services.pluginManager);
        this.client = this._register(new TypeScriptServiceClient(
          context,
          onCaseInsensitiveFileSystem2,
          services,
          allModeIds
        ));
        this.client.onDiagnosticsReceived(({ kind, resource, diagnostics, spans }) => {
          this.diagnosticsReceived(kind, resource, diagnostics, spans);
        }, null, this._disposables);
        this.client.onConfigDiagnosticsReceived((diag) => this.configFileDiagnosticsReceived(diag), null, this._disposables);
        this.client.onResendModelsRequested(() => this.populateService(), null, this._disposables);
        this._register(new IntellisenseStatus(this.client, services.commandManager, services.activeJsTsEditorTracker));
        this._register(new AtaProgressReporter(this.client));
        this.typingsStatus = this._register(new TypingsStatus(this.client));
        this.fileConfigurationManager = this._register(new FileConfigurationManager(this.client, onCaseInsensitiveFileSystem2));
        for (const description2 of descriptions) {
          const manager = new LanguageProvider(this.client, description2, this.commandManager, this.client.telemetryReporter, this.typingsStatus, this.fileConfigurationManager, onCompletionAccepted);
          this.languages.push(manager);
          this._register(manager);
          this.languagePerId.set(description2.id, manager);
        }
        Promise.resolve().then(() => (init_updatePathsOnRename(), updatePathsOnRename_exports)).then((module) => this._register(module.register(this.client, this.fileConfigurationManager, (uri) => this.handles(uri))));
        Promise.resolve().then(() => (init_workspaceSymbols(), workspaceSymbols_exports)).then((module) => this._register(module.register(this.client, allModeIds)));
        this.client.ensureServiceStarted();
        this.client.onReady(() => {
          const languages2 = /* @__PURE__ */ new Set();
          for (const plugin of services.pluginManager.plugins) {
            if (plugin.configNamespace && plugin.languages.length) {
              this.registerExtensionLanguageProvider({
                id: plugin.configNamespace,
                languageIds: Array.from(plugin.languages),
                diagnosticSource: "ts-plugin",
                diagnosticLanguage: 1 /* TypeScript */,
                diagnosticOwner: "typescript",
                isExternal: true,
                standardFileExtensions: []
              }, onCompletionAccepted);
            } else {
              for (const language of plugin.languages) {
                languages2.add(language);
              }
            }
          }
          if (languages2.size) {
            this.registerExtensionLanguageProvider({
              id: "typescript-plugins",
              languageIds: Array.from(languages2.values()),
              diagnosticSource: "ts-plugin",
              diagnosticLanguage: 1 /* TypeScript */,
              diagnosticOwner: "typescript",
              isExternal: true,
              standardFileExtensions: []
            }, onCompletionAccepted);
          }
        });
        this.client.onTsServerStarted(() => {
          this.triggerAllDiagnostics();
        });
        workspace.onDidChangeConfiguration(this.configurationChanged, this, this._disposables);
        this.configurationChanged();
        this._register(new LogLevelMonitor(context));
      }
      registerExtensionLanguageProvider(description2, onCompletionAccepted) {
        const manager = new LanguageProvider(this.client, description2, this.commandManager, this.client.telemetryReporter, this.typingsStatus, this.fileConfigurationManager, onCompletionAccepted);
        this.languages.push(manager);
        this._register(manager);
        this.languagePerId.set(description2.id, manager);
      }
      getAllModeIds(descriptions, pluginManager) {
        return [
          ...descriptions.map((x) => x.languageIds),
          ...pluginManager.plugins.map((x) => x.languages)
        ].flat();
      }
      get serviceClient() {
        return this.client;
      }
      reloadProjects() {
        this.client.executeWithoutWaitingForResponse("reloadProjects", null);
        this.triggerAllDiagnostics();
      }
      async handles(resource) {
        const provider = await this.findLanguage(resource);
        if (provider) {
          return true;
        }
        return this.client.bufferSyncSupport.handles(resource);
      }
      configurationChanged() {
        const typescriptConfig = workspace.getConfiguration("typescript");
        this.reportStyleCheckAsWarnings = typescriptConfig.get("reportStyleChecksAsWarnings", true);
      }
      async findLanguage(resource) {
        try {
          for (const language of this.languages) {
            if (language.handlesUri(resource)) {
              return language;
            }
          }
          if (this.client.toOpenTsFilePath(resource)) {
            const doc = await workspace.openTextDocument(resource);
            return this.languages.find((language) => language.handlesDocument(doc));
          }
        } catch {
          return void 0;
        }
      }
      triggerAllDiagnostics() {
        for (const language of this.languagePerId.values()) {
          language.triggerAllDiagnostics();
        }
      }
      populateService() {
        this.fileConfigurationManager.reset();
        for (const language of this.languagePerId.values()) {
          language.reInitialize();
        }
      }
      async diagnosticsReceived(kind, resource, diagnostics, spans) {
        const language = await this.findLanguage(resource);
        if (language) {
          language.diagnosticsReceived(
            kind,
            resource,
            this.createMarkerDatas(diagnostics, language.diagnosticSource),
            spans == null ? void 0 : spans.map((span) => Range4.fromTextSpan(span))
          );
        }
      }
      configFileDiagnosticsReceived(event) {
        const body = event.body;
        if (!(body == null ? void 0 : body.diagnostics) || !body.configFile) {
          return;
        }
        this.findLanguage(this.client.toResource(body.configFile)).then((language) => {
          language == null ? void 0 : language.configFileDiagnosticsReceived(this.client.toResource(body.configFile), body.diagnostics.map((tsDiag) => {
            const range = tsDiag.start && tsDiag.end ? Range4.fromTextSpan(tsDiag) : new Range(0, 0, 0, 1);
            const diagnostic = new Diagnostic(range, tsDiag.text, this.getDiagnosticSeverity(tsDiag));
            diagnostic.source = language.diagnosticSource;
            return diagnostic;
          }));
        });
      }
      createMarkerDatas(diagnostics, source) {
        return diagnostics.map((tsDiag) => this.tsDiagnosticToVsDiagnostic(tsDiag, source));
      }
      tsDiagnosticToVsDiagnostic(diagnostic, source) {
        const { start, end, text } = diagnostic;
        const range = new Range(Position3.fromLocation(start), Position3.fromLocation(end));
        const converted = new Diagnostic(range, text, this.getDiagnosticSeverity(diagnostic));
        converted.source = diagnostic.source || source;
        if (diagnostic.code) {
          converted.code = diagnostic.code;
        }
        const relatedInformation = diagnostic.relatedInformation;
        if (relatedInformation) {
          converted.relatedInformation = coalesce(relatedInformation.map((info) => {
            const span = info.span;
            if (!span) {
              return void 0;
            }
            return new DiagnosticRelatedInformation(Location2.fromTextSpan(this.client.toResource(span.file), span), info.message);
          }));
        }
        const tags = [];
        if (diagnostic.reportsUnnecessary) {
          tags.push(1 /* Unnecessary */);
        }
        if (diagnostic.reportsDeprecated) {
          tags.push(2 /* Deprecated */);
        }
        converted.tags = tags.length ? tags : void 0;
        const resultConverted = converted;
        resultConverted.reportUnnecessary = diagnostic.reportsUnnecessary;
        resultConverted.reportDeprecated = diagnostic.reportsDeprecated;
        return resultConverted;
      }
      getDiagnosticSeverity(diagnostic) {
        if (this.reportStyleCheckAsWarnings && this.isStyleCheckDiagnostic(diagnostic.code) && diagnostic.category === DiagnosticCategory.error) {
          return 1 /* Warning */;
        }
        switch (diagnostic.category) {
          case DiagnosticCategory.error:
            return 0 /* Error */;
          case DiagnosticCategory.warning:
            return 1 /* Warning */;
          case DiagnosticCategory.suggestion:
            return 3 /* Hint */;
          default:
            return 0 /* Error */;
        }
      }
      isStyleCheckDiagnostic(code) {
        return typeof code === "number" && styleCheckDiagnostics.has(code);
      }
    };
  }
});

// src/typescript-language-features/src/lazyClientHost.ts
function createLazyClientHost(context, onCaseInsensitiveFileSystem2, services, onCompletionAccepted) {
  return lazy(() => {
    const clientHost = new TypeScriptServiceClientHost(
      standardLanguageDescriptions,
      context,
      onCaseInsensitiveFileSystem2,
      services,
      onCompletionAccepted
    );
    context.subscriptions.push(clientHost);
    return clientHost;
  });
}
function lazilyActivateClient(lazyClientHost, pluginManager, activeJsTsEditorTracker, onActivate = () => Promise.resolve()) {
  onActivate().then(() => {
    void lazyClientHost.value;
  });
  return Disposable4.from();
}
var init_lazyClientHost = __esm({
  "src/typescript-language-features/src/lazyClientHost.ts"() {
    "use strict";
    init_shims();
    init_typeScriptServiceClientHost();
    init_fileSchemes();
    init_languageDescription();
    init_lazy();
  }
});

// src/typescript-language-features/src/tsServer/cancellation.electron.ts
import * as fs3 from "fs";
var NodeRequestCanceller, nodeRequestCancellerFactory;
var init_cancellation_electron = __esm({
  "src/typescript-language-features/src/tsServer/cancellation.electron.ts"() {
    "use strict";
    init_temp_electron();
    NodeRequestCanceller = class {
      constructor(_serverId, _tracer) {
        this._serverId = _serverId;
        this._tracer = _tracer;
        this.cancellationPipeName = getTempFile("tscancellation");
      }
      tryCancelOngoingRequest(seq) {
        if (!this.cancellationPipeName) {
          return false;
        }
        this._tracer.trace(this._serverId, `TypeScript Server: trying to cancel ongoing request with sequence number ${seq}`);
        try {
          fs3.writeFileSync(this.cancellationPipeName + seq, "");
        } catch {
        }
        return true;
      }
    };
    nodeRequestCancellerFactory = new class {
      create(serverId, tracer) {
        return new NodeRequestCanceller(serverId, tracer);
      }
    }();
  }
});

// src/typescript-language-features/src/tsServer/logDirectoryProvider.electron.ts
import * as fs4 from "fs";
import * as path11 from "path";
var NodeLogDirectoryProvider;
var init_logDirectoryProvider_electron = __esm({
  "src/typescript-language-features/src/tsServer/logDirectoryProvider.electron.ts"() {
    "use strict";
    init_shims();
    init_memoize();
    NodeLogDirectoryProvider = class {
      constructor(context) {
        this.context = context;
      }
      getNewLogDirectory() {
        const root = this.logDirectory();
        if (root) {
          try {
            return Uri.file(fs4.mkdtempSync(path11.join(root, `tsserver-log-`)));
          } catch (e) {
            return void 0;
          }
        }
        return void 0;
      }
      logDirectory() {
        try {
          const path15 = this.context.logPath;
          if (!fs4.existsSync(path15)) {
            fs4.mkdirSync(path15);
          }
          return this.context.logPath;
        } catch {
          return void 0;
        }
      }
    };
    __decorateClass([
      memoize
    ], NodeLogDirectoryProvider.prototype, "logDirectory", 1);
  }
});

// src/typescript-language-features/src/tsServer/serverProcess.electron.ts
import * as child_process from "child_process";
import * as fs5 from "fs";
import * as path12 from "path";
function generatePatchedEnv(env2, modulePath, hasExecPath) {
  const newEnv = Object.assign({}, env2);
  if (!hasExecPath) {
    newEnv["ELECTRON_RUN_AS_NODE"] = "1";
  }
  newEnv["NODE_PATH"] = path12.join(modulePath, "..", "..", "..");
  newEnv["PATH"] = newEnv["PATH"] || process.env.PATH;
  return newEnv;
}
function getExecArgv(kind, configuration) {
  const args = [];
  const debugPort = getDebugPort(kind);
  if (debugPort) {
    const inspectFlag = getTssDebugBrk() ? "--inspect-brk" : "--inspect";
    args.push(`${inspectFlag}=${debugPort}`);
  }
  if (configuration.maxTsServerMemory) {
    args.push(`--max-old-space-size=${configuration.maxTsServerMemory}`);
  }
  return args;
}
function getDebugPort(kind) {
  if (kind === "syntax" /* Syntax */) {
    return void 0;
  }
  const value = getTssDebugBrk() || getTssDebug();
  if (value) {
    const port = parseInt(value);
    if (!isNaN(port)) {
      return port;
    }
  }
  return void 0;
}
function getTssDebug() {
  return process.env[env.remoteName ? "TSS_REMOTE_DEBUG" : "TSS_DEBUG"];
}
function getTssDebugBrk() {
  return process.env[env.remoteName ? "TSS_REMOTE_DEBUG_BRK" : "TSS_DEBUG_BRK"];
}
var defaultSize, contentLength, contentLengthSize, blank, backslashR, backslashN, ProtocolBuffer, Reader, IpcChildServerProcess, StdioChildServerProcess, ElectronServiceProcessFactory;
var init_serverProcess_electron = __esm({
  "src/typescript-language-features/src/tsServer/serverProcess.electron.ts"() {
    "use strict";
    init_shims();
    init_dispose();
    init_api2();
    init_server();
    defaultSize = 8192;
    contentLength = "Content-Length: ";
    contentLengthSize = Buffer.byteLength(contentLength, "utf8");
    blank = Buffer.from(" ", "utf8")[0];
    backslashR = Buffer.from("\r", "utf8")[0];
    backslashN = Buffer.from("\n", "utf8")[0];
    ProtocolBuffer = class {
      constructor() {
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(defaultSize);
      }
      append(data) {
        let toAppend = null;
        if (Buffer.isBuffer(data)) {
          toAppend = data;
        } else {
          toAppend = Buffer.from(data, "utf8");
        }
        if (this.buffer.length - this.index >= toAppend.length) {
          toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        } else {
          const newSize = (Math.ceil((this.index + toAppend.length) / defaultSize) + 1) * defaultSize;
          if (this.index === 0) {
            this.buffer = Buffer.allocUnsafe(newSize);
            toAppend.copy(this.buffer, 0, 0, toAppend.length);
          } else {
            this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
          }
        }
        this.index += toAppend.length;
      }
      tryReadContentLength() {
        let result = -1;
        let current = 0;
        while (current < this.index && (this.buffer[current] === blank || this.buffer[current] === backslashR || this.buffer[current] === backslashN)) {
          current++;
        }
        if (this.index < current + contentLengthSize) {
          return result;
        }
        current += contentLengthSize;
        const start = current;
        while (current < this.index && this.buffer[current] !== backslashR) {
          current++;
        }
        if (current + 3 >= this.index || this.buffer[current + 1] !== backslashN || this.buffer[current + 2] !== backslashR || this.buffer[current + 3] !== backslashN) {
          return result;
        }
        const data = this.buffer.toString("utf8", start, current);
        result = parseInt(data);
        this.buffer = this.buffer.slice(current + 4);
        this.index = this.index - (current + 4);
        return result;
      }
      tryReadContent(length) {
        if (this.index < length) {
          return null;
        }
        const result = this.buffer.toString("utf8", 0, length);
        let sourceStart = length;
        while (sourceStart < this.index && (this.buffer[sourceStart] === backslashR || this.buffer[sourceStart] === backslashN)) {
          sourceStart++;
        }
        this.buffer.copy(this.buffer, 0, sourceStart);
        this.index = this.index - sourceStart;
        return result;
      }
    };
    Reader = class extends Disposable {
      constructor(readable) {
        super();
        this.buffer = new ProtocolBuffer();
        this.nextMessageLength = -1;
        this._onError = this._register(new EventEmitter());
        this.onError = this._onError.event;
        this._onData = this._register(new EventEmitter());
        this.onData = this._onData.event;
        readable.on("data", (data) => this.onLengthData(data));
      }
      onLengthData(data) {
        if (this.isDisposed) {
          return;
        }
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              this.nextMessageLength = this.buffer.tryReadContentLength();
              if (this.nextMessageLength === -1) {
                return;
              }
            }
            const msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
              return;
            }
            this.nextMessageLength = -1;
            const json = JSON.parse(msg);
            this._onData.fire(json);
          }
        } catch (e) {
          this._onError.fire(e);
        }
      }
    };
    IpcChildServerProcess = class extends Disposable {
      constructor(_process) {
        super();
        this._process = _process;
      }
      write(serverRequest) {
        this._process.send(serverRequest);
      }
      onData(handler) {
        this._process.on("message", handler);
      }
      onExit(handler) {
        this._process.on("exit", handler);
      }
      onError(handler) {
        this._process.on("error", handler);
      }
      kill() {
        this._process.kill();
      }
    };
    StdioChildServerProcess = class extends Disposable {
      constructor(_process) {
        super();
        this._process = _process;
        this._reader = this._register(new Reader(this._process.stdout));
      }
      write(serverRequest) {
        this._process.stdin.write(JSON.stringify(serverRequest) + "\r\n", "utf8");
      }
      onData(handler) {
        this._reader.onData(handler);
      }
      onExit(handler) {
        this._process.on("exit", handler);
      }
      onError(handler) {
        this._process.on("error", handler);
        this._reader.onError(handler);
      }
      kill() {
        this._process.kill();
        this._reader.dispose();
      }
    };
    ElectronServiceProcessFactory = class {
      fork(version, args, kind, configuration, versionManager, nodeVersionManager, _tsserverLog) {
        var _a;
        let tsServerPath = version.tsServerPath;
        if (!fs5.existsSync(tsServerPath)) {
          window.showWarningMessage(l10n.t("The path {0} doesn't point to a valid tsserver install. Falling back to bundled TypeScript version.", tsServerPath));
          versionManager.reset();
          tsServerPath = versionManager.currentVersion.tsServerPath;
        }
        const execPath = nodeVersionManager.currentVersion;
        const env2 = generatePatchedEnv(process.env, tsServerPath, !!execPath);
        const runtimeArgs = [...args];
        const execArgv = getExecArgv(kind, configuration);
        const useIpc = !execPath && ((_a = version.apiVersion) == null ? void 0 : _a.gte(API.v460));
        if (useIpc) {
          runtimeArgs.push("--useNodeIpc");
        }
        const childProcess = execPath ? child_process.spawn(execPath, [...execArgv, tsServerPath, ...runtimeArgs], {
          windowsHide: true,
          cwd: void 0,
          env: env2
        }) : child_process.fork(tsServerPath, runtimeArgs, {
          silent: true,
          cwd: void 0,
          env: env2,
          execArgv,
          stdio: useIpc ? ["pipe", "pipe", "pipe", "ipc"] : void 0
        });
        return useIpc ? new IpcChildServerProcess(childProcess) : new StdioChildServerProcess(childProcess);
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/versionProvider.ts
var TypeScriptVersion;
var init_versionProvider = __esm({
  "src/typescript-language-features/src/tsServer/versionProvider.ts"() {
    "use strict";
    init_shims();
    TypeScriptVersion = class {
      constructor(source, path15, apiVersion, _pathLabel) {
        this.source = source;
        this.path = path15;
        this.apiVersion = apiVersion;
        this._pathLabel = _pathLabel;
      }
      get tsServerPath() {
        return this.path;
      }
      get pathLabel() {
        return this._pathLabel ?? this.path;
      }
      get isValid() {
        return this.apiVersion !== void 0;
      }
      eq(other) {
        if (this.path !== other.path) {
          return false;
        }
        if (this.apiVersion === other.apiVersion) {
          return true;
        }
        if (!this.apiVersion || !other.apiVersion) {
          return false;
        }
        return this.apiVersion.eq(other.apiVersion);
      }
      get displayName() {
        const version = this.apiVersion;
        return version ? version.displayName : l10n.t("Could not load the TypeScript version at this path");
      }
    };
  }
});

// src/typescript-language-features/src/tsServer/versionProvider.electron.ts
import * as fs6 from "fs";
import * as path13 from "path";
import { createRequire } from "module";
import { fileURLToPath } from "url";
var req, DiskTypeScriptVersionProvider;
var init_versionProvider_electron = __esm({
  "src/typescript-language-features/src/tsServer/versionProvider.electron.ts"() {
    "use strict";
    init_shims();
    init_relativePathResolver();
    init_api2();
    init_versionProvider();
    req = createRequire(import.meta.url);
    DiskTypeScriptVersionProvider = class _DiskTypeScriptVersionProvider {
      constructor(configuration) {
        this.configuration = configuration;
      }
      updateConfiguration(configuration) {
        this.configuration = configuration;
      }
      get defaultVersion() {
        return this.globalVersion || this.bundledVersion;
      }
      get globalVersion() {
        var _a;
        if ((_a = this.configuration) == null ? void 0 : _a.globalTsdk) {
          const globals = this.loadVersionsFromSetting("user-setting" /* UserSetting */, this.configuration.globalTsdk);
          if (globals == null ? void 0 : globals.length) {
            return globals[0];
          }
        }
        return this.contributedTsNextVersion;
      }
      get localVersion() {
        const tsdkVersions = this.localTsdkVersions;
        if (tsdkVersions == null ? void 0 : tsdkVersions.length) {
          return tsdkVersions[0];
        }
        const nodeVersions = this.localNodeModulesVersions;
        if (nodeVersions && nodeVersions.length === 1) {
          return nodeVersions[0];
        }
        return void 0;
      }
      get localVersions() {
        const allVersions = this.localTsdkVersions.concat(this.localNodeModulesVersions);
        const paths = /* @__PURE__ */ new Set();
        return allVersions.filter((x) => {
          if (paths.has(x.path)) {
            return false;
          }
          paths.add(x.path);
          return true;
        });
      }
      get bundledVersion() {
        const version = this.getContributedVersion("bundled" /* Bundled */, "vscode.typescript-language-features", ["..", "node_modules"]);
        if (version) {
          return version;
        }
        window.showErrorMessage(l10n.t("VS Code's tsserver was deleted by another application such as a misbehaving virus detection tool. Please reinstall VS Code."));
        throw new Error("Could not find bundled tsserver.js");
      }
      get contributedTsNextVersion() {
        return this.getContributedVersion("ts-nightly-extension" /* TsNightlyExtension */, "ms-vscode.vscode-typescript-next", ["node_modules"]);
      }
      getContributedVersion(source, extensionId, pathToTs) {
        try {
          const tsPath = req.resolve("typescript", { paths: [fileURLToPath(import.meta.url)] });
          const serverPath = path13.join(path13.dirname(tsPath), "tsserver.js");
          const bundledVersion = new TypeScriptVersion(source, serverPath, _DiskTypeScriptVersionProvider.getApiVersion(serverPath), "");
          if (bundledVersion.isValid) {
            return bundledVersion;
          }
        } catch {
        }
        return void 0;
      }
      get localTsdkVersions() {
        var _a;
        const localTsdk = (_a = this.configuration) == null ? void 0 : _a.localTsdk;
        return localTsdk ? this.loadVersionsFromSetting("workspace-setting" /* WorkspaceSetting */, localTsdk) : [];
      }
      loadVersionsFromSetting(source, tsdkPathSetting) {
        if (path13.isAbsolute(tsdkPathSetting)) {
          const serverPath = path13.join(tsdkPathSetting, "tsserver.js");
          return [
            new TypeScriptVersion(
              source,
              serverPath,
              _DiskTypeScriptVersionProvider.getApiVersion(serverPath),
              tsdkPathSetting
            )
          ];
        }
        const workspacePath = RelativeWorkspacePathResolver.asAbsoluteWorkspacePath(tsdkPathSetting);
        if (workspacePath !== void 0) {
          const serverPath = path13.join(workspacePath, "tsserver.js");
          return [
            new TypeScriptVersion(
              source,
              serverPath,
              _DiskTypeScriptVersionProvider.getApiVersion(serverPath),
              tsdkPathSetting
            )
          ];
        }
        return this.loadTypeScriptVersionsFromPath(source, tsdkPathSetting);
      }
      get localNodeModulesVersions() {
        return this.loadTypeScriptVersionsFromPath("node-modules" /* NodeModules */, path13.join("node_modules", "typescript", "lib")).filter((x) => x.isValid);
      }
      loadTypeScriptVersionsFromPath(source, relativePath) {
        if (!workspace.workspaceFolders) {
          return [];
        }
        const versions = [];
        for (const root of workspace.workspaceFolders) {
          let label = relativePath;
          if (workspace.workspaceFolders.length > 1) {
            label = path13.join(root.name, relativePath);
          }
          const serverPath = path13.join(root.uri.fsPath, relativePath, "tsserver.js");
          versions.push(new TypeScriptVersion(source, serverPath, _DiskTypeScriptVersionProvider.getApiVersion(serverPath), label));
        }
        return versions;
      }
      static getApiVersion(serverPath) {
        const version = _DiskTypeScriptVersionProvider.getTypeScriptVersion(serverPath);
        if (version) {
          return version;
        }
        const tsdkVersion = workspace.getConfiguration().get("typescript.tsdk_version", void 0);
        if (tsdkVersion) {
          return API.fromVersionString(tsdkVersion);
        }
        return void 0;
      }
      static getTypeScriptVersion(serverPath) {
        if (!fs6.existsSync(serverPath)) {
          return void 0;
        }
        const p = serverPath.split(path13.sep);
        if (p.length <= 2) {
          return void 0;
        }
        const p2 = p.slice(0, -2);
        const modulePath = p2.join(path13.sep);
        let fileName = path13.join(modulePath, "package.json");
        if (!fs6.existsSync(fileName)) {
          if (path13.basename(modulePath) === "built") {
            fileName = path13.join(modulePath, "..", "package.json");
          }
        }
        if (!fs6.existsSync(fileName)) {
          return void 0;
        }
        const contents = fs6.readFileSync(fileName).toString();
        let desc = null;
        try {
          desc = JSON.parse(contents);
        } catch (err) {
          return void 0;
        }
        if (!(desc == null ? void 0 : desc.version)) {
          return void 0;
        }
        return desc.version ? API.fromVersionString(desc.version) : void 0;
      }
    };
  }
});

// src/typescript-language-features/src/ui/activeJsTsEditorTracker.ts
var ActiveJsTsEditorTracker;
var init_activeJsTsEditorTracker = __esm({
  "src/typescript-language-features/src/ui/activeJsTsEditorTracker.ts"() {
    "use strict";
    init_shims();
    init_languageDescription();
    init_languageIds();
    init_dispose();
    init_arrays();
    ActiveJsTsEditorTracker = class extends Disposable {
      constructor() {
        super();
        this._onDidChangeActiveJsTsEditor = this._register(new EventEmitter());
        this.onDidChangeActiveJsTsEditor = this._onDidChangeActiveJsTsEditor.event;
        this._register(window.onDidChangeActiveTextEditor((_) => this.update()));
        this._register(window.onDidChangeVisibleTextEditors((_) => this.update()));
        this._register(window.tabGroups.onDidChangeTabGroups((_) => this.update()));
        this.update();
      }
      get activeJsTsEditor() {
        return this._activeJsTsEditor;
      }
      update() {
        const editorCandidates = this.getEditorCandidatesForActiveTab();
        const managedEditors = editorCandidates.filter((editor) => this.isManagedFile(editor));
        const newActiveJsTsEditor = managedEditors.at(0);
        if (this._activeJsTsEditor !== newActiveJsTsEditor) {
          this._activeJsTsEditor = newActiveJsTsEditor;
          this._onDidChangeActiveJsTsEditor.fire(this._activeJsTsEditor);
        }
      }
      getEditorCandidatesForActiveTab() {
        const tab = window.tabGroups.activeTabGroup.activeTab;
        if (!tab) {
          return [];
        }
        if (tab.input instanceof TabInputText) {
          const inputUri = tab.input.uri;
          const editor = window.visibleTextEditors.find((editor2) => {
            return editor2.document.uri.toString() === inputUri.toString() && editor2.viewColumn === tab.group.viewColumn;
          });
          return editor ? [editor] : [];
        }
        if (tab.input instanceof TabInputTextDiff) {
          const original = tab.input.original;
          const modified = tab.input.modified;
          return coalesce([window.activeTextEditor, ...window.visibleTextEditors]).filter((editor) => {
            return (editor.document.uri.toString() === original.toString() || editor.document.uri.toString() === modified.toString()) && editor.viewColumn === void 0;
          });
        }
        if (tab.input instanceof TabInputNotebook) {
          const activeEditor = window.activeTextEditor;
          if (!activeEditor) {
            return [];
          }
          if (activeEditor.viewColumn !== void 0) {
            return [];
          }
          const notebook = window.visibleNotebookEditors.find((editor) => editor.notebook.uri.toString() === tab.input.uri.toString() && editor.viewColumn === tab.group.viewColumn);
          return (notebook == null ? void 0 : notebook.notebook.getCells().some((cell) => cell.document.uri.toString() === activeEditor.document.uri.toString())) ? [activeEditor] : [];
        }
        return [];
      }
      isManagedFile(editor) {
        return this.isManagedScriptFile(editor) || this.isManagedConfigFile(editor);
      }
      isManagedScriptFile(editor) {
        return isSupportedLanguageMode(editor.document);
      }
      isManagedConfigFile(editor) {
        return isJsConfigOrTsConfigFileName(editor.document.fileName);
      }
    };
  }
});

// src/typescript-language-features/src/configuration/configuration.electron.ts
import * as os3 from "os";
import * as path14 from "path";
import * as child_process2 from "child_process";
import * as fs7 from "fs";
var ElectronServiceConfigurationProvider;
var init_configuration_electron = __esm({
  "src/typescript-language-features/src/configuration/configuration.electron.ts"() {
    "use strict";
    init_shims();
    init_configuration2();
    init_relativePathResolver();
    ElectronServiceConfigurationProvider = class extends BaseServiceConfigurationProvider {
      fixPathPrefixes(inspectValue) {
        const pathPrefixes = ["~" + path14.sep];
        for (const pathPrefix of pathPrefixes) {
          if (inspectValue.startsWith(pathPrefix)) {
            return path14.join(os3.homedir(), inspectValue.slice(pathPrefix.length));
          }
        }
        return inspectValue;
      }
      readGlobalTsdk(configuration) {
        const value = configuration.get("vtsls.typescript.globalTsdk");
        if (value) {
          return this.fixPathPrefixes(value);
        }
        return null;
      }
      readLocalTsdk(configuration) {
        const inspect = configuration.inspect("typescript.tsdk");
        if (inspect && typeof inspect.workspaceValue === "string") {
          return this.fixPathPrefixes(inspect.workspaceValue);
        }
        return null;
      }
      readLocalNodePath(configuration) {
        return this.validatePath(this.readLocalNodePathWorker(configuration));
      }
      readLocalNodePathWorker(configuration) {
        const inspect = configuration.inspect("typescript.tsserver.nodePath");
        if ((inspect == null ? void 0 : inspect.workspaceValue) && typeof inspect.workspaceValue === "string") {
          if (inspect.workspaceValue === "node") {
            return this.findNodePath();
          }
          const fixedPath = this.fixPathPrefixes(inspect.workspaceValue);
          if (!path14.isAbsolute(fixedPath)) {
            const workspacePath = RelativeWorkspacePathResolver.asAbsoluteWorkspacePath(fixedPath);
            return workspacePath || null;
          }
          return fixedPath;
        }
        return null;
      }
      readGlobalNodePath(configuration) {
        return this.validatePath(this.readGlobalNodePathWorker(configuration));
      }
      readGlobalNodePathWorker(configuration) {
        const inspect = configuration.inspect("typescript.tsserver.nodePath");
        if ((inspect == null ? void 0 : inspect.globalValue) && typeof inspect.globalValue === "string") {
          if (inspect.globalValue === "node") {
            return this.findNodePath();
          }
          const fixedPath = this.fixPathPrefixes(inspect.globalValue);
          if (path14.isAbsolute(fixedPath)) {
            return fixedPath;
          }
        }
        return null;
      }
      findNodePath() {
        var _a;
        try {
          const out = child_process2.execFileSync("node", ["-e", "console.log(process.execPath)"], {
            windowsHide: true,
            timeout: 2e3,
            cwd: (_a = workspace.workspaceFolders) == null ? void 0 : _a[0].uri.fsPath,
            encoding: "utf-8"
          });
          return out.trim();
        } catch (error) {
          window.showWarningMessage(l10n.t("Could not detect a Node installation to run TS Server."));
          return null;
        }
      }
      validatePath(nodePath) {
        if (nodePath && (!fs7.existsSync(nodePath) || fs7.lstatSync(nodePath).isDirectory())) {
          window.showWarningMessage(l10n.t("The path {0} doesn't point to a valid Node installation to run TS Server. Falling back to bundled Node.", nodePath));
          return null;
        }
        return nodePath;
      }
    };
  }
});

// src/typescript-language-features/src/logging/logger.ts
var Logger;
var init_logger = __esm({
  "src/typescript-language-features/src/logging/logger.ts"() {
    "use strict";
    init_shims();
    init_memoize();
    Logger = class {
      get output() {
        return window.createOutputChannel("TypeScript", { log: true });
      }
      get logLevel() {
        return this.output.logLevel;
      }
      info(message, ...args) {
        this.output.info(message, ...args);
      }
      trace(message, ...args) {
        this.output.trace(message, ...args);
      }
      error(message, data) {
        if (data && data.message === "No content available.") {
          return;
        }
        this.output.error(message, ...data ? [data] : []);
      }
    };
    __decorateClass([
      memoize
    ], Logger.prototype, "output", 1);
  }
});

// src/typescript-language-features/src/tsServer/plugins.ts
var TypeScriptServerPlugin, PluginManager;
var init_plugins = __esm({
  "src/typescript-language-features/src/tsServer/plugins.ts"() {
    "use strict";
    init_shims();
    init_arrays();
    init_dispose();
    ((TypeScriptServerPlugin2) => {
      function equals3(a, b) {
        var _a, _b;
        return ((_a = a.uri) == null ? void 0 : _a.toString()) === ((_b = b.uri) == null ? void 0 : _b.toString()) && a.name === b.name && a.enableForWorkspaceTypeScriptVersions === b.enableForWorkspaceTypeScriptVersions && equals(a.languages, b.languages);
      }
      TypeScriptServerPlugin2.equals = equals3;
    })(TypeScriptServerPlugin || (TypeScriptServerPlugin = {}));
    PluginManager = class extends Disposable {
      constructor() {
        super();
        this._pluginConfigurations = /* @__PURE__ */ new Map();
        this._onDidUpdatePlugins = this._register(new EventEmitter());
        this.onDidChangePlugins = this._onDidUpdatePlugins.event;
        this._onDidUpdateConfig = this._register(new EventEmitter());
        this.onDidUpdateConfig = this._onDidUpdateConfig.event;
        workspace.onDidChangeConfiguration((e) => {
          if (!e.affectsConfiguration("vtsls.tsserver.globalPlugins")) {
            return;
          }
          if (!this._plugins) {
            return;
          }
          const newPlugins = this.readPlugins();
          if (!equals(Array.from(this._plugins.values()).flat(), Array.from(newPlugins.values()).flat(), TypeScriptServerPlugin.equals)) {
            this._plugins = newPlugins;
            this._onDidUpdatePlugins.fire(this);
          }
        }, void 0, this._disposables);
      }
      get plugins() {
        this._plugins ??= this.readPlugins();
        return Array.from(this._plugins.values()).flat();
      }
      setConfiguration(pluginId, config3) {
        this._pluginConfigurations.set(pluginId, config3);
        this._onDidUpdateConfig.fire({ pluginId, config: config3 });
      }
      configurations() {
        return this._pluginConfigurations.entries();
      }
      readPlugins() {
        const configPlugins = workspace.getConfiguration("vtsls").get("tsserver.globalPlugins") || [];
        const plugins = [];
        for (const plugin of configPlugins) {
          const extension = {
            id: plugin.name
            // extensionUri: uri,
            // extensionPath: pluginPath,
            // isActive: true,
          };
          plugins.push({
            extension,
            name: plugin.name,
            enableForWorkspaceTypeScriptVersions: !!plugin.enableForWorkspaceTypeScriptVersions,
            uri: plugin.location ? Uri.file(plugin.location) : void 0,
            languages: Array.isArray(plugin.languages) ? plugin.languages : [],
            configNamespace: plugin.configNamespace
          });
        }
        return /* @__PURE__ */ new Map([["", plugins]]);
      }
    };
  }
});

// src/typescript-language-features/src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
import * as fs8 from "fs";
function activate(context) {
  const pluginManager = new PluginManager();
  context.subscriptions.push(pluginManager);
  const commandManager = new CommandManager();
  context.subscriptions.push(commandManager);
  const onCompletionAccepted = new EventEmitter();
  context.subscriptions.push(onCompletionAccepted);
  const logDirectoryProvider = new NodeLogDirectoryProvider(context);
  const versionProvider = new DiskTypeScriptVersionProvider();
  const activeJsTsEditorTracker = new ActiveJsTsEditorTracker();
  context.subscriptions.push(activeJsTsEditorTracker);
  let experimentTelemetryReporter;
  const logger = new Logger();
  const lazyClientHost = createLazyClientHost(context, onCaseInsensitiveFileSystem(), {
    pluginManager,
    commandManager,
    logDirectoryProvider,
    cancellerFactory: nodeRequestCancellerFactory,
    versionProvider,
    processFactory: new ElectronServiceProcessFactory(),
    activeJsTsEditorTracker,
    serviceConfigurationProvider: new ElectronServiceConfigurationProvider(),
    experimentTelemetryReporter,
    logger
  }, (item) => {
    onCompletionAccepted.fire(item);
  });
  registerBaseCommands(commandManager, lazyClientHost, pluginManager, activeJsTsEditorTracker);
  context.subscriptions.push(lazilyActivateClient(lazyClientHost, pluginManager, activeJsTsEditorTracker));
  return getExtensionApi(onCompletionAccepted.event, pluginManager);
}
function deactivate() {
  fs8.rmSync(instanceTempDir.value, { recursive: true, force: true });
}
var init_extension = __esm({
  "src/typescript-language-features/src/extension.ts"() {
    "use strict";
    init_shims();
    init_api();
    init_commandManager();
    init_commands2();
    init_lazyClientHost();
    init_cancellation_electron();
    init_logDirectoryProvider_electron();
    init_serverProcess_electron();
    init_versionProvider_electron();
    init_activeJsTsEditorTracker();
    init_configuration_electron();
    init_fs_electron();
    init_logger();
    init_plugins();
    init_temp_electron();
  }
});

// src/service/main.ts
init_share();
init_shims();
init_types2();
init_barrier();
import * as lsp12 from "vscode-languageserver-protocol";
import { URI as URI9 } from "vscode-uri";

// src/utils/converter.ts
init_types2();
init_fs();
init_resourceMap2();
init_objects2();
import * as lsp8 from "vscode-languageserver-protocol";
import { URI as URI8 } from "vscode-uri";
function isStringOrFalsy(val) {
  return typeof val === "string" || val === void 0 || val === null;
}
function mapOrFalsy(val, mapFn) {
  return val && val.length > 0 ? val.map(mapFn) : void 0;
}
function convertOrFalsy(val, cvtFn) {
  return val !== void 0 && val !== null ? cvtFn(val) : void 0;
}
var LspInvariantConverter = class {
  constructor() {
    this.convertTextEdit = (edit) => {
      return {
        range: this.convertRangeToLsp(edit.range),
        newText: edit.newText
      };
    };
    this.convertPositionToLsp = (pos) => {
      return {
        line: pos.line,
        character: pos.character
      };
    };
    this.convertRangeToLsp = (range) => {
      return {
        start: range.start,
        end: range.end
      };
    };
    this.convertPositionFromLsp = (position) => Position.of(position);
    this.convertRangeFromLsp = (range) => Range.of(range);
  }
};
var TSLspConverter = class extends LspInvariantConverter {
  constructor(clientCapabilities) {
    super();
    this.clientCapabilities = clientCapabilities;
    this.convertWorkspaceEdit = (edit) => {
      var _a, _b, _c, _d;
      const resouceOpKinds = ((_b = (_a = this.clientCapabilities.workspace) == null ? void 0 : _a.workspaceEdit) == null ? void 0 : _b.resourceOperations) ?? [];
      const docChanges = [];
      let hasResourceOp = false;
      const textEditsByUri = new ResourceMap(void 0, {
        onCaseInsensitiveFileSystem: onCaseInsensitiveFileSystem()
      });
      for (const entry of edit._allEntries()) {
        if (entry._type === 1 /* File */) {
          hasResourceOp = true;
          if (!entry.from) {
            if (
              // less strict check (some clients don't support this)
              !((_c = entry.options) == null ? void 0 : _c.ignoreIfExists) && !resouceOpKinds.includes(lsp8.ResourceOperationKind.Create)
            ) {
              throw new Error("client doesn't support create operation");
            }
            if (entry.to) {
              docChanges.push({
                kind: "create",
                uri: entry.to.toString(),
                options: entry.options
              });
            }
          } else if (entry.to) {
            if (!resouceOpKinds.includes(lsp8.ResourceOperationKind.Rename)) {
              throw new Error("client doesn't support rename operation");
            }
            docChanges.push({
              kind: "rename",
              oldUri: entry.from.toString(),
              newUri: entry.to.toString(),
              options: entry.options
            });
          } else {
            if (!resouceOpKinds.includes(lsp8.ResourceOperationKind.Delete)) {
              throw new Error("client doesn't support delete operation");
            }
            docChanges.push({
              kind: "delete",
              uri: entry.from.toString(),
              options: entry.options
            });
          }
        } else if (entry._type === 2 /* Text */) {
          if (textEditsByUri.has(entry.uri)) {
            (_d = textEditsByUri.get(entry.uri)) == null ? void 0 : _d.push(this.convertTextEdit(entry.edit));
          } else {
            docChanges.push(entry.uri);
            textEditsByUri.set(entry.uri, [this.convertTextEdit(entry.edit)]);
          }
        } else {
          throw new Error(`Not supported type of edit entry: ${entry._type}`);
        }
      }
      if (hasResourceOp) {
        return {
          documentChanges: docChanges.map((d) => {
            if (!URI8.isUri(d)) {
              return d;
            } else {
              return {
                textDocument: { uri: d.toString(), version: null },
                edits: textEditsByUri.get(d)
              };
            }
          })
        };
      } else {
        const changes = {};
        for (const { resource: uri, value: edits } of textEditsByUri.entries()) {
          changes[uri.toString()] = edits;
        }
        return { changes };
      }
    };
    this.convertCompletionItem = (item, data) => {
      var _a, _b, _c, _d;
      const { label, ...details } = isStringOrFalsy(item.label) ? { label: item.label } : item.label;
      const isSnippet = !isStringOrFalsy(item.insertText);
      const insertText = isSnippet ? item.insertText.value : item.insertText ?? ((_a = item.textEdit) == null ? void 0 : _a.newText);
      let textEdit = void 0;
      if (item.range) {
        if (lsp8.Range.is(item.range)) {
          textEdit = {
            range: this.convertRangeToLsp(item.range),
            newText: insertText ?? label
          };
        } else if ((_d = (_c = (_b = this.clientCapabilities.textDocument) == null ? void 0 : _b.completion) == null ? void 0 : _c.completionItem) == null ? void 0 : _d.insertReplaceSupport) {
          textEdit = {
            insert: this.convertRangeToLsp(item.range.inserting),
            replace: this.convertRangeToLsp(item.range.replacing),
            newText: insertText ?? label
          };
        } else {
          textEdit = {
            // TODO: use item.range.replacing?
            range: this.convertRangeToLsp(item.range.inserting),
            newText: insertText ?? label
          };
        }
      } else if (item.textEdit) {
        textEdit = this.convertTextEdit(item.textEdit);
      }
      return {
        label,
        labelDetails: details,
        kind: item.kind ? item.kind + 1 : void 0,
        tags: item.tags,
        detail: item.detail,
        documentation: convertOrFalsy(item.documentation, this.convertMarkupToLsp),
        preselect: item.preselect,
        sortText: item.sortText,
        filterText: item.filterText,
        insertTextMode: item.keepWhitespace === void 0 ? void 0 : item.keepWhitespace ? lsp8.InsertTextMode.adjustIndentation : lsp8.InsertTextMode.asIs,
        insertTextFormat: isSnippet ? lsp8.InsertTextFormat.Snippet : lsp8.InsertTextFormat.PlainText,
        insertText,
        textEdit,
        additionalTextEdits: mapOrFalsy(item.additionalTextEdits, this.convertTextEdit),
        commitCharacters: item.commitCharacters,
        command: item.command,
        data
      };
    };
    this.convertLocationLink = (location) => {
      return {
        originSelectionRange: convertOrFalsy(location.originSelectionRange, this.convertRangeToLsp),
        targetUri: location.targetUri.toString(),
        targetRange: this.convertRangeToLsp(location.targetRange),
        targetSelectionRange: this.convertRangeToLsp(
          location.targetSelectionRange ?? location.targetRange
        )
      };
    };
    this.convertLocationLinkToLocation = (location) => {
      return {
        uri: location.targetUri.toString(),
        range: this.convertRangeToLsp(location.targetRange)
      };
    };
    this.convertLocation = (location) => {
      return {
        uri: location.uri.toString(),
        range: this.convertRangeToLsp(location.range)
      };
    };
    this.convertDefinition = (location) => {
      var _a, _b;
      return this.convertLocations(
        location,
        ((_b = (_a = this.clientCapabilities.textDocument) == null ? void 0 : _a.definition) == null ? void 0 : _b.linkSupport) ?? false
      );
    };
    this.convertImplementation = (location) => {
      var _a, _b;
      return this.convertLocations(
        location,
        ((_b = (_a = this.clientCapabilities.textDocument) == null ? void 0 : _a.implementation) == null ? void 0 : _b.linkSupport) ?? false
      );
    };
    this.convertTypeDefinition = (location) => {
      var _a, _b;
      return this.convertLocations(
        location,
        ((_b = (_a = this.clientCapabilities.textDocument) == null ? void 0 : _a.typeDefinition) == null ? void 0 : _b.linkSupport) ?? false
      );
    };
    this.convertDocumentLink = (link, data) => {
      var _a;
      return {
        range: this.convertRangeToLsp(link.range),
        target: (_a = link.target) == null ? void 0 : _a.toString(),
        tooltip: link.tooltip,
        data
      };
    };
    this.convertDiagnosticFromLsp = (diagnostic) => {
      const d = new Diagnostic(
        Range.of(diagnostic.range),
        diagnostic.message,
        diagnostic.severity ? diagnostic.severity - 1 : void 0
      );
      d.code = diagnostic.code;
      d.tags = diagnostic.tags;
      d.source = diagnostic.source;
      if (diagnostic.relatedInformation) {
        d.relatedInformation = diagnostic.relatedInformation.map((r) => {
          const location = new Location(
            URI8.parse(r.location.uri),
            Range.of(r.location.range)
          );
          return new DiagnosticRelatedInformation(location, r.message);
        });
      }
      return d;
    };
    this.convertDiagnosticToLsp = (diagnostic) => {
      const { value: code, target } = isStringOrFalsy(diagnostic.code) || typeof diagnostic.code === "number" ? { value: diagnostic.code, target: void 0 } : diagnostic.code;
      return {
        range: this.convertRangeToLsp(diagnostic.range),
        message: diagnostic.message,
        code,
        codeDescription: target ? {
          href: target.toString()
        } : void 0,
        source: diagnostic.source,
        severity: diagnostic.severity + 1,
        relatedInformation: diagnostic.relatedInformation ? diagnostic.relatedInformation.map((d) => ({
          message: d.message,
          location: this.convertLocation(d.location)
        })) : void 0,
        tags: diagnostic.tags ? diagnostic.tags.map((t) => t) : void 0
      };
    };
    this.convertHover = (hover) => {
      const mergedString = new MarkdownString();
      for (const content of hover.contents) {
        if (lsp8.MarkedString.is(content)) {
          if (typeof content === "string") {
            mergedString.appendText(content);
          } else {
            mergedString.appendCodeblock(content.value, content.language);
          }
        } else {
          mergedString.appendMarkdown(content.value);
        }
      }
      return {
        contents: mergedString.value,
        range: hover.range ? this.convertRangeToLsp(hover.range) : void 0
      };
    };
    this.convertSymbol = (symbol) => {
      var _a, _b;
      if ("range" in symbol) {
        const result = {
          name: symbol.name,
          detail: symbol.detail,
          kind: symbol.kind + 1,
          range: this.convertRangeToLsp(symbol.range),
          selectionRange: this.convertRangeToLsp(symbol.selectionRange),
          tags: symbol.tags,
          // deprecated: symbol.tags?.includes(types.SymbolTag.Deprecated) ?? false,
          children: symbol.children && ((_b = (_a = this.clientCapabilities.textDocument) == null ? void 0 : _a.documentSymbol) == null ? void 0 : _b.hierarchicalDocumentSymbolSupport) ? symbol.children.map(this.convertSymbol) : void 0
        };
        return result;
      } else {
        const result = {
          name: symbol.name,
          kind: symbol.kind + 1,
          tags: symbol.tags,
          // deprecated: symbol.tags?.includes(types.SymbolTag.Deprecated) ?? false,
          location: this.convertLocation(symbol.location),
          containerName: symbol.containerName
        };
        return result;
      }
    };
    this.convertMarkupfromLsp = (doc) => {
      if (typeof doc === "string") {
        return doc;
      }
      if (doc.kind === "plaintext") {
        return doc.value;
      }
      return new MarkdownString(doc.value);
    };
    this.convertMarkupToLsp = (doc) => {
      if (typeof doc === "string") {
        return doc || void 0;
      } else {
        return doc.value ? {
          kind: lsp8.MarkupKind.Markdown,
          value: doc.value
        } : void 0;
      }
    };
    this.convertSignatureInfoFromLsp = (info) => {
      const result = deepClone(info);
      if (result.documentation) {
        result.documentation = this.convertMarkupfromLsp(
          result.documentation
        );
      }
      for (const param of result.parameters || []) {
        if (param.documentation) {
          param.documentation = this.convertMarkupfromLsp(
            param.documentation
          );
        }
        param.documentation;
      }
      return result;
    };
    this.convertSignatureInfoToLsp = (info) => {
      return {
        label: info.label,
        activeParameter: info.activeParameter,
        parameters: info.parameters ? info.parameters.map((p) => ({
          label: p.label,
          documentation: p.documentation ? this.convertMarkupToLsp(p.documentation) : void 0
        })) : void 0,
        documentation: info.documentation ? this.convertMarkupToLsp(info.documentation) : void 0
      };
    };
    this.convertCallHierarcgyItemToLsp = (item, data) => {
      return {
        uri: item.uri.toString(),
        kind: item.kind + 1,
        name: item.name,
        range: this.convertRangeToLsp(item.range),
        selectionRange: this.convertRangeToLsp(item.selectionRange),
        detail: item.detail,
        tags: item.tags,
        data
      };
    };
    this.convertCallHierarcgyItemFromLsp = (item) => {
      return new CallHierarchyItem(
        item.kind - 1,
        item.name,
        item.detail ?? "",
        URI8.parse(item.uri),
        Range.of(item.range),
        Range.of(item.selectionRange)
      );
    };
    this.convertInlayHint = (hint) => {
      return {
        position: this.convertPositionToLsp(hint.position),
        label: typeof hint.label === "string" ? hint.label : hint.label.map((l) => ({
          value: l.value,
          tooltip: convertOrFalsy(l.tooltip, this.convertMarkupToLsp),
          location: convertOrFalsy(l.location, this.convertLocation),
          command: l.command ? { ...l.command } : void 0
        })),
        kind: hint.kind,
        tooltip: convertOrFalsy(hint.tooltip, this.convertMarkupToLsp),
        paddingLeft: hint.paddingLeft,
        paddingRight: hint.paddingRight,
        textEdits: mapOrFalsy(hint.textEdits, this.convertTextEdit)
      };
    };
    this.convertIncomingCall = (item) => {
      return {
        from: this.convertCallHierarcgyItemToLsp(item.from),
        fromRanges: item.fromRanges.map(this.convertRangeToLsp)
      };
    };
    this.convertOutgoingCall = (item) => {
      return {
        to: this.convertCallHierarcgyItemToLsp(item.to),
        fromRanges: item.fromRanges.map(this.convertRangeToLsp)
      };
    };
    this.convertFoldingRange = (range) => {
      let kind;
      switch (range.kind) {
        case 1 /* Comment */:
          kind = lsp8.FoldingRangeKind.Comment;
          break;
        case 3 /* Region */:
          kind = lsp8.FoldingRangeKind.Region;
          break;
        case 2 /* Imports */:
          kind = lsp8.FoldingRangeKind.Imports;
          break;
        default:
          break;
      }
      return {
        kind,
        startLine: range.start,
        endLine: range.end
      };
    };
    this.convertSelectionRange = (range) => {
      return {
        range: this.convertRangeToLsp(range.range),
        parent: convertOrFalsy(range.parent, this.convertSelectionRange)
      };
    };
    this.convertCodeLens = (lens, data) => {
      return {
        range: this.convertRangeToLsp(lens.range),
        command: lens.command,
        data
      };
    };
    this.convertSemanticTokens = (tokens) => {
      return { data: Array.from(tokens.data), resultId: tokens.resultId };
    };
    this.convertLinkedEditingRanges = (data) => {
      var _a;
      return {
        ranges: data.ranges.map(this.convertRangeToLsp),
        wordPattern: (_a = data.wordPattern) == null ? void 0 : _a.source
      };
    };
    this.convertCodeAction = this.convertCodeAction.bind(this);
  }
  convertLocations(location, supportLink) {
    if (Array.isArray(location)) {
      return location.map((l) => {
        if ("targetUri" in l) {
          return supportLink ? this.convertLocationLink(l) : this.convertLocationLinkToLocation(l);
        } else {
          return this.convertLocation(l);
        }
      });
    } else {
      return this.convertLocation(location);
    }
  }
  convertCodeAction(action, data) {
    var _a;
    if (typeof action.command === "string") {
      return action;
    } else {
      const ac = action;
      const result = {
        title: ac.title,
        command: ac.command,
        diagnostics: mapOrFalsy(ac.diagnostics, this.convertDiagnosticToLsp),
        kind: (_a = ac.kind) == null ? void 0 : _a.value,
        edit: convertOrFalsy(ac.edit, this.convertWorkspaceEdit),
        isPreferred: ac.isPreferred,
        data
      };
      return result;
    }
  }
};

// src/service/main.ts
init_dispose2();
init_objects2();

// src/service/codeAction.ts
init_types2();
import * as lsp9 from "vscode-languageserver-protocol";

// src/utils/cache.ts
var RestrictedCache = class {
  constructor(maxItems) {
    this.maxItems = maxItems;
    this._store = /* @__PURE__ */ new Map();
    this._isDisposed = false;
    this.maxId = 1;
    this.lastMinId = 0;
  }
  dispose() {
    this._isDisposed = true;
    if (!this._store.size) {
      return;
    }
    this._store.clear();
  }
  has(key) {
    return this._store.has(key);
  }
  get(key) {
    return this._store.get(key);
  }
  store(value) {
    const cacheId = this.maxId++;
    this._store.set(cacheId, value);
    this._clearIfMaxReached();
    return cacheId;
  }
  delete(key) {
    this._store.delete(key);
  }
  _clearIfMaxReached() {
    if (!!this.timer || this._store.size < this.maxItems) {
      return;
    }
    this.timer = setTimeout(() => {
      while (this._store.size > this.maxItems && this.lastMinId < this.maxId) {
        this.lastMinId += 1;
        if (this._store.has(this.lastMinId)) {
          this.delete(this.lastMinId);
        }
      }
      this.timer = void 0;
    }, 100);
  }
};

// src/service/codeAction.ts
init_dispose2();
init_types();
function isCodeAction(item) {
  return typeof item.command != "string";
}
var CodeActionCache = class extends Disposable {
  constructor() {
    super(...arguments);
    this.codeActionCache = this._register(
      new RestrictedCache(12)
    );
  }
  store(items, providerId) {
    const cacheId = this.codeActionCache.store(items);
    return items.map((_, index) => {
      const data = this.createData(providerId, index, cacheId);
      return { data };
    });
  }
  resolveData(data) {
    var _a;
    const { providerId: _providerId, index: _index, cacheId: _cacheId } = data || {};
    if ([_providerId, _index, _cacheId].some(isNil)) {
      return;
    }
    const providerId = _providerId;
    const index = _index;
    const cacheId = _cacheId;
    const cachedItem = (_a = this.codeActionCache.get(cacheId)) == null ? void 0 : _a[index];
    if (!cachedItem) {
      return;
    }
    return { cachedItem, providerId, index, cacheId };
  }
  createData(providerId, index, cacheId) {
    return {
      providerId,
      index,
      cacheId
    };
  }
};
var TSCodeActionFeature = class extends Disposable {
  constructor(registry, configuration, converter, clientCapabilities) {
    super();
    this.registry = registry;
    this.configuration = configuration;
    this.converter = converter;
    this.clientCapabilities = clientCapabilities;
    this.cache = this._register(new CodeActionCache());
  }
  get unsupported_actions() {
    return this.configuration.getConfiguration("vtsls").get("enableMoveToFileCodeAction") ? [] : ["refactor.move.file"];
  }
  async codeAction(doc, params, token) {
    var _a, _b, _c, _d, _e, _f;
    const providers = this.registry.getProviders(doc);
    const ctx = params.context;
    const baseVscCtx = {
      diagnostics: ctx.diagnostics.map(this.converter.convertDiagnosticFromLsp),
      triggerKind: ctx.triggerKind ?? lsp9.CodeActionTriggerKind.Invoked
    };
    const results = [];
    const kinds = ((_a = ctx.only) == null ? void 0 : _a.sort()) ?? [""];
    let lastPrefixi = -1;
    for (let i = 0; i < kinds.length; ++i) {
      const kind = kinds[i];
      if (lastPrefixi >= 0 && kind.startsWith(kinds[lastPrefixi])) {
        continue;
      } else {
        lastPrefixi = i;
      }
      const vscKind = kind ? new CodeActionKind(kind) : void 0;
      const vscCtx = {
        only: vscKind,
        ...baseVscCtx
      };
      for (const { id, provider, args } of providers) {
        if (vscKind && args.metadata && ((_b = args.metadata.providedCodeActionKinds) == null ? void 0 : _b.every((k) => !vscKind.contains(k)))) {
          continue;
        }
        let actions = await provider.provideCodeActions(
          doc,
          Range.of(params.range),
          vscCtx,
          token
        );
        if (!((_d = (_c = this.clientCapabilities.textDocument) == null ? void 0 : _c.codeAction) == null ? void 0 : _d.disabledSupport)) {
          actions = actions == null ? void 0 : actions.filter((item) => !("disabled" in item && item.disabled));
        }
        actions = actions == null ? void 0 : actions.filter(
          (action) => !("kind" in action && action.kind && this.unsupported_actions.includes(action.kind.value))
        );
        if (!actions || actions.length === 0) {
          continue;
        }
        const overrideFields = this.cache.store(actions, id);
        results.push(
          actions.map((action, index) => {
            const converted = this.converter.convertCodeAction(action);
            const { data } = overrideFields[index];
            return isCodeAction(converted) ? { ...converted, data } : converted;
          })
        );
      }
    }
    if (results.length > 0) {
      const flattedResults = results.flat();
      if ((_f = (_e = this.clientCapabilities.textDocument) == null ? void 0 : _e.codeAction) == null ? void 0 : _f.resolveSupport) {
        return flattedResults;
      } else {
        return await Promise.all(
          flattedResults.map(
            (item) => isCodeAction(item) && !item.disabled ? this.codeActionResolve(item, token) : Promise.resolve(item)
          )
        );
      }
    } else {
      return null;
    }
  }
  async codeActionResolve(item, token) {
    const cached = this.cache.resolveData(item.data);
    if (!cached) {
      return item;
    }
    const { providerId, cachedItem } = cached;
    const entry = this.registry.getProviderById(providerId);
    if (!entry || !entry.provider.resolveCodeAction) {
      return item;
    }
    const result = await entry.provider.resolveCodeAction(cachedItem, token);
    if (result) {
      const converted = this.converter.convertCodeAction(result, item.data);
      return converted;
    } else {
      return item;
    }
  }
};

// src/service/completion.ts
init_types2();
import { fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive } from "@vtsls/vscode-fuzzy";
import * as lsp10 from "vscode-languageserver-protocol";
init_dispose2();
init_types();
var _CompletionCache = class _CompletionCache extends Disposable {
  constructor(commands3) {
    super();
    this.completionItemCache = this._register(
      new RestrictedCache(12)
    );
    this._register(
      commands3.registerCommand(_CompletionCache.id, (...args) => {
        var _a;
        const item = (_a = this.resolveData(args[0])) == null ? void 0 : _a.cachedItem;
        if (!item) {
          throw new lsp10.ResponseError(lsp10.ErrorCodes.InvalidParams, "completion item data missing");
        }
        if (item.command && item.command.command !== _CompletionCache.id) {
          return commands3.executeCommand(item.command.command, ...item.command.arguments ?? []);
        }
      })
    );
  }
  store(items, providerId) {
    const cacheId = this.completionItemCache.store(items);
    return items.map((_, index) => {
      const data = this.createData(providerId, index, cacheId);
      return { data, command: { command: _CompletionCache.id, title: "", arguments: [data] } };
    });
  }
  resolveData(data) {
    var _a;
    const { providerId: _providerId, index: _index, cacheId: _cacheId } = data || {};
    if ([_providerId, _index, _cacheId].some(isNil)) {
      return;
    }
    const providerId = _providerId;
    const index = _index;
    const cacheId = _cacheId;
    const cachedItem = (_a = this.completionItemCache.get(cacheId)) == null ? void 0 : _a[index];
    if (!cachedItem) {
      return;
    }
    return { cachedItem, providerId, index, cacheId };
  }
  createData(providerId, index, cacheId) {
    return {
      providerId,
      index,
      cacheId
    };
  }
};
_CompletionCache.id = "_vtsls.completionCacheCommand";
var CompletionCache = _CompletionCache;
var TSCompletionFeature = class extends Disposable {
  constructor(registry, configuration, commands3, converter) {
    super();
    this.registry = registry;
    this.configuration = configuration;
    this.converter = converter;
    this.lastCompleteResult = null;
    this.cache = this._register(new CompletionCache(commands3));
  }
  async completion(doc, params, token) {
    var _a;
    const experimentalCompletionConfig = this.configuration.getConfiguration(
      "vtsls.experimental.completion"
    );
    const enableServerSideFuzzyMatch = experimentalCompletionConfig.get(
      "enableServerSideFuzzyMatch"
    );
    const entriesLimit = experimentalCompletionConfig.get("entriesLimit");
    const pos = Position.of(params.position);
    const wordRange = doc.getWordRangeAtPosition(pos);
    const leadingLineContent = doc.getText(new Range(pos.line, 0, pos.line, pos.character));
    let results = [];
    let isIncomplete = false;
    if (((_a = params.context) == null ? void 0 : _a.triggerKind) === lsp10.CompletionTriggerKind.TriggerForIncompleteCompletions && this.lastCompleteResult) {
      results = this.lastCompleteResult;
    } else {
      const providers = this.registry.getProviders(doc);
      const ctx = params.context ? {
        triggerKind: params.context.triggerKind - 1,
        triggerCharacter: params.context.triggerCharacter
      } : {
        triggerKind: 0 /* Invoke */,
        triggerCharacter: void 0
      };
      const inWord = wordRange == null ? void 0 : wordRange.contains(new Position(pos.line, pos.character - 1));
      for (const {
        id: providerId,
        provider,
        args: { triggerCharacters }
      } of providers) {
        const checkTriggerCharacter = ctx.triggerCharacter && triggerCharacters.includes(ctx.triggerCharacter);
        if (ctx.triggerKind === 1 /* TriggerCharacter */ && !checkTriggerCharacter && !inWord) {
          continue;
        }
        const items = await provider.provideCompletionItems(doc, pos, token, ctx);
        if (!items) {
          continue;
        }
        let itemsArr;
        if (Array.isArray(items)) {
          itemsArr = items;
        } else {
          isIncomplete = isIncomplete || Boolean(items.isIncomplete);
          itemsArr = items.items;
        }
        if (itemsArr.length === 0) {
          continue;
        }
        results.push({ items: itemsArr, providerId });
      }
      this.lastCompleteResult = isIncomplete ? null : results;
    }
    const shouldFuzzy = enableServerSideFuzzyMatch && wordRange;
    const fuzzyScorer = shouldFuzzy ? this.getCompletionItemFuzzyScorer(
      results.map((r) => r.items.length).reduce((a, b) => a + b),
      pos,
      wordRange,
      leadingLineContent
    ) : () => void 0;
    let resultItems = [];
    for (const { items, providerId } of results) {
      const overrideFields = this.cache.store(items, providerId);
      for (let i = 0; i < items.length; ++i) {
        const { data, command } = overrideFields[i];
        const item = items[i];
        const match = fuzzyScorer(item);
        const converted = this.converter.convertCompletionItem(items[i], {
          ...data,
          // attach match result in data for trimming
          match
        });
        resultItems.push({
          ...converted,
          command
        });
      }
    }
    if (!isNil(entriesLimit) && resultItems.length > entriesLimit) {
      isIncomplete = true;
      if (shouldFuzzy) {
        resultItems = resultItems.filter(
          (item) => Boolean(item.data.match)
        );
      }
      if (resultItems.length > entriesLimit) {
        resultItems = this.trimCompletionItems(resultItems, entriesLimit);
      }
    }
    return lsp10.CompletionList.create(resultItems, isIncomplete);
  }
  async completionItemResolve(item, token) {
    const cached = this.cache.resolveData(item.data);
    if (!cached) {
      return item;
    }
    const { cachedItem, providerId } = cached;
    const entry = this.registry.getProviderById(providerId);
    if (!entry || !entry.provider.resolveCompletionItem) {
      return item;
    }
    const result = await entry.provider.resolveCompletionItem(cachedItem, token);
    if (result) {
      const converted = this.converter.convertCompletionItem(result, item.data);
      converted.command = item.command;
      return converted;
    } else {
      return item;
    }
  }
  getCompletionItemFuzzyScorer(itemsLen, position, wordRange, leadingLineContent) {
    const scoreFn = itemsLen > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
    let word = "";
    let wordLow = "";
    return (item) => {
      var _a, _b;
      const editStartColumn = item.range ? Range.isRange(item.range) ? item.range.start.character : (_a = item.range) == null ? void 0 : _a.inserting.start.character : (wordRange == null ? void 0 : wordRange.start.character) ?? position.character;
      const wordLen = position.character - editStartColumn;
      if (word.length !== wordLen) {
        word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
        wordLow = word.toLowerCase();
      }
      if (wordLen === 0) {
        return FuzzyScore.Default;
      } else {
        let wordPos = 0;
        while (wordPos < wordLen) {
          const ch = word.charCodeAt(wordPos);
          if (isWhitespace(ch)) {
            wordPos += 1;
          } else {
            break;
          }
        }
        if (wordPos >= wordLen) {
          return FuzzyScore.Default;
        }
        if (typeof item.filterText === "string") {
          const match = scoreFn(
            word,
            wordLow,
            wordPos,
            item.filterText,
            item.filterText.toLowerCase(),
            0
          );
          return match;
        } else {
          const textLabel = typeof item.label === "string" ? item.label : (_b = item.label) == null ? void 0 : _b.label;
          const match = scoreFn(word, wordLow, wordPos, textLabel, textLabel.toLowerCase(), 0);
          return match;
        }
      }
    };
  }
  trimCompletionItems(items, limit) {
    const wrappedItems = items.map((item, idx) => {
      var _a;
      return {
        item,
        idx,
        sortText: item.sortText ?? item.label,
        // use fuzzy matched score if possible
        match: (_a = item.data) == null ? void 0 : _a.match
      };
    });
    wrappedItems.sort((a, b) => {
      if (a.match && b.match) {
        if (a.match[0] < b.match[0]) {
          return 1;
        } else if (a.match[0] > b.match[0]) {
          return -1;
        } else if (a.match[1] < b.match[1]) {
          return -1;
        } else if (a.match[1] > b.match[1]) {
          return 1;
        }
      }
      if (a.sortText < b.sortText) {
        return -1;
      } else if (a.sortText > b.sortText) {
        return 1;
      } else {
        return a.idx - b.idx;
      }
    });
    return wrappedItems.slice(0, limit).map((v) => v.item);
  }
};
function isWhitespace(code) {
  return code === 32 || code === 9;
}

// src/service/delegate.ts
import * as lsp11 from "vscode-languageserver-protocol";
function createTSLanguageServiceDelegate(converter) {
  const eventHandlers = {};
  function onHandler(event) {
    return (handler) => {
      eventHandlers[event] = handler;
      return lsp11.Disposable.create(() => {
        if (eventHandlers[event] === handler) {
          delete eventHandlers[event];
        }
      });
    };
  }
  function getHandler(event) {
    return eventHandlers[event];
  }
  const events = {
    onShowDocument: onHandler("showDocument"),
    onLogMessage: onHandler("logMessage"),
    onLogTrace: onHandler("logTrace"),
    onShowMessage: onHandler("showMessage"),
    onApplyWorkspaceEdit: onHandler("applyWorkspaceEdit"),
    onWorkDoneProgress: onHandler("workDoneProgress"),
    onDiagnostics: onHandler("diagnostics")
  };
  const delegate = {
    converter,
    async openExternal(uri) {
      const handler = getHandler("showDocument");
      if (handler) {
        return await handler({ uri, external: true });
      }
      return false;
    },
    async openTextDocument(uri, focus) {
      const handler = getHandler("showDocument");
      if (handler) {
        return await handler({ uri, external: false, takeFocus: focus });
      }
      return false;
    },
    async applyWorkspaceEdit(edit) {
      const handler = getHandler("applyWorkspaceEdit");
      if (handler) {
        const result = await handler({ edit });
        return result.applied;
      }
      return false;
    },
    logMessage(type, message) {
      const handler = getHandler("logMessage");
      if (handler) {
        handler({ type, message });
      }
    },
    logTrace(message) {
      const handler = getHandler("logTrace");
      if (handler) {
        handler({ message });
      }
    },
    async showMessage(type, message, ...actions) {
      const handler = getHandler("showMessage");
      if (handler) {
        return await handler({ type, message, actions });
      }
      return null;
    },
    async createWorkDoneProgress() {
      const handler = getHandler("workDoneProgress");
      if (handler) {
        return await handler();
      }
    },
    publishDiagnostics(uri, diagnostics) {
      const handler = getHandler("diagnostics");
      if (handler) {
        void handler({ uri, diagnostics });
      }
    }
  };
  return { events, delegate };
}

// src/service/inlayHint.ts
init_types();
var TSInlayHintFeature = class {
  constructor(registry, configuration, converter) {
    this.registry = registry;
    this.configuration = configuration;
    this.converter = converter;
  }
  async inlayHint(doc, params, token) {
    const maxHintLength = this.configuration.getConfiguration("vtsls.experimental").get("maxInlayHintLength");
    const { provider } = this.registry.getHighestProvider(doc);
    const result = await provider.provideInlayHints(
      doc,
      this.converter.convertRangeFromLsp(params.range),
      token
    );
    if (!result) {
      return;
    }
    let converted = result.map(this.converter.convertInlayHint);
    if (!isNil(maxHintLength)) {
      const ellipsis = "\u2026";
      converted = converted.map((hint) => {
        const originalLabel = hint.label;
        const { truncated, label } = truncateLabel(
          originalLabel,
          Math.max(maxHintLength, ellipsis.length),
          ellipsis
        );
        if (truncated) {
          hint.label = label;
          hint.data = { originalLabel };
        }
        return hint;
      });
    }
    return converted;
  }
};
function truncateLabel(label, limit, ellipsis) {
  if (typeof label == "string") {
    if (label.length <= limit) {
      return { truncated: false, label };
    } else {
      return {
        truncated: true,
        label: `${label.substring(0, limit - ellipsis.length)}${ellipsis}`
      };
    }
  }
  const withInLimit = label.reduce((labelLength, part) => labelLength + part.value.length, 0) <= limit;
  if (withInLimit) {
    return { truncated: false, label };
  }
  let labelRemaining = limit - ellipsis.length;
  const labelParts = [];
  for (const part of label) {
    if (part.value.length < labelRemaining) {
      labelParts.push(part);
      labelRemaining -= part.value.length;
    } else {
      labelParts.push({
        ...part,
        value: `${part.value.substring(0, labelRemaining)}${ellipsis}`
      });
      break;
    }
  }
  return { truncated: true, label: labelParts };
}

// src/typescript-language-features/package.json
var activationEvents = [
  "onLanguage:javascript",
  "onLanguage:javascriptreact",
  "onLanguage:typescript",
  "onLanguage:typescriptreact",
  "onLanguage:jsx-tags",
  "onCommand:typescript.tsserverRequest",
  "onCommand:_typescript.configurePlugin",
  "onCommand:_typescript.learnMoreAboutRefactorings",
  "onCommand:typescript.findAllFileReferences",
  "onTaskType:typescript",
  "onLanguage:jsonc",
  "onWalkthrough:nodejsWelcome"
];
var contributes = {
  jsonValidation: [
    {
      fileMatch: "package.json",
      url: "./schemas/package.schema.json"
    },
    {
      fileMatch: "tsconfig.json",
      url: "https://json.schemastore.org/tsconfig"
    },
    {
      fileMatch: "tsconfig.json",
      url: "./schemas/tsconfig.schema.json"
    },
    {
      fileMatch: "tsconfig.*.json",
      url: "https://json.schemastore.org/tsconfig"
    },
    {
      fileMatch: "tsconfig-*.json",
      url: "./schemas/tsconfig.schema.json"
    },
    {
      fileMatch: "tsconfig-*.json",
      url: "https://json.schemastore.org/tsconfig"
    },
    {
      fileMatch: "tsconfig.*.json",
      url: "./schemas/tsconfig.schema.json"
    },
    {
      fileMatch: "typings.json",
      url: "https://json.schemastore.org/typings"
    },
    {
      fileMatch: ".bowerrc",
      url: "https://json.schemastore.org/bowerrc"
    },
    {
      fileMatch: ".babelrc",
      url: "https://json.schemastore.org/babelrc"
    },
    {
      fileMatch: ".babelrc.json",
      url: "https://json.schemastore.org/babelrc"
    },
    {
      fileMatch: "babel.config.json",
      url: "https://json.schemastore.org/babelrc"
    },
    {
      fileMatch: "jsconfig.json",
      url: "https://json.schemastore.org/jsconfig"
    },
    {
      fileMatch: "jsconfig.json",
      url: "./schemas/jsconfig.schema.json"
    },
    {
      fileMatch: "jsconfig.*.json",
      url: "https://json.schemastore.org/jsconfig"
    },
    {
      fileMatch: "jsconfig.*.json",
      url: "./schemas/jsconfig.schema.json"
    },
    {
      fileMatch: ".swcrc",
      url: "https://swc.rs/schema.json"
    },
    {
      fileMatch: "typedoc.json",
      url: "https://typedoc.org/schema.json"
    }
  ],
  configuration: {
    type: "object",
    title: "%configuration.typescript%",
    order: 20,
    properties: {
      "typescript.tsdk": {
        type: "string",
        markdownDescription: "%typescript.tsdk.desc%",
        scope: "window"
      },
      "typescript.disableAutomaticTypeAcquisition": {
        type: "boolean",
        default: false,
        markdownDescription: "%typescript.disableAutomaticTypeAcquisition%",
        scope: "window",
        tags: [
          "usesOnlineServices"
        ]
      },
      "typescript.enablePromptUseWorkspaceTsdk": {
        type: "boolean",
        default: false,
        description: "%typescript.enablePromptUseWorkspaceTsdk%",
        scope: "window"
      },
      "typescript.npm": {
        type: "string",
        markdownDescription: "%typescript.npm%",
        scope: "machine"
      },
      "typescript.check.npmIsInstalled": {
        type: "boolean",
        default: true,
        markdownDescription: "%typescript.check.npmIsInstalled%",
        scope: "window"
      },
      "javascript.referencesCodeLens.enabled": {
        type: "boolean",
        default: false,
        description: "%javascript.referencesCodeLens.enabled%",
        scope: "window"
      },
      "javascript.referencesCodeLens.showOnAllFunctions": {
        type: "boolean",
        default: false,
        description: "%javascript.referencesCodeLens.showOnAllFunctions%",
        scope: "window"
      },
      "typescript.referencesCodeLens.enabled": {
        type: "boolean",
        default: false,
        description: "%typescript.referencesCodeLens.enabled%",
        scope: "window"
      },
      "typescript.referencesCodeLens.showOnAllFunctions": {
        type: "boolean",
        default: false,
        description: "%typescript.referencesCodeLens.showOnAllFunctions%",
        scope: "window"
      },
      "typescript.implementationsCodeLens.enabled": {
        type: "boolean",
        default: false,
        description: "%typescript.implementationsCodeLens.enabled%",
        scope: "window"
      },
      "typescript.implementationsCodeLens.showOnInterfaceMethods": {
        type: "boolean",
        default: false,
        description: "%typescript.implementationsCodeLens.showOnInterfaceMethods%",
        scope: "window"
      },
      "typescript.tsserver.enableTracing": {
        type: "boolean",
        default: false,
        description: "%typescript.tsserver.enableTracing%",
        scope: "window"
      },
      "typescript.tsserver.log": {
        type: "string",
        enum: [
          "off",
          "terse",
          "normal",
          "verbose"
        ],
        default: "off",
        description: "%typescript.tsserver.log%",
        scope: "window"
      },
      "typescript.tsserver.pluginPaths": {
        type: "array",
        items: {
          type: "string",
          description: "%typescript.tsserver.pluginPaths.item%"
        },
        default: [],
        description: "%typescript.tsserver.pluginPaths%",
        scope: "machine"
      },
      "javascript.suggest.completeFunctionCalls": {
        type: "boolean",
        default: false,
        description: "%configuration.suggest.completeFunctionCalls%",
        scope: "resource"
      },
      "typescript.suggest.completeFunctionCalls": {
        type: "boolean",
        default: false,
        description: "%configuration.suggest.completeFunctionCalls%",
        scope: "resource"
      },
      "javascript.suggest.includeAutomaticOptionalChainCompletions": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.includeAutomaticOptionalChainCompletions%",
        scope: "resource"
      },
      "typescript.suggest.includeAutomaticOptionalChainCompletions": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.includeAutomaticOptionalChainCompletions%",
        scope: "resource"
      },
      "typescript.inlayHints.parameterNames.enabled": {
        type: "string",
        enum: [
          "none",
          "literals",
          "all"
        ],
        enumDescriptions: [
          "%inlayHints.parameterNames.none%",
          "%inlayHints.parameterNames.literals%",
          "%inlayHints.parameterNames.all%"
        ],
        default: "none",
        markdownDescription: "%configuration.inlayHints.parameterNames.enabled%",
        scope: "resource"
      },
      "typescript.inlayHints.parameterNames.suppressWhenArgumentMatchesName": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.inlayHints.parameterNames.suppressWhenArgumentMatchesName%",
        scope: "resource"
      },
      "typescript.inlayHints.parameterTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.parameterTypes.enabled%",
        scope: "resource"
      },
      "typescript.inlayHints.variableTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.variableTypes.enabled%",
        scope: "resource"
      },
      "typescript.inlayHints.variableTypes.suppressWhenTypeMatchesName": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.inlayHints.variableTypes.suppressWhenTypeMatchesName%",
        scope: "resource"
      },
      "typescript.inlayHints.propertyDeclarationTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.propertyDeclarationTypes.enabled%",
        scope: "resource"
      },
      "typescript.inlayHints.functionLikeReturnTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.functionLikeReturnTypes.enabled%",
        scope: "resource"
      },
      "typescript.inlayHints.enumMemberValues.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.enumMemberValues.enabled%",
        scope: "resource"
      },
      "javascript.inlayHints.parameterNames.enabled": {
        type: "string",
        enum: [
          "none",
          "literals",
          "all"
        ],
        enumDescriptions: [
          "%inlayHints.parameterNames.none%",
          "%inlayHints.parameterNames.literals%",
          "%inlayHints.parameterNames.all%"
        ],
        default: "none",
        markdownDescription: "%configuration.inlayHints.parameterNames.enabled%",
        scope: "resource"
      },
      "javascript.inlayHints.parameterNames.suppressWhenArgumentMatchesName": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.inlayHints.parameterNames.suppressWhenArgumentMatchesName%",
        scope: "resource"
      },
      "javascript.inlayHints.parameterTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.parameterTypes.enabled%",
        scope: "resource"
      },
      "javascript.inlayHints.variableTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.variableTypes.enabled%",
        scope: "resource"
      },
      "javascript.inlayHints.variableTypes.suppressWhenTypeMatchesName": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.inlayHints.variableTypes.suppressWhenTypeMatchesName%",
        scope: "resource"
      },
      "javascript.inlayHints.propertyDeclarationTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.propertyDeclarationTypes.enabled%",
        scope: "resource"
      },
      "javascript.inlayHints.functionLikeReturnTypes.enabled": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.inlayHints.functionLikeReturnTypes.enabled%",
        scope: "resource"
      },
      "javascript.suggest.includeCompletionsForImportStatements": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.includeCompletionsForImportStatements%",
        scope: "resource"
      },
      "typescript.suggest.includeCompletionsForImportStatements": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.includeCompletionsForImportStatements%",
        scope: "resource"
      },
      "typescript.reportStyleChecksAsWarnings": {
        type: "boolean",
        default: true,
        description: "%typescript.reportStyleChecksAsWarnings%",
        scope: "window"
      },
      "typescript.validate.enable": {
        type: "boolean",
        default: true,
        description: "%typescript.validate.enable%",
        scope: "window"
      },
      "typescript.format.enable": {
        type: "boolean",
        default: true,
        description: "%typescript.format.enable%",
        scope: "window"
      },
      "typescript.format.insertSpaceAfterCommaDelimiter": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterCommaDelimiter%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterConstructor": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterConstructor%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterSemicolonInForStatements": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterSemicolonInForStatements%",
        scope: "resource"
      },
      "typescript.format.insertSpaceBeforeAndAfterBinaryOperators": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceBeforeAndAfterBinaryOperators%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterKeywordsInControlFlowStatements": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterKeywordsInControlFlowStatements%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterFunctionKeywordForAnonymousFunctions%",
        scope: "resource"
      },
      "typescript.format.insertSpaceBeforeFunctionParenthesis": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceBeforeFunctionParenthesis%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces%",
        scope: "resource"
      },
      "typescript.format.insertSpaceAfterTypeAssertion": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterTypeAssertion%",
        scope: "resource"
      },
      "typescript.format.placeOpenBraceOnNewLineForFunctions": {
        type: "boolean",
        default: false,
        description: "%format.placeOpenBraceOnNewLineForFunctions%",
        scope: "resource"
      },
      "typescript.format.placeOpenBraceOnNewLineForControlBlocks": {
        type: "boolean",
        default: false,
        description: "%format.placeOpenBraceOnNewLineForControlBlocks%",
        scope: "resource"
      },
      "typescript.format.semicolons": {
        type: "string",
        default: "ignore",
        description: "%format.semicolons%",
        scope: "resource",
        enum: [
          "ignore",
          "insert",
          "remove"
        ],
        enumDescriptions: [
          "%format.semicolons.ignore%",
          "%format.semicolons.insert%",
          "%format.semicolons.remove%"
        ]
      },
      "typescript.format.indentSwitchCase": {
        type: "boolean",
        default: true,
        description: "%format.indentSwitchCase%",
        scope: "resource"
      },
      "javascript.validate.enable": {
        type: "boolean",
        default: true,
        description: "%javascript.validate.enable%",
        scope: "window"
      },
      "javascript.format.enable": {
        type: "boolean",
        default: true,
        description: "%javascript.format.enable%",
        scope: "window"
      },
      "javascript.format.insertSpaceAfterCommaDelimiter": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterCommaDelimiter%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterConstructor": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterConstructor%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterSemicolonInForStatements": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterSemicolonInForStatements%",
        scope: "resource"
      },
      "javascript.format.insertSpaceBeforeAndAfterBinaryOperators": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceBeforeAndAfterBinaryOperators%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterKeywordsInControlFlowStatements": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterKeywordsInControlFlowStatements%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterFunctionKeywordForAnonymousFunctions%",
        scope: "resource"
      },
      "javascript.format.insertSpaceBeforeFunctionParenthesis": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceBeforeFunctionParenthesis%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": {
        type: "boolean",
        default: true,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces%",
        scope: "resource"
      },
      "javascript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces": {
        type: "boolean",
        default: false,
        description: "%format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces%",
        scope: "resource"
      },
      "javascript.format.placeOpenBraceOnNewLineForFunctions": {
        type: "boolean",
        default: false,
        description: "%format.placeOpenBraceOnNewLineForFunctions%",
        scope: "resource"
      },
      "javascript.format.placeOpenBraceOnNewLineForControlBlocks": {
        type: "boolean",
        default: false,
        description: "%format.placeOpenBraceOnNewLineForControlBlocks%",
        scope: "resource"
      },
      "javascript.format.semicolons": {
        type: "string",
        default: "ignore",
        description: "%format.semicolons%",
        scope: "resource",
        enum: [
          "ignore",
          "insert",
          "remove"
        ],
        enumDescriptions: [
          "%format.semicolons.ignore%",
          "%format.semicolons.insert%",
          "%format.semicolons.remove%"
        ]
      },
      "js/ts.implicitProjectConfig.module": {
        type: "string",
        markdownDescription: "%configuration.implicitProjectConfig.module%",
        default: "ESNext",
        enum: [
          "CommonJS",
          "AMD",
          "System",
          "UMD",
          "ES6",
          "ES2015",
          "ES2020",
          "ESNext",
          "None",
          "ES2022",
          "Node12",
          "NodeNext"
        ],
        scope: "window"
      },
      "js/ts.implicitProjectConfig.target": {
        type: "string",
        default: "ES2022",
        markdownDescription: "%configuration.implicitProjectConfig.target%",
        enum: [
          "ES3",
          "ES5",
          "ES6",
          "ES2015",
          "ES2016",
          "ES2017",
          "ES2018",
          "ES2019",
          "ES2020",
          "ES2021",
          "ES2022",
          "ES2023",
          "ES2024",
          "ESNext"
        ],
        scope: "window"
      },
      "javascript.implicitProjectConfig.checkJs": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.implicitProjectConfig.checkJs%",
        markdownDeprecationMessage: "%configuration.javascript.checkJs.checkJs.deprecation%",
        scope: "window"
      },
      "js/ts.implicitProjectConfig.checkJs": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.implicitProjectConfig.checkJs%",
        scope: "window"
      },
      "javascript.implicitProjectConfig.experimentalDecorators": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.implicitProjectConfig.experimentalDecorators%",
        markdownDeprecationMessage: "%configuration.javascript.checkJs.experimentalDecorators.deprecation%",
        scope: "window"
      },
      "js/ts.implicitProjectConfig.experimentalDecorators": {
        type: "boolean",
        default: false,
        markdownDescription: "%configuration.implicitProjectConfig.experimentalDecorators%",
        scope: "window"
      },
      "js/ts.implicitProjectConfig.strictNullChecks": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.implicitProjectConfig.strictNullChecks%",
        scope: "window"
      },
      "js/ts.implicitProjectConfig.strictFunctionTypes": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.implicitProjectConfig.strictFunctionTypes%",
        scope: "window"
      },
      "javascript.suggest.names": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.suggest.names%",
        scope: "resource"
      },
      "typescript.tsc.autoDetect": {
        type: "string",
        default: "on",
        enum: [
          "on",
          "off",
          "build",
          "watch"
        ],
        markdownEnumDescriptions: [
          "%typescript.tsc.autoDetect.on%",
          "%typescript.tsc.autoDetect.off%",
          "%typescript.tsc.autoDetect.build%",
          "%typescript.tsc.autoDetect.watch%"
        ],
        description: "%typescript.tsc.autoDetect%",
        scope: "window"
      },
      "javascript.suggest.paths": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.paths%",
        scope: "resource"
      },
      "typescript.suggest.paths": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.paths%",
        scope: "resource"
      },
      "javascript.suggest.autoImports": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.autoImports%",
        scope: "resource"
      },
      "typescript.suggest.autoImports": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.autoImports%",
        scope: "resource"
      },
      "javascript.suggest.completeJSDocs": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.completeJSDocs%",
        scope: "language-overridable"
      },
      "typescript.suggest.completeJSDocs": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.completeJSDocs%",
        scope: "language-overridable"
      },
      "javascript.suggest.jsdoc.generateReturns": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.suggest.jsdoc.generateReturns%",
        scope: "language-overridable"
      },
      "typescript.suggest.jsdoc.generateReturns": {
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.suggest.jsdoc.generateReturns%",
        scope: "language-overridable"
      },
      "typescript.locale": {
        type: "string",
        default: "auto",
        enum: [
          "auto",
          "de",
          "es",
          "en",
          "fr",
          "it",
          "ja",
          "ko",
          "ru",
          "zh-CN",
          "zh-TW"
        ],
        enumDescriptions: [
          "%typescript.locale.auto%",
          "Deutsch",
          "espa\xF1ol",
          "English",
          "fran\xE7ais",
          "italiano",
          "\u65E5\u672C\u8A9E",
          "\uD55C\uAD6D\uC5B4",
          "\u0440\u0443\u0441\u0441\u043A\u0438\u0439",
          "\u4E2D\u6587(\u7B80\u4F53)",
          "\u4E2D\u6587(\u7E41\u9AD4)"
        ],
        markdownDescription: "%typescript.locale%",
        scope: "window"
      },
      "javascript.suggestionActions.enabled": {
        type: "boolean",
        default: true,
        description: "%javascript.suggestionActions.enabled%",
        scope: "resource"
      },
      "typescript.suggestionActions.enabled": {
        type: "boolean",
        default: true,
        description: "%typescript.suggestionActions.enabled%",
        scope: "resource"
      },
      "javascript.preferences.quoteStyle": {
        type: "string",
        enum: [
          "auto",
          "single",
          "double"
        ],
        default: "auto",
        markdownDescription: "%typescript.preferences.quoteStyle%",
        markdownEnumDescriptions: [
          "%typescript.preferences.quoteStyle.auto%",
          "%typescript.preferences.quoteStyle.single%",
          "%typescript.preferences.quoteStyle.double%"
        ],
        scope: "language-overridable"
      },
      "typescript.preferences.quoteStyle": {
        type: "string",
        enum: [
          "auto",
          "single",
          "double"
        ],
        default: "auto",
        markdownDescription: "%typescript.preferences.quoteStyle%",
        markdownEnumDescriptions: [
          "%typescript.preferences.quoteStyle.auto%",
          "%typescript.preferences.quoteStyle.single%",
          "%typescript.preferences.quoteStyle.double%"
        ],
        scope: "language-overridable"
      },
      "javascript.preferences.importModuleSpecifier": {
        type: "string",
        enum: [
          "shortest",
          "relative",
          "non-relative",
          "project-relative"
        ],
        markdownEnumDescriptions: [
          "%typescript.preferences.importModuleSpecifier.shortest%",
          "%typescript.preferences.importModuleSpecifier.relative%",
          "%typescript.preferences.importModuleSpecifier.nonRelative%",
          "%typescript.preferences.importModuleSpecifier.projectRelative%"
        ],
        default: "shortest",
        description: "%typescript.preferences.importModuleSpecifier%",
        scope: "language-overridable"
      },
      "typescript.preferences.importModuleSpecifier": {
        type: "string",
        enum: [
          "shortest",
          "relative",
          "non-relative",
          "project-relative"
        ],
        markdownEnumDescriptions: [
          "%typescript.preferences.importModuleSpecifier.shortest%",
          "%typescript.preferences.importModuleSpecifier.relative%",
          "%typescript.preferences.importModuleSpecifier.nonRelative%",
          "%typescript.preferences.importModuleSpecifier.projectRelative%"
        ],
        default: "shortest",
        description: "%typescript.preferences.importModuleSpecifier%",
        scope: "language-overridable"
      },
      "javascript.preferences.importModuleSpecifierEnding": {
        type: "string",
        enum: [
          "auto",
          "minimal",
          "index",
          "js"
        ],
        enumItemLabels: [
          null,
          null,
          null,
          "%typescript.preferences.importModuleSpecifierEnding.label.js%"
        ],
        markdownEnumDescriptions: [
          "%typescript.preferences.importModuleSpecifierEnding.auto%",
          "%typescript.preferences.importModuleSpecifierEnding.minimal%",
          "%typescript.preferences.importModuleSpecifierEnding.index%",
          "%typescript.preferences.importModuleSpecifierEnding.js%"
        ],
        default: "auto",
        description: "%typescript.preferences.importModuleSpecifierEnding%",
        scope: "language-overridable"
      },
      "typescript.preferences.importModuleSpecifierEnding": {
        type: "string",
        enum: [
          "auto",
          "minimal",
          "index",
          "js"
        ],
        enumItemLabels: [
          null,
          null,
          null,
          "%typescript.preferences.importModuleSpecifierEnding.label.js%"
        ],
        markdownEnumDescriptions: [
          "%typescript.preferences.importModuleSpecifierEnding.auto%",
          "%typescript.preferences.importModuleSpecifierEnding.minimal%",
          "%typescript.preferences.importModuleSpecifierEnding.index%",
          "%typescript.preferences.importModuleSpecifierEnding.js%"
        ],
        default: "auto",
        description: "%typescript.preferences.importModuleSpecifierEnding%",
        scope: "language-overridable"
      },
      "javascript.preferences.jsxAttributeCompletionStyle": {
        type: "string",
        enum: [
          "auto",
          "braces",
          "none"
        ],
        markdownEnumDescriptions: [
          "%javascript.preferences.jsxAttributeCompletionStyle.auto%",
          "%typescript.preferences.jsxAttributeCompletionStyle.braces%",
          "%typescript.preferences.jsxAttributeCompletionStyle.none%"
        ],
        default: "auto",
        description: "%typescript.preferences.jsxAttributeCompletionStyle%",
        scope: "language-overridable"
      },
      "typescript.preferences.jsxAttributeCompletionStyle": {
        type: "string",
        enum: [
          "auto",
          "braces",
          "none"
        ],
        markdownEnumDescriptions: [
          "%typescript.preferences.jsxAttributeCompletionStyle.auto%",
          "%typescript.preferences.jsxAttributeCompletionStyle.braces%",
          "%typescript.preferences.jsxAttributeCompletionStyle.none%"
        ],
        default: "auto",
        description: "%typescript.preferences.jsxAttributeCompletionStyle%",
        scope: "language-overridable"
      },
      "typescript.preferences.includePackageJsonAutoImports": {
        type: "string",
        enum: [
          "auto",
          "on",
          "off"
        ],
        enumDescriptions: [
          "%typescript.preferences.includePackageJsonAutoImports.auto%",
          "%typescript.preferences.includePackageJsonAutoImports.on%",
          "%typescript.preferences.includePackageJsonAutoImports.off%"
        ],
        default: "auto",
        markdownDescription: "%typescript.preferences.includePackageJsonAutoImports%",
        scope: "window"
      },
      "typescript.preferences.autoImportFileExcludePatterns": {
        type: "array",
        items: {
          type: "string"
        },
        markdownDescription: "%typescript.preferences.autoImportFileExcludePatterns%",
        scope: "resource"
      },
      "javascript.preferences.autoImportFileExcludePatterns": {
        type: "array",
        items: {
          type: "string"
        },
        markdownDescription: "%typescript.preferences.autoImportFileExcludePatterns%",
        scope: "resource"
      },
      "typescript.preferences.autoImportSpecifierExcludeRegexes": {
        type: "array",
        items: {
          type: "string"
        },
        markdownDescription: "%typescript.preferences.autoImportSpecifierExcludeRegexes%",
        scope: "resource"
      },
      "javascript.preferences.autoImportSpecifierExcludeRegexes": {
        type: "array",
        items: {
          type: "string"
        },
        markdownDescription: "%typescript.preferences.autoImportSpecifierExcludeRegexes%",
        scope: "resource"
      },
      "typescript.preferences.preferTypeOnlyAutoImports": {
        type: "boolean",
        default: false,
        markdownDescription: "%typescript.preferences.preferTypeOnlyAutoImports%",
        scope: "resource"
      },
      "javascript.preferences.renameShorthandProperties": {
        type: "boolean",
        default: true,
        description: "%typescript.preferences.useAliasesForRenames%",
        deprecationMessage: "%typescript.preferences.renameShorthandProperties.deprecationMessage%",
        scope: "language-overridable"
      },
      "typescript.preferences.renameShorthandProperties": {
        type: "boolean",
        default: true,
        description: "%typescript.preferences.useAliasesForRenames%",
        deprecationMessage: "%typescript.preferences.renameShorthandProperties.deprecationMessage%",
        scope: "language-overridable"
      },
      "javascript.preferences.useAliasesForRenames": {
        type: "boolean",
        default: true,
        description: "%typescript.preferences.useAliasesForRenames%",
        scope: "language-overridable"
      },
      "typescript.preferences.useAliasesForRenames": {
        type: "boolean",
        default: true,
        description: "%typescript.preferences.useAliasesForRenames%",
        scope: "language-overridable"
      },
      "javascript.preferences.renameMatchingJsxTags": {
        type: "boolean",
        default: true,
        description: "%typescript.preferences.renameMatchingJsxTags%",
        scope: "language-overridable"
      },
      "typescript.preferences.renameMatchingJsxTags": {
        type: "boolean",
        default: true,
        description: "%typescript.preferences.renameMatchingJsxTags%",
        scope: "language-overridable"
      },
      "typescript.preferences.organizeImports": {
        type: "object",
        markdownDescription: "%typescript.preferences.organizeImports%",
        properties: {
          caseSensitivity: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.caseSensitivity%",
            enum: [
              "auto",
              "caseInsensitive",
              "caseSensitive"
            ],
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.caseSensitivity.auto%",
              "%typescript.preferences.organizeImports.caseSensitivity.insensitive",
              "%typescript.preferences.organizeImports.caseSensitivity.sensitive%"
            ],
            default: "auto"
          },
          typeOrder: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.typeOrder%",
            enum: [
              "auto",
              "last",
              "inline",
              "first"
            ],
            default: "auto",
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.typeOrder.auto%",
              "%typescript.preferences.organizeImports.typeOrder.last%",
              "%typescript.preferences.organizeImports.typeOrder.inline%",
              "%typescript.preferences.organizeImports.typeOrder.first%"
            ]
          },
          unicodeCollation: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.unicodeCollation%",
            enum: [
              "ordinal",
              "unicode"
            ],
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.unicodeCollation.ordinal%",
              "%typescript.preferences.organizeImports.unicodeCollation.unicode%"
            ],
            default: "ordinal"
          },
          locale: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.locale%"
          },
          numericCollation: {
            type: "boolean",
            markdownDescription: "%typescript.preferences.organizeImports.numericCollation%"
          },
          accentCollation: {
            type: "boolean",
            markdownDescription: "%typescript.preferences.organizeImports.accentCollation%"
          },
          caseFirst: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.caseFirst%",
            enum: [
              "default",
              "upper",
              "lower"
            ],
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.caseFirst.default%",
              "%typescript.preferences.organizeImports.caseFirst.upper%",
              "%typescript.preferences.organizeImports.caseFirst.lower%"
            ],
            default: "default"
          }
        }
      },
      "javascript.preferences.organizeImports": {
        type: "object",
        markdownDescription: "%typescript.preferences.organizeImports%",
        properties: {
          caseSensitivity: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.caseSensitivity%",
            enum: [
              "auto",
              "caseInsensitive",
              "caseSensitive"
            ],
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.caseSensitivity.auto%",
              "%typescript.preferences.organizeImports.caseSensitivity.insensitive",
              "%typescript.preferences.organizeImports.caseSensitivity.sensitive%"
            ],
            default: "auto"
          },
          typeOrder: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.typeOrder%",
            enum: [
              "auto",
              "last",
              "inline",
              "first"
            ],
            default: "auto",
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.typeOrder.auto%",
              "%typescript.preferences.organizeImports.typeOrder.last%",
              "%typescript.preferences.organizeImports.typeOrder.inline%",
              "%typescript.preferences.organizeImports.typeOrder.first%"
            ]
          },
          unicodeCollation: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.unicodeCollation%",
            enum: [
              "ordinal",
              "unicode"
            ],
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.unicodeCollation.ordinal%",
              "%typescript.preferences.organizeImports.unicodeCollation.unicode%"
            ],
            default: "ordinal"
          },
          locale: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.locale%"
          },
          numericCollation: {
            type: "boolean",
            markdownDescription: "%typescript.preferences.organizeImports.numericCollation%"
          },
          accentCollation: {
            type: "boolean",
            markdownDescription: "%typescript.preferences.organizeImports.accentCollation%"
          },
          caseFirst: {
            type: "string",
            markdownDescription: "%typescript.preferences.organizeImports.caseFirst%",
            enum: [
              "default",
              "upper",
              "lower"
            ],
            markdownEnumDescriptions: [
              "%typescript.preferences.organizeImports.caseFirst.default%",
              "%typescript.preferences.organizeImports.caseFirst.upper%",
              "%typescript.preferences.organizeImports.caseFirst.lower%"
            ],
            default: "default"
          }
        }
      },
      "typescript.updateImportsOnFileMove.enabled": {
        type: "string",
        enum: [
          "prompt",
          "always",
          "never"
        ],
        markdownEnumDescriptions: [
          "%typescript.updateImportsOnFileMove.enabled.prompt%",
          "%typescript.updateImportsOnFileMove.enabled.always%",
          "%typescript.updateImportsOnFileMove.enabled.never%"
        ],
        default: "prompt",
        description: "%typescript.updateImportsOnFileMove.enabled%",
        scope: "resource"
      },
      "javascript.updateImportsOnFileMove.enabled": {
        type: "string",
        enum: [
          "prompt",
          "always",
          "never"
        ],
        markdownEnumDescriptions: [
          "%typescript.updateImportsOnFileMove.enabled.prompt%",
          "%typescript.updateImportsOnFileMove.enabled.always%",
          "%typescript.updateImportsOnFileMove.enabled.never%"
        ],
        default: "prompt",
        description: "%typescript.updateImportsOnFileMove.enabled%",
        scope: "resource"
      },
      "typescript.autoClosingTags": {
        type: "boolean",
        default: true,
        description: "%typescript.autoClosingTags%",
        scope: "language-overridable"
      },
      "javascript.autoClosingTags": {
        type: "boolean",
        default: true,
        description: "%typescript.autoClosingTags%",
        scope: "language-overridable"
      },
      "javascript.suggest.enabled": {
        type: "boolean",
        default: true,
        description: "%typescript.suggest.enabled%",
        scope: "language-overridable"
      },
      "typescript.suggest.enabled": {
        type: "boolean",
        default: true,
        description: "%typescript.suggest.enabled%",
        scope: "language-overridable"
      },
      "typescript.surveys.enabled": {
        type: "boolean",
        default: true,
        description: "%configuration.surveys.enabled%",
        scope: "window"
      },
      "typescript.tsserver.useSeparateSyntaxServer": {
        type: "boolean",
        default: true,
        description: "%configuration.tsserver.useSeparateSyntaxServer%",
        markdownDeprecationMessage: "%configuration.tsserver.useSeparateSyntaxServer.deprecation%",
        scope: "window"
      },
      "typescript.tsserver.useSyntaxServer": {
        type: "string",
        scope: "window",
        description: "%configuration.tsserver.useSyntaxServer%",
        default: "auto",
        enum: [
          "always",
          "never",
          "auto"
        ],
        enumDescriptions: [
          "%configuration.tsserver.useSyntaxServer.always%",
          "%configuration.tsserver.useSyntaxServer.never%",
          "%configuration.tsserver.useSyntaxServer.auto%"
        ]
      },
      "typescript.tsserver.maxTsServerMemory": {
        type: "number",
        default: 3072,
        markdownDescription: "%configuration.tsserver.maxTsServerMemory%",
        scope: "window"
      },
      "typescript.tsserver.experimental.enableProjectDiagnostics": {
        type: "boolean",
        default: false,
        description: "%configuration.tsserver.experimental.enableProjectDiagnostics%",
        scope: "window",
        tags: [
          "experimental"
        ]
      },
      "typescript.tsserver.experimental.useVsCodeWatcher": {
        type: "boolean",
        description: "%configuration.tsserver.useVsCodeWatcher%",
        deprecationMessage: "%configuration.tsserver.useVsCodeWatcher.deprecation%",
        default: true
      },
      "typescript.tsserver.watchOptions": {
        description: "%configuration.tsserver.watchOptions%",
        scope: "window",
        default: "vscode",
        oneOf: [
          {
            type: "string",
            const: "vscode",
            description: "%configuration.tsserver.watchOptions.vscode%"
          },
          {
            type: "object",
            properties: {
              watchFile: {
                type: "string",
                description: "%configuration.tsserver.watchOptions.watchFile%",
                enum: [
                  "fixedChunkSizePolling",
                  "fixedPollingInterval",
                  "priorityPollingInterval",
                  "dynamicPriorityPolling",
                  "useFsEvents",
                  "useFsEventsOnParentDirectory"
                ],
                enumDescriptions: [
                  "%configuration.tsserver.watchOptions.watchFile.fixedChunkSizePolling%",
                  "%configuration.tsserver.watchOptions.watchFile.fixedPollingInterval%",
                  "%configuration.tsserver.watchOptions.watchFile.priorityPollingInterval%",
                  "%configuration.tsserver.watchOptions.watchFile.dynamicPriorityPolling%",
                  "%configuration.tsserver.watchOptions.watchFile.useFsEvents%",
                  "%configuration.tsserver.watchOptions.watchFile.useFsEventsOnParentDirectory%"
                ],
                default: "useFsEvents"
              },
              watchDirectory: {
                type: "string",
                description: "%configuration.tsserver.watchOptions.watchDirectory%",
                enum: [
                  "fixedChunkSizePolling",
                  "fixedPollingInterval",
                  "dynamicPriorityPolling",
                  "useFsEvents"
                ],
                enumDescriptions: [
                  "%configuration.tsserver.watchOptions.watchDirectory.fixedChunkSizePolling%",
                  "%configuration.tsserver.watchOptions.watchDirectory.fixedPollingInterval%",
                  "%configuration.tsserver.watchOptions.watchDirectory.dynamicPriorityPolling%",
                  "%configuration.tsserver.watchOptions.watchDirectory.useFsEvents%"
                ],
                default: "useFsEvents"
              },
              fallbackPolling: {
                type: "string",
                description: "%configuration.tsserver.watchOptions.fallbackPolling%",
                enum: [
                  "fixedPollingInterval",
                  "priorityPollingInterval",
                  "dynamicPriorityPolling"
                ],
                enumDescriptions: [
                  "configuration.tsserver.watchOptions.fallbackPolling.fixedPollingInterval",
                  "configuration.tsserver.watchOptions.fallbackPolling.priorityPollingInterval",
                  "configuration.tsserver.watchOptions.fallbackPolling.dynamicPriorityPolling"
                ]
              },
              synchronousWatchDirectory: {
                type: "boolean",
                description: "%configuration.tsserver.watchOptions.synchronousWatchDirectory%"
              }
            }
          }
        ]
      },
      "typescript.workspaceSymbols.scope": {
        type: "string",
        enum: [
          "allOpenProjects",
          "currentProject"
        ],
        enumDescriptions: [
          "%typescript.workspaceSymbols.scope.allOpenProjects%",
          "%typescript.workspaceSymbols.scope.currentProject%"
        ],
        default: "allOpenProjects",
        markdownDescription: "%typescript.workspaceSymbols.scope%",
        scope: "window"
      },
      "javascript.suggest.classMemberSnippets.enabled": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.classMemberSnippets.enabled%",
        scope: "resource"
      },
      "typescript.suggest.classMemberSnippets.enabled": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.classMemberSnippets.enabled%",
        scope: "resource"
      },
      "typescript.suggest.objectLiteralMethodSnippets.enabled": {
        type: "boolean",
        default: true,
        description: "%configuration.suggest.objectLiteralMethodSnippets.enabled%",
        scope: "resource"
      },
      "typescript.tsserver.web.projectWideIntellisense.enabled": {
        type: "boolean",
        default: true,
        description: "%configuration.tsserver.web.projectWideIntellisense.enabled%",
        scope: "window"
      },
      "typescript.tsserver.web.projectWideIntellisense.suppressSemanticErrors": {
        type: "boolean",
        default: false,
        description: "%configuration.tsserver.web.projectWideIntellisense.suppressSemanticErrors%",
        scope: "window"
      },
      "typescript.tsserver.web.typeAcquisition.enabled": {
        type: "boolean",
        default: true,
        description: "%configuration.tsserver.web.typeAcquisition.enabled%",
        scope: "window"
      },
      "typescript.tsserver.nodePath": {
        type: "string",
        description: "%configuration.tsserver.nodePath%",
        scope: "window"
      },
      "typescript.preferGoToSourceDefinition": {
        type: "boolean",
        default: false,
        description: "%configuration.preferGoToSourceDefinition%",
        scope: "window"
      },
      "javascript.preferGoToSourceDefinition": {
        type: "boolean",
        default: false,
        description: "%configuration.preferGoToSourceDefinition%",
        scope: "window"
      },
      "typescript.workspaceSymbols.excludeLibrarySymbols": {
        type: "boolean",
        default: true,
        markdownDescription: "%typescript.workspaceSymbols.excludeLibrarySymbols%",
        scope: "window"
      },
      "typescript.tsserver.enableRegionDiagnostics": {
        type: "boolean",
        default: true,
        description: "%typescript.tsserver.enableRegionDiagnostics%",
        scope: "window"
      },
      "javascript.updateImportsOnPaste.enabled": {
        scope: "window",
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.updateImportsOnPaste%"
      },
      "typescript.updateImportsOnPaste.enabled": {
        scope: "window",
        type: "boolean",
        default: true,
        markdownDescription: "%configuration.updateImportsOnPaste%"
      },
      "typescript.experimental.expandableHover": {
        type: "boolean",
        default: false,
        description: "%configuration.expandableHover%",
        scope: "window",
        tags: [
          "experimental"
        ]
      }
    }
  },
  commands: [
    {
      command: "typescript.reloadProjects",
      title: "%reloadProjects.title%",
      category: "TypeScript"
    },
    {
      command: "javascript.reloadProjects",
      title: "%reloadProjects.title%",
      category: "JavaScript"
    },
    {
      command: "typescript.selectTypeScriptVersion",
      title: "%typescript.selectTypeScriptVersion.title%",
      category: "TypeScript"
    },
    {
      command: "typescript.goToProjectConfig",
      title: "%typescript.goToProjectConfig.title%",
      category: "TypeScript"
    },
    {
      command: "javascript.goToProjectConfig",
      title: "%javascript.goToProjectConfig.title%",
      category: "JavaScript"
    },
    {
      command: "typescript.openTsServerLog",
      title: "%typescript.openTsServerLog.title%",
      category: "TypeScript"
    },
    {
      command: "typescript.restartTsServer",
      title: "%typescript.restartTsServer%",
      category: "TypeScript"
    },
    {
      command: "typescript.findAllFileReferences",
      title: "%typescript.findAllFileReferences%",
      category: "TypeScript"
    },
    {
      command: "typescript.goToSourceDefinition",
      title: "%typescript.goToSourceDefinition%",
      category: "TypeScript"
    },
    {
      command: "typescript.sortImports",
      title: "%typescript.sortImports%",
      category: "TypeScript"
    },
    {
      command: "javascript.sortImports",
      title: "%typescript.sortImports%",
      category: "JavaScript"
    },
    {
      command: "typescript.removeUnusedImports",
      title: "%typescript.removeUnusedImports%",
      category: "TypeScript"
    },
    {
      command: "javascript.removeUnusedImports",
      title: "%typescript.removeUnusedImports%",
      category: "JavaScript"
    }
  ],
  menus: {
    commandPalette: [
      {
        command: "typescript.reloadProjects",
        when: "editorLangId == typescript && typescript.isManagedFile"
      },
      {
        command: "typescript.reloadProjects",
        when: "editorLangId == typescriptreact && typescript.isManagedFile"
      },
      {
        command: "javascript.reloadProjects",
        when: "editorLangId == javascript && typescript.isManagedFile"
      },
      {
        command: "javascript.reloadProjects",
        when: "editorLangId == javascriptreact && typescript.isManagedFile"
      },
      {
        command: "typescript.goToProjectConfig",
        when: "editorLangId == typescript && typescript.isManagedFile"
      },
      {
        command: "typescript.goToProjectConfig",
        when: "editorLangId == typescriptreact"
      },
      {
        command: "javascript.goToProjectConfig",
        when: "editorLangId == javascript && typescript.isManagedFile"
      },
      {
        command: "javascript.goToProjectConfig",
        when: "editorLangId == javascriptreact && typescript.isManagedFile"
      },
      {
        command: "typescript.selectTypeScriptVersion",
        when: "typescript.isManagedFile"
      },
      {
        command: "typescript.openTsServerLog",
        when: "typescript.isManagedFile"
      },
      {
        command: "typescript.restartTsServer",
        when: "typescript.isManagedFile"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && typescript.isManagedFile"
      },
      {
        command: "typescript.goToSourceDefinition",
        when: "tsSupportsSourceDefinition && typescript.isManagedFile"
      },
      {
        command: "typescript.sortImports",
        when: "supportedCodeAction =~ /(\\s|^)source\\.sortImports\\b/ && editorLangId =~ /^typescript(react)?$/"
      },
      {
        command: "javascript.sortImports",
        when: "supportedCodeAction =~ /(\\s|^)source\\.sortImports\\b/ && editorLangId =~ /^javascript(react)?$/"
      },
      {
        command: "typescript.removeUnusedImports",
        when: "supportedCodeAction =~ /(\\s|^)source\\.removeUnusedImports\\b/ && editorLangId =~ /^typescript(react)?$/"
      },
      {
        command: "javascript.removeUnusedImports",
        when: "supportedCodeAction =~ /(\\s|^)source\\.removeUnusedImports\\b/ && editorLangId =~ /^javascript(react)?$/"
      }
    ],
    "editor/context": [
      {
        command: "typescript.goToSourceDefinition",
        when: "tsSupportsSourceDefinition && (resourceLangId == typescript || resourceLangId == typescriptreact || resourceLangId == javascript || resourceLangId == javascriptreact)",
        group: "navigation@1.41"
      }
    ],
    "explorer/context": [
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == typescript",
        group: "4_search"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == typescriptreact",
        group: "4_search"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == javascript",
        group: "4_search"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == javascriptreact",
        group: "4_search"
      }
    ],
    "editor/title/context": [
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == javascript"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == javascriptreact"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == typescript"
      },
      {
        command: "typescript.findAllFileReferences",
        when: "tsSupportsFileReferences && resourceLangId == typescriptreact"
      }
    ]
  },
  breakpoints: [
    {
      language: "typescript"
    },
    {
      language: "typescriptreact"
    }
  ],
  taskDefinitions: [
    {
      type: "typescript",
      required: [
        "tsconfig"
      ],
      properties: {
        tsconfig: {
          type: "string",
          description: "%taskDefinition.tsconfig.description%"
        },
        option: {
          type: "string"
        }
      },
      when: "shellExecutionSupported"
    }
  ],
  problemPatterns: [
    {
      name: "tsc",
      regexp: "^([^\\s].*)[\\(:](\\d+)[,:](\\d+)(?:\\):\\s+|\\s+-\\s+)(error|warning|info)\\s+TS(\\d+)\\s*:\\s*(.*)$",
      file: 1,
      line: 2,
      column: 3,
      severity: 4,
      code: 5,
      message: 6
    }
  ],
  problemMatchers: [
    {
      name: "tsc",
      label: "%typescript.problemMatchers.tsc.label%",
      owner: "typescript",
      source: "ts",
      applyTo: "closedDocuments",
      fileLocation: [
        "relative",
        "${cwd}"
      ],
      pattern: "$tsc"
    },
    {
      name: "tsc-watch",
      label: "%typescript.problemMatchers.tscWatch.label%",
      owner: "typescript",
      source: "ts",
      applyTo: "closedDocuments",
      fileLocation: [
        "relative",
        "${cwd}"
      ],
      pattern: "$tsc",
      background: {
        activeOnStart: true,
        beginsPattern: {
          regexp: "^\\s*(?:message TS6032:|\\[?\\D*.{1,2}[:.].{1,2}[:.].{1,2}\\D*(\u251C\\D*\\d{1,2}\\D+\u2524)?(?:\\]| -)) (Starting compilation in watch mode|File change detected\\. Starting incremental compilation)\\.\\.\\."
        },
        endsPattern: {
          regexp: "^\\s*(?:message TS6042:|\\[?\\D*.{1,2}[:.].{1,2}[:.].{1,2}\\D*(\u251C\\D*\\d{1,2}\\D+\u2524)?(?:\\]| -)) (?:Compilation complete\\.|Found \\d+ errors?\\.) Watching for file changes\\."
        }
      }
    }
  ]
};

// src/typescript-language-features/package.nls.json
var package_nls_exports = {};
__export(package_nls_exports, {
  "configuration.expandableHover": () => configuration_expandableHover,
  "configuration.implicitProjectConfig.checkJs": () => configuration_implicitProjectConfig_checkJs,
  "configuration.implicitProjectConfig.experimentalDecorators": () => configuration_implicitProjectConfig_experimentalDecorators,
  "configuration.implicitProjectConfig.module": () => configuration_implicitProjectConfig_module,
  "configuration.implicitProjectConfig.strictFunctionTypes": () => configuration_implicitProjectConfig_strictFunctionTypes,
  "configuration.implicitProjectConfig.strictNullChecks": () => configuration_implicitProjectConfig_strictNullChecks,
  "configuration.implicitProjectConfig.target": () => configuration_implicitProjectConfig_target,
  "configuration.inlayHints.enumMemberValues.enabled": () => configuration_inlayHints_enumMemberValues_enabled,
  "configuration.inlayHints.functionLikeReturnTypes.enabled": () => configuration_inlayHints_functionLikeReturnTypes_enabled,
  "configuration.inlayHints.parameterNames.enabled": () => configuration_inlayHints_parameterNames_enabled,
  "configuration.inlayHints.parameterNames.suppressWhenArgumentMatchesName": () => configuration_inlayHints_parameterNames_suppressWhenArgumentMatchesName,
  "configuration.inlayHints.parameterTypes.enabled": () => configuration_inlayHints_parameterTypes_enabled,
  "configuration.inlayHints.propertyDeclarationTypes.enabled": () => configuration_inlayHints_propertyDeclarationTypes_enabled,
  "configuration.inlayHints.variableTypes.enabled": () => configuration_inlayHints_variableTypes_enabled,
  "configuration.inlayHints.variableTypes.suppressWhenTypeMatchesName": () => configuration_inlayHints_variableTypes_suppressWhenTypeMatchesName,
  "configuration.javascript.checkJs.checkJs.deprecation": () => configuration_javascript_checkJs_checkJs_deprecation,
  "configuration.javascript.checkJs.experimentalDecorators.deprecation": () => configuration_javascript_checkJs_experimentalDecorators_deprecation,
  "configuration.preferGoToSourceDefinition": () => configuration_preferGoToSourceDefinition,
  "configuration.suggest.autoImports": () => configuration_suggest_autoImports,
  "configuration.suggest.classMemberSnippets.enabled": () => configuration_suggest_classMemberSnippets_enabled,
  "configuration.suggest.completeFunctionCalls": () => configuration_suggest_completeFunctionCalls,
  "configuration.suggest.completeJSDocs": () => configuration_suggest_completeJSDocs,
  "configuration.suggest.includeAutomaticOptionalChainCompletions": () => configuration_suggest_includeAutomaticOptionalChainCompletions,
  "configuration.suggest.includeCompletionsForImportStatements": () => configuration_suggest_includeCompletionsForImportStatements,
  "configuration.suggest.jsdoc.generateReturns": () => configuration_suggest_jsdoc_generateReturns,
  "configuration.suggest.names": () => configuration_suggest_names,
  "configuration.suggest.objectLiteralMethodSnippets.enabled": () => configuration_suggest_objectLiteralMethodSnippets_enabled,
  "configuration.suggest.paths": () => configuration_suggest_paths,
  "configuration.surveys.enabled": () => configuration_surveys_enabled,
  "configuration.tsserver.experimental.enableProjectDiagnostics": () => configuration_tsserver_experimental_enableProjectDiagnostics,
  "configuration.tsserver.maxTsServerMemory": () => configuration_tsserver_maxTsServerMemory,
  "configuration.tsserver.nodePath": () => configuration_tsserver_nodePath,
  "configuration.tsserver.useSeparateSyntaxServer": () => configuration_tsserver_useSeparateSyntaxServer,
  "configuration.tsserver.useSeparateSyntaxServer.deprecation": () => configuration_tsserver_useSeparateSyntaxServer_deprecation,
  "configuration.tsserver.useSyntaxServer": () => configuration_tsserver_useSyntaxServer,
  "configuration.tsserver.useSyntaxServer.always": () => configuration_tsserver_useSyntaxServer_always,
  "configuration.tsserver.useSyntaxServer.auto": () => configuration_tsserver_useSyntaxServer_auto,
  "configuration.tsserver.useSyntaxServer.never": () => configuration_tsserver_useSyntaxServer_never,
  "configuration.tsserver.useVsCodeWatcher": () => configuration_tsserver_useVsCodeWatcher,
  "configuration.tsserver.useVsCodeWatcher.deprecation": () => configuration_tsserver_useVsCodeWatcher_deprecation,
  "configuration.tsserver.watchOptions": () => configuration_tsserver_watchOptions,
  "configuration.tsserver.watchOptions.fallbackPolling": () => configuration_tsserver_watchOptions_fallbackPolling,
  "configuration.tsserver.watchOptions.fallbackPolling.dynamicPriorityPolling ": () => configuration_tsserver_watchOptions_fallbackPolling_dynamicPriorityPolling_,
  "configuration.tsserver.watchOptions.fallbackPolling.fixedPollingInterval": () => configuration_tsserver_watchOptions_fallbackPolling_fixedPollingInterval,
  "configuration.tsserver.watchOptions.fallbackPolling.priorityPollingInterval": () => configuration_tsserver_watchOptions_fallbackPolling_priorityPollingInterval,
  "configuration.tsserver.watchOptions.synchronousWatchDirectory": () => configuration_tsserver_watchOptions_synchronousWatchDirectory,
  "configuration.tsserver.watchOptions.vscode": () => configuration_tsserver_watchOptions_vscode,
  "configuration.tsserver.watchOptions.watchDirectory": () => configuration_tsserver_watchOptions_watchDirectory,
  "configuration.tsserver.watchOptions.watchDirectory.dynamicPriorityPolling": () => configuration_tsserver_watchOptions_watchDirectory_dynamicPriorityPolling,
  "configuration.tsserver.watchOptions.watchDirectory.fixedChunkSizePolling": () => configuration_tsserver_watchOptions_watchDirectory_fixedChunkSizePolling,
  "configuration.tsserver.watchOptions.watchDirectory.fixedPollingInterval": () => configuration_tsserver_watchOptions_watchDirectory_fixedPollingInterval,
  "configuration.tsserver.watchOptions.watchDirectory.useFsEvents": () => configuration_tsserver_watchOptions_watchDirectory_useFsEvents,
  "configuration.tsserver.watchOptions.watchFile": () => configuration_tsserver_watchOptions_watchFile,
  "configuration.tsserver.watchOptions.watchFile.dynamicPriorityPolling": () => configuration_tsserver_watchOptions_watchFile_dynamicPriorityPolling,
  "configuration.tsserver.watchOptions.watchFile.fixedChunkSizePolling": () => configuration_tsserver_watchOptions_watchFile_fixedChunkSizePolling,
  "configuration.tsserver.watchOptions.watchFile.fixedPollingInterval": () => configuration_tsserver_watchOptions_watchFile_fixedPollingInterval,
  "configuration.tsserver.watchOptions.watchFile.priorityPollingInterval": () => configuration_tsserver_watchOptions_watchFile_priorityPollingInterval,
  "configuration.tsserver.watchOptions.watchFile.useFsEvents": () => configuration_tsserver_watchOptions_watchFile_useFsEvents,
  "configuration.tsserver.watchOptions.watchFile.useFsEventsOnParentDirectory": () => configuration_tsserver_watchOptions_watchFile_useFsEventsOnParentDirectory,
  "configuration.tsserver.web.projectWideIntellisense.enabled": () => configuration_tsserver_web_projectWideIntellisense_enabled,
  "configuration.tsserver.web.projectWideIntellisense.suppressSemanticErrors": () => configuration_tsserver_web_projectWideIntellisense_suppressSemanticErrors,
  "configuration.tsserver.web.typeAcquisition.enabled": () => configuration_tsserver_web_typeAcquisition_enabled,
  "configuration.typescript": () => configuration_typescript,
  "configuration.updateImportsOnPaste": () => configuration_updateImportsOnPaste,
  default: () => package_nls_default,
  description: () => description,
  displayName: () => displayName,
  "format.indentSwitchCase": () => format_indentSwitchCase,
  "format.insertSpaceAfterCommaDelimiter": () => format_insertSpaceAfterCommaDelimiter,
  "format.insertSpaceAfterConstructor": () => format_insertSpaceAfterConstructor,
  "format.insertSpaceAfterFunctionKeywordForAnonymousFunctions": () => format_insertSpaceAfterFunctionKeywordForAnonymousFunctions,
  "format.insertSpaceAfterKeywordsInControlFlowStatements": () => format_insertSpaceAfterKeywordsInControlFlowStatements,
  "format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": () => format_insertSpaceAfterOpeningAndBeforeClosingEmptyBraces,
  "format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces": () => format_insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces,
  "format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces": () => format_insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces,
  "format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets": () => format_insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets,
  "format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis": () => format_insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis,
  "format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": () => format_insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces,
  "format.insertSpaceAfterSemicolonInForStatements": () => format_insertSpaceAfterSemicolonInForStatements,
  "format.insertSpaceAfterTypeAssertion": () => format_insertSpaceAfterTypeAssertion,
  "format.insertSpaceBeforeAndAfterBinaryOperators": () => format_insertSpaceBeforeAndAfterBinaryOperators,
  "format.insertSpaceBeforeFunctionParenthesis": () => format_insertSpaceBeforeFunctionParenthesis,
  "format.placeOpenBraceOnNewLineForControlBlocks": () => format_placeOpenBraceOnNewLineForControlBlocks,
  "format.placeOpenBraceOnNewLineForFunctions": () => format_placeOpenBraceOnNewLineForFunctions,
  "format.semicolons": () => format_semicolons,
  "format.semicolons.ignore": () => format_semicolons_ignore,
  "format.semicolons.insert": () => format_semicolons_insert,
  "format.semicolons.remove": () => format_semicolons_remove,
  "inlayHints.parameterNames.all": () => inlayHints_parameterNames_all,
  "inlayHints.parameterNames.literals": () => inlayHints_parameterNames_literals,
  "inlayHints.parameterNames.none": () => inlayHints_parameterNames_none,
  "javascript.format.enable": () => javascript_format_enable,
  "javascript.goToProjectConfig.title": () => javascript_goToProjectConfig_title,
  "javascript.preferences.jsxAttributeCompletionStyle.auto": () => javascript_preferences_jsxAttributeCompletionStyle_auto,
  "javascript.preferences.organizeImports": () => javascript_preferences_organizeImports,
  "javascript.referencesCodeLens.enabled": () => javascript_referencesCodeLens_enabled,
  "javascript.referencesCodeLens.showOnAllFunctions": () => javascript_referencesCodeLens_showOnAllFunctions,
  "javascript.suggestionActions.enabled": () => javascript_suggestionActions_enabled,
  "javascript.validate.enable": () => javascript_validate_enable,
  "reloadProjects.title": () => reloadProjects_title,
  "taskDefinition.tsconfig.description": () => taskDefinition_tsconfig_description,
  "typescript.autoClosingTags": () => typescript_autoClosingTags,
  "typescript.check.npmIsInstalled": () => typescript_check_npmIsInstalled,
  "typescript.disableAutomaticTypeAcquisition": () => typescript_disableAutomaticTypeAcquisition,
  "typescript.enablePromptUseWorkspaceTsdk": () => typescript_enablePromptUseWorkspaceTsdk,
  "typescript.findAllFileReferences": () => typescript_findAllFileReferences,
  "typescript.format.enable": () => typescript_format_enable,
  "typescript.goToProjectConfig.title": () => typescript_goToProjectConfig_title,
  "typescript.goToSourceDefinition": () => typescript_goToSourceDefinition,
  "typescript.implementationsCodeLens.enabled": () => typescript_implementationsCodeLens_enabled,
  "typescript.implementationsCodeLens.showOnInterfaceMethods": () => typescript_implementationsCodeLens_showOnInterfaceMethods,
  "typescript.locale": () => typescript_locale,
  "typescript.locale.auto": () => typescript_locale_auto,
  "typescript.npm": () => typescript_npm,
  "typescript.openTsServerLog.title": () => typescript_openTsServerLog_title,
  "typescript.preferences.autoImportFileExcludePatterns": () => typescript_preferences_autoImportFileExcludePatterns,
  "typescript.preferences.autoImportSpecifierExcludeRegexes": () => typescript_preferences_autoImportSpecifierExcludeRegexes,
  "typescript.preferences.importModuleSpecifier": () => typescript_preferences_importModuleSpecifier,
  "typescript.preferences.importModuleSpecifier.nonRelative": () => typescript_preferences_importModuleSpecifier_nonRelative,
  "typescript.preferences.importModuleSpecifier.projectRelative": () => typescript_preferences_importModuleSpecifier_projectRelative,
  "typescript.preferences.importModuleSpecifier.relative": () => typescript_preferences_importModuleSpecifier_relative,
  "typescript.preferences.importModuleSpecifier.shortest": () => typescript_preferences_importModuleSpecifier_shortest,
  "typescript.preferences.importModuleSpecifierEnding": () => typescript_preferences_importModuleSpecifierEnding,
  "typescript.preferences.importModuleSpecifierEnding.auto": () => typescript_preferences_importModuleSpecifierEnding_auto,
  "typescript.preferences.importModuleSpecifierEnding.index": () => typescript_preferences_importModuleSpecifierEnding_index,
  "typescript.preferences.importModuleSpecifierEnding.js": () => typescript_preferences_importModuleSpecifierEnding_js,
  "typescript.preferences.importModuleSpecifierEnding.label.js": () => typescript_preferences_importModuleSpecifierEnding_label_js,
  "typescript.preferences.importModuleSpecifierEnding.minimal": () => typescript_preferences_importModuleSpecifierEnding_minimal,
  "typescript.preferences.includePackageJsonAutoImports": () => typescript_preferences_includePackageJsonAutoImports,
  "typescript.preferences.includePackageJsonAutoImports.auto": () => typescript_preferences_includePackageJsonAutoImports_auto,
  "typescript.preferences.includePackageJsonAutoImports.off": () => typescript_preferences_includePackageJsonAutoImports_off,
  "typescript.preferences.includePackageJsonAutoImports.on": () => typescript_preferences_includePackageJsonAutoImports_on,
  "typescript.preferences.jsxAttributeCompletionStyle": () => typescript_preferences_jsxAttributeCompletionStyle,
  "typescript.preferences.jsxAttributeCompletionStyle.auto": () => typescript_preferences_jsxAttributeCompletionStyle_auto,
  "typescript.preferences.jsxAttributeCompletionStyle.braces": () => typescript_preferences_jsxAttributeCompletionStyle_braces,
  "typescript.preferences.jsxAttributeCompletionStyle.none": () => typescript_preferences_jsxAttributeCompletionStyle_none,
  "typescript.preferences.organizeImports": () => typescript_preferences_organizeImports,
  "typescript.preferences.organizeImports.accentCollation": () => typescript_preferences_organizeImports_accentCollation,
  "typescript.preferences.organizeImports.caseFirst": () => typescript_preferences_organizeImports_caseFirst,
  "typescript.preferences.organizeImports.caseFirst.default": () => typescript_preferences_organizeImports_caseFirst_default,
  "typescript.preferences.organizeImports.caseFirst.lower": () => typescript_preferences_organizeImports_caseFirst_lower,
  "typescript.preferences.organizeImports.caseFirst.upper": () => typescript_preferences_organizeImports_caseFirst_upper,
  "typescript.preferences.organizeImports.caseSensitivity": () => typescript_preferences_organizeImports_caseSensitivity,
  "typescript.preferences.organizeImports.caseSensitivity.auto": () => typescript_preferences_organizeImports_caseSensitivity_auto,
  "typescript.preferences.organizeImports.caseSensitivity.insensitive": () => typescript_preferences_organizeImports_caseSensitivity_insensitive,
  "typescript.preferences.organizeImports.caseSensitivity.sensitive": () => typescript_preferences_organizeImports_caseSensitivity_sensitive,
  "typescript.preferences.organizeImports.locale": () => typescript_preferences_organizeImports_locale,
  "typescript.preferences.organizeImports.numericCollation": () => typescript_preferences_organizeImports_numericCollation,
  "typescript.preferences.organizeImports.typeOrder": () => typescript_preferences_organizeImports_typeOrder,
  "typescript.preferences.organizeImports.typeOrder.auto": () => typescript_preferences_organizeImports_typeOrder_auto,
  "typescript.preferences.organizeImports.typeOrder.first": () => typescript_preferences_organizeImports_typeOrder_first,
  "typescript.preferences.organizeImports.typeOrder.inline": () => typescript_preferences_organizeImports_typeOrder_inline,
  "typescript.preferences.organizeImports.typeOrder.last": () => typescript_preferences_organizeImports_typeOrder_last,
  "typescript.preferences.organizeImports.unicodeCollation": () => typescript_preferences_organizeImports_unicodeCollation,
  "typescript.preferences.organizeImports.unicodeCollation.ordinal": () => typescript_preferences_organizeImports_unicodeCollation_ordinal,
  "typescript.preferences.organizeImports.unicodeCollation.unicode": () => typescript_preferences_organizeImports_unicodeCollation_unicode,
  "typescript.preferences.preferTypeOnlyAutoImports": () => typescript_preferences_preferTypeOnlyAutoImports,
  "typescript.preferences.quoteStyle": () => typescript_preferences_quoteStyle,
  "typescript.preferences.quoteStyle.auto": () => typescript_preferences_quoteStyle_auto,
  "typescript.preferences.quoteStyle.double": () => typescript_preferences_quoteStyle_double,
  "typescript.preferences.quoteStyle.single": () => typescript_preferences_quoteStyle_single,
  "typescript.preferences.renameMatchingJsxTags": () => typescript_preferences_renameMatchingJsxTags,
  "typescript.preferences.renameShorthandProperties.deprecationMessage": () => typescript_preferences_renameShorthandProperties_deprecationMessage,
  "typescript.preferences.useAliasesForRenames": () => typescript_preferences_useAliasesForRenames,
  "typescript.problemMatchers.tsc.label": () => typescript_problemMatchers_tsc_label,
  "typescript.problemMatchers.tscWatch.label": () => typescript_problemMatchers_tscWatch_label,
  "typescript.referencesCodeLens.enabled": () => typescript_referencesCodeLens_enabled,
  "typescript.referencesCodeLens.showOnAllFunctions": () => typescript_referencesCodeLens_showOnAllFunctions,
  "typescript.removeUnusedImports": () => typescript_removeUnusedImports,
  "typescript.reportStyleChecksAsWarnings": () => typescript_reportStyleChecksAsWarnings,
  "typescript.restartTsServer": () => typescript_restartTsServer,
  "typescript.selectTypeScriptVersion.title": () => typescript_selectTypeScriptVersion_title,
  "typescript.sortImports": () => typescript_sortImports,
  "typescript.suggest.enabled": () => typescript_suggest_enabled,
  "typescript.suggestionActions.enabled": () => typescript_suggestionActions_enabled,
  "typescript.tsc.autoDetect": () => typescript_tsc_autoDetect,
  "typescript.tsc.autoDetect.build": () => typescript_tsc_autoDetect_build,
  "typescript.tsc.autoDetect.off": () => typescript_tsc_autoDetect_off,
  "typescript.tsc.autoDetect.on": () => typescript_tsc_autoDetect_on,
  "typescript.tsc.autoDetect.watch": () => typescript_tsc_autoDetect_watch,
  "typescript.tsdk.desc": () => typescript_tsdk_desc,
  "typescript.tsserver.enableRegionDiagnostics": () => typescript_tsserver_enableRegionDiagnostics,
  "typescript.tsserver.enableTracing": () => typescript_tsserver_enableTracing,
  "typescript.tsserver.log": () => typescript_tsserver_log,
  "typescript.tsserver.pluginPaths": () => typescript_tsserver_pluginPaths,
  "typescript.tsserver.pluginPaths.item": () => typescript_tsserver_pluginPaths_item,
  "typescript.tsserver.trace": () => typescript_tsserver_trace,
  "typescript.updateImportsOnFileMove.enabled": () => typescript_updateImportsOnFileMove_enabled,
  "typescript.updateImportsOnFileMove.enabled.always": () => typescript_updateImportsOnFileMove_enabled_always,
  "typescript.updateImportsOnFileMove.enabled.never": () => typescript_updateImportsOnFileMove_enabled_never,
  "typescript.updateImportsOnFileMove.enabled.prompt": () => typescript_updateImportsOnFileMove_enabled_prompt,
  "typescript.validate.enable": () => typescript_validate_enable,
  "typescript.workspaceSymbols.excludeLibrarySymbols": () => typescript_workspaceSymbols_excludeLibrarySymbols,
  "typescript.workspaceSymbols.scope": () => typescript_workspaceSymbols_scope,
  "typescript.workspaceSymbols.scope.allOpenProjects": () => typescript_workspaceSymbols_scope_allOpenProjects,
  "typescript.workspaceSymbols.scope.currentProject": () => typescript_workspaceSymbols_scope_currentProject,
  virtualWorkspaces: () => virtualWorkspaces,
  "walkthroughs.nodejsWelcome.debugJsFile.altText": () => walkthroughs_nodejsWelcome_debugJsFile_altText,
  "walkthroughs.nodejsWelcome.debugJsFile.description": () => walkthroughs_nodejsWelcome_debugJsFile_description,
  "walkthroughs.nodejsWelcome.debugJsFile.title": () => walkthroughs_nodejsWelcome_debugJsFile_title,
  "walkthroughs.nodejsWelcome.description": () => walkthroughs_nodejsWelcome_description,
  "walkthroughs.nodejsWelcome.downloadNode.forLinux.description": () => walkthroughs_nodejsWelcome_downloadNode_forLinux_description,
  "walkthroughs.nodejsWelcome.downloadNode.forLinux.title": () => walkthroughs_nodejsWelcome_downloadNode_forLinux_title,
  "walkthroughs.nodejsWelcome.downloadNode.forMacOrWindows.description": () => walkthroughs_nodejsWelcome_downloadNode_forMacOrWindows_description,
  "walkthroughs.nodejsWelcome.downloadNode.forMacOrWindows.title": () => walkthroughs_nodejsWelcome_downloadNode_forMacOrWindows_title,
  "walkthroughs.nodejsWelcome.learnMoreAboutJs.altText": () => walkthroughs_nodejsWelcome_learnMoreAboutJs_altText,
  "walkthroughs.nodejsWelcome.learnMoreAboutJs.description": () => walkthroughs_nodejsWelcome_learnMoreAboutJs_description,
  "walkthroughs.nodejsWelcome.learnMoreAboutJs.title": () => walkthroughs_nodejsWelcome_learnMoreAboutJs_title,
  "walkthroughs.nodejsWelcome.makeJsFile.description": () => walkthroughs_nodejsWelcome_makeJsFile_description,
  "walkthroughs.nodejsWelcome.makeJsFile.title": () => walkthroughs_nodejsWelcome_makeJsFile_title,
  "walkthroughs.nodejsWelcome.title": () => walkthroughs_nodejsWelcome_title,
  workspaceTrust: () => workspaceTrust
});
var displayName = "TypeScript and JavaScript Language Features";
var description = "Provides rich language support for JavaScript and TypeScript.";
var workspaceTrust = "The extension requires workspace trust when the workspace version is used because it executes code specified by the workspace.";
var virtualWorkspaces = "In virtual workspaces, resolving and finding references across files is not supported.";
var reloadProjects_title = "Reload Project";
var configuration_typescript = "TypeScript";
var configuration_suggest_completeFunctionCalls = "Complete functions with their parameter signature.";
var configuration_suggest_includeAutomaticOptionalChainCompletions = "Enable/disable showing completions on potentially undefined values that insert an optional chain call. Requires strict null checks to be enabled.";
var configuration_suggest_includeCompletionsForImportStatements = "Enable/disable auto-import-style completions on partially-typed import statements.";
var typescript_tsdk_desc = "Specifies the folder path to the tsserver and `lib*.d.ts` files under a TypeScript install to use for IntelliSense, for example: `./node_modules/typescript/lib`.\n\n- When specified as a user setting, the TypeScript version from `typescript.tsdk` automatically replaces the built-in TypeScript version.\n- When specified as a workspace setting, `typescript.tsdk` allows you to switch to use that workspace version of TypeScript for IntelliSense with the `TypeScript: Select TypeScript version` command.\n\nSee the [TypeScript documentation](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-newer-typescript-versions) for more detail about managing TypeScript versions.";
var typescript_disableAutomaticTypeAcquisition = "Disables [automatic type acquisition](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition). Automatic type acquisition fetches `@types` packages from npm to improve IntelliSense for external libraries.";
var typescript_enablePromptUseWorkspaceTsdk = "Enables prompting of users to use the TypeScript version configured in the workspace for Intellisense.";
var typescript_tsserver_enableTracing = "Enables tracing TS server performance to a directory. These trace files can be used to diagnose TS Server performance issues. The log may contain file paths, source code, and other potentially sensitive information from your project.";
var typescript_tsserver_log = "Enables logging of the TS server to a file. This log can be used to diagnose TS Server issues. The log may contain file paths, source code, and other potentially sensitive information from your project.";
var typescript_tsserver_pluginPaths = "Additional paths to discover TypeScript Language Service plugins.";
var typescript_tsserver_pluginPaths_item = "Either an absolute or relative path. Relative path will be resolved against workspace folder(s).";
var typescript_tsserver_trace = "Enables tracing of messages sent to the TS server. This trace can be used to diagnose TS Server issues. The trace may contain file paths, source code, and other potentially sensitive information from your project.";
var typescript_tsserver_enableRegionDiagnostics = "Enables region-based diagnostics in TypeScript. Requires using TypeScript 5.6+ in the workspace.";
var typescript_validate_enable = "Enable/disable TypeScript validation.";
var typescript_format_enable = "Enable/disable default TypeScript formatter.";
var javascript_format_enable = "Enable/disable default JavaScript formatter.";
var format_insertSpaceAfterCommaDelimiter = "Defines space handling after a comma delimiter.";
var format_insertSpaceAfterConstructor = "Defines space handling after the constructor keyword.";
var format_insertSpaceAfterSemicolonInForStatements = "Defines space handling after a semicolon in a for statement.";
var format_insertSpaceBeforeAndAfterBinaryOperators = "Defines space handling after a binary operator.";
var format_insertSpaceAfterKeywordsInControlFlowStatements = "Defines space handling after keywords in a control flow statement.";
var format_insertSpaceAfterFunctionKeywordForAnonymousFunctions = "Defines space handling after function keyword for anonymous functions.";
var format_insertSpaceBeforeFunctionParenthesis = "Defines space handling before function argument parentheses.";
var format_insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis = "Defines space handling after opening and before closing non-empty parenthesis.";
var format_insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets = "Defines space handling after opening and before closing non-empty brackets.";
var format_insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces = "Defines space handling after opening and before closing non-empty braces.";
var format_insertSpaceAfterOpeningAndBeforeClosingEmptyBraces = "Defines space handling after opening and before closing empty braces.";
var format_insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces = "Defines space handling after opening and before closing template string braces.";
var format_insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces = "Defines space handling after opening and before closing JSX expression braces.";
var format_insertSpaceAfterTypeAssertion = "Defines space handling after type assertions in TypeScript.";
var format_placeOpenBraceOnNewLineForFunctions = "Defines whether an open brace is put onto a new line for functions or not.";
var format_placeOpenBraceOnNewLineForControlBlocks = "Defines whether an open brace is put onto a new line for control blocks or not.";
var format_semicolons = "Defines handling of optional semicolons.";
var format_semicolons_ignore = "Don't insert or remove any semicolons.";
var format_semicolons_insert = "Insert semicolons at statement ends.";
var format_semicolons_remove = "Remove unnecessary semicolons.";
var format_indentSwitchCase = "Indent case clauses in switch statements. Requires using TypeScript 5.1+ in the workspace.";
var javascript_validate_enable = "Enable/disable JavaScript validation.";
var javascript_goToProjectConfig_title = "Go to Project Configuration (jsconfig / tsconfig)";
var typescript_goToProjectConfig_title = "Go to Project Configuration (tsconfig)";
var javascript_referencesCodeLens_enabled = "Enable/disable references CodeLens in JavaScript files.";
var javascript_referencesCodeLens_showOnAllFunctions = "Enable/disable references CodeLens on all functions in JavaScript files.";
var typescript_referencesCodeLens_enabled = "Enable/disable references CodeLens in TypeScript files.";
var typescript_referencesCodeLens_showOnAllFunctions = "Enable/disable references CodeLens on all functions in TypeScript files.";
var typescript_implementationsCodeLens_enabled = "Enable/disable implementations CodeLens. This CodeLens shows the implementers of an interface.";
var typescript_implementationsCodeLens_showOnInterfaceMethods = "Enable/disable implementations CodeLens on interface methods.";
var typescript_openTsServerLog_title = "Open TS Server log";
var typescript_restartTsServer = "Restart TS Server";
var typescript_selectTypeScriptVersion_title = "Select TypeScript Version...";
var typescript_reportStyleChecksAsWarnings = "Report style checks as warnings.";
var typescript_npm = "Specifies the path to the npm executable used for [Automatic Type Acquisition](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition).";
var typescript_check_npmIsInstalled = "Check if npm is installed for [Automatic Type Acquisition](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition).";
var configuration_suggest_names = "Enable/disable including unique names from the file in JavaScript suggestions. Note that name suggestions are always disabled in JavaScript code that is semantically checked using `@ts-check` or `checkJs`.";
var typescript_tsc_autoDetect = "Controls auto detection of tsc tasks.";
var typescript_tsc_autoDetect_off = "Disable this feature.";
var typescript_tsc_autoDetect_on = "Create both build and watch tasks.";
var typescript_tsc_autoDetect_build = "Only create single run compile tasks.";
var typescript_tsc_autoDetect_watch = "Only create compile and watch tasks.";
var typescript_problemMatchers_tsc_label = "TypeScript problems";
var typescript_problemMatchers_tscWatch_label = "TypeScript problems (watch mode)";
var configuration_suggest_paths = "Enable/disable suggestions for paths in import statements and require calls.";
var configuration_tsserver_useSeparateSyntaxServer = "Enable/disable spawning a separate TypeScript server that can more quickly respond to syntax related operations, such as calculating folding or computing document symbols.";
var configuration_tsserver_useSeparateSyntaxServer_deprecation = "This setting has been deprecated in favor of `typescript.tsserver.useSyntaxServer`.";
var configuration_tsserver_useSyntaxServer = "Controls if TypeScript launches a dedicated server to more quickly handle syntax related operations, such as computing code folding.";
var configuration_tsserver_useSyntaxServer_always = "Use a lighter weight syntax server to handle all IntelliSense operations. This syntax server can only provide IntelliSense for opened files.";
var configuration_tsserver_useSyntaxServer_never = "Don't use a dedicated syntax server. Use a single server to handle all IntelliSense operations.";
var configuration_tsserver_useSyntaxServer_auto = "Spawn both a full server and a lighter weight server dedicated to syntax operations. The syntax server is used to speed up syntax operations and provide IntelliSense while projects are loading.";
var configuration_tsserver_maxTsServerMemory = "The maximum amount of memory (in MB) to allocate to the TypeScript server process. To use a memory limit greater than 4 GB, use `#typescript.tsserver.nodePath#` to run TS Server with a custom Node installation.";
var configuration_tsserver_experimental_enableProjectDiagnostics = "Enables project wide error reporting.";
var typescript_locale = "Sets the locale used to report JavaScript and TypeScript errors. Defaults to use VS Code's locale.";
var typescript_locale_auto = "Use VS Code's configured display language.";
var configuration_implicitProjectConfig_module = "Sets the module system for the program. See more: https://www.typescriptlang.org/tsconfig#module.";
var configuration_implicitProjectConfig_target = "Set target JavaScript language version for emitted JavaScript and include library declarations. See more: https://www.typescriptlang.org/tsconfig#target.";
var configuration_implicitProjectConfig_checkJs = "Enable/disable semantic checking of JavaScript files. Existing `jsconfig.json` or `tsconfig.json` files override this setting.";
var configuration_javascript_checkJs_checkJs_deprecation = "This setting has been deprecated in favor of `js/ts.implicitProjectConfig.checkJs`.";
var configuration_implicitProjectConfig_experimentalDecorators = "Enable/disable `experimentalDecorators` in JavaScript files that are not part of a project. Existing `jsconfig.json` or `tsconfig.json` files override this setting.";
var configuration_javascript_checkJs_experimentalDecorators_deprecation = "This setting has been deprecated in favor of `js/ts.implicitProjectConfig.experimentalDecorators`.";
var configuration_implicitProjectConfig_strictNullChecks = "Enable/disable [strict null checks](https://www.typescriptlang.org/tsconfig#strictNullChecks) in JavaScript and TypeScript files that are not part of a project. Existing `jsconfig.json` or `tsconfig.json` files override this setting.";
var configuration_implicitProjectConfig_strictFunctionTypes = "Enable/disable [strict function types](https://www.typescriptlang.org/tsconfig#strictFunctionTypes) in JavaScript and TypeScript files that are not part of a project. Existing `jsconfig.json` or `tsconfig.json` files override this setting.";
var configuration_suggest_jsdoc_generateReturns = "Enable/disable generating `@returns` annotations for JSDoc templates.";
var configuration_suggest_autoImports = "Enable/disable auto import suggestions.";
var configuration_preferGoToSourceDefinition = "Makes `Go to Definition` avoid type declaration files when possible by triggering `Go to Source Definition` instead. This allows `Go to Source Definition` to be triggered with the mouse gesture.";
var inlayHints_parameterNames_none = "Disable parameter name hints.";
var inlayHints_parameterNames_literals = "Enable parameter name hints only for literal arguments.";
var inlayHints_parameterNames_all = "Enable parameter name hints for literal and non-literal arguments.";
var configuration_inlayHints_parameterNames_enabled = {
  message: "Enable/disable inlay hints for parameter names:\n```typescript\n\nparseInt(/* str: */ '123', /* radix: */ 8)\n \n```",
  comment: [
    "The text inside the ``` block is code and should not be localized."
  ]
};
var configuration_inlayHints_parameterNames_suppressWhenArgumentMatchesName = "Suppress parameter name hints on arguments whose text is identical to the parameter name.";
var configuration_inlayHints_parameterTypes_enabled = {
  message: "Enable/disable inlay hints for implicit parameter types:\n```typescript\n\nel.addEventListener('click', e /* :MouseEvent */ => ...)\n \n```",
  comment: [
    "The text inside the ``` block is code and should not be localized."
  ]
};
var configuration_inlayHints_variableTypes_enabled = {
  message: "Enable/disable inlay hints for implicit variable types:\n```typescript\n\nconst foo /* :number */ = Date.now();\n \n```",
  comment: [
    "The text inside the ``` block is code and should not be localized."
  ]
};
var configuration_inlayHints_variableTypes_suppressWhenTypeMatchesName = "Suppress type hints on variables whose name is identical to the type name.";
var configuration_inlayHints_propertyDeclarationTypes_enabled = {
  message: "Enable/disable inlay hints for implicit types on property declarations:\n```typescript\n\nclass Foo {\n	prop /* :number */ = Date.now();\n}\n \n```",
  comment: [
    "The text inside the ``` block is code and should not be localized."
  ]
};
var configuration_inlayHints_functionLikeReturnTypes_enabled = {
  message: "Enable/disable inlay hints for implicit return types on function signatures:\n```typescript\n\nfunction foo() /* :number */ {\n	return Date.now();\n} \n \n```",
  comment: [
    "The text inside the ``` block is code and should not be localized."
  ]
};
var configuration_inlayHints_enumMemberValues_enabled = {
  message: "Enable/disable inlay hints for member values in enum declarations:\n```typescript\n\nenum MyValue {\n	A /* = 0 */;\n	B /* = 1 */;\n}\n \n```",
  comment: [
    "The text inside the ``` block is code and should not be localized."
  ]
};
var taskDefinition_tsconfig_description = "The tsconfig file that defines the TS build.";
var javascript_suggestionActions_enabled = "Enable/disable suggestion diagnostics for JavaScript files in the editor.";
var typescript_suggestionActions_enabled = "Enable/disable suggestion diagnostics for TypeScript files in the editor.";
var typescript_preferences_quoteStyle = "Preferred quote style to use for Quick Fixes.";
var typescript_preferences_quoteStyle_single = "Always use single quotes: `'`";
var typescript_preferences_quoteStyle_double = 'Always use double quotes: `"`';
var typescript_preferences_quoteStyle_auto = "Infer quote type from existing code";
var typescript_preferences_importModuleSpecifier = "Preferred path style for auto imports.";
var typescript_preferences_importModuleSpecifier_shortest = "Prefers a non-relative import only if one is available that has fewer path segments than a relative import.";
var typescript_preferences_importModuleSpecifier_relative = "Prefers a relative path to the imported file location.";
var typescript_preferences_importModuleSpecifier_nonRelative = "Prefers a non-relative import based on the `baseUrl` or `paths` configured in your `jsconfig.json` / `tsconfig.json`.";
var typescript_preferences_importModuleSpecifier_projectRelative = "Prefers a non-relative import only if the relative import path would leave the package or project directory.";
var typescript_preferences_importModuleSpecifierEnding = "Preferred path ending for auto imports.";
var typescript_preferences_importModuleSpecifierEnding_label_js = ".js / .ts";
var typescript_preferences_importModuleSpecifierEnding_auto = "Use project settings to select a default.";
var typescript_preferences_importModuleSpecifierEnding_minimal = "Shorten `./component/index.js` to `./component`.";
var typescript_preferences_importModuleSpecifierEnding_index = "Shorten `./component/index.js` to `./component/index`.";
var typescript_preferences_importModuleSpecifierEnding_js = "Do not shorten path endings; include the `.js` or `.ts` extension.";
var typescript_preferences_jsxAttributeCompletionStyle = "Preferred style for JSX attribute completions.";
var javascript_preferences_jsxAttributeCompletionStyle_auto = 'Insert `={}` or `=""` after attribute names based on the prop type. See `#javascript.preferences.quoteStyle#` to control the type of quotes used for string attributes.';
var typescript_preferences_jsxAttributeCompletionStyle_auto = 'Insert `={}` or `=""` after attribute names based on the prop type. See `#typescript.preferences.quoteStyle#` to control the type of quotes used for string attributes.';
var typescript_preferences_jsxAttributeCompletionStyle_braces = "Insert `={}` after attribute names.";
var typescript_preferences_jsxAttributeCompletionStyle_none = "Only insert attribute names.";
var typescript_preferences_includePackageJsonAutoImports = "Enable/disable searching `package.json` dependencies for available auto imports.";
var typescript_preferences_includePackageJsonAutoImports_auto = "Search dependencies based on estimated performance impact.";
var typescript_preferences_includePackageJsonAutoImports_on = "Always search dependencies.";
var typescript_preferences_includePackageJsonAutoImports_off = "Never search dependencies.";
var typescript_preferences_autoImportFileExcludePatterns = "Specify glob patterns of files to exclude from auto imports. Relative paths are resolved relative to the workspace root. Patterns are evaluated using tsconfig.json [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) semantics.";
var typescript_preferences_autoImportSpecifierExcludeRegexes = "Specify regular expressions to exclude auto imports with matching import specifiers. Examples:\n\n- `^node:`\n- `lib/internal` (slashes don't need to be escaped...)\n- `/lib\\/internal/i` (...unless including surrounding slashes for `i` or `u` flags)\n- `^lodash$` (only allow subpath imports from lodash)";
var typescript_preferences_preferTypeOnlyAutoImports = "Include the `type` keyword in auto-imports whenever possible. Requires using TypeScript 5.3+ in the workspace.";
var typescript_workspaceSymbols_excludeLibrarySymbols = "Exclude symbols that come from library files in `Go to Symbol in Workspace` results. Requires using TypeScript 5.3+ in the workspace.";
var typescript_updateImportsOnFileMove_enabled = "Enable/disable automatic updating of import paths when you rename or move a file in VS Code.";
var typescript_updateImportsOnFileMove_enabled_prompt = "Prompt on each rename.";
var typescript_updateImportsOnFileMove_enabled_always = "Always update paths automatically.";
var typescript_updateImportsOnFileMove_enabled_never = "Never rename paths and don't prompt.";
var typescript_autoClosingTags = "Enable/disable automatic closing of JSX tags.";
var typescript_suggest_enabled = "Enabled/disable autocomplete suggestions.";
var configuration_surveys_enabled = "Enabled/disable occasional surveys that help us improve VS Code's JavaScript and TypeScript support.";
var configuration_suggest_completeJSDocs = "Enable/disable suggestion to complete JSDoc comments.";
var configuration_tsserver_useVsCodeWatcher = "Use VS Code's file watchers instead of TypeScript's. Requires using TypeScript 5.4+ in the workspace.";
var configuration_tsserver_useVsCodeWatcher_deprecation = "Please use the `#typescript.tsserver.watchOptions#` setting instead.";
var configuration_tsserver_watchOptions = "Configure which watching strategies should be used to keep track of files and directories.";
var configuration_tsserver_watchOptions_vscode = "Use VS Code's file watchers instead of TypeScript's. Requires using TypeScript 5.4+ in the workspace.";
var configuration_tsserver_watchOptions_watchFile = "Strategy for how individual files are watched.";
var configuration_tsserver_watchOptions_watchFile_fixedChunkSizePolling = "Polls files in chunks at regular interval.";
var configuration_tsserver_watchOptions_watchFile_fixedPollingInterval = "Check every file for changes several times a second at a fixed interval.";
var configuration_tsserver_watchOptions_watchFile_priorityPollingInterval = "Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.";
var configuration_tsserver_watchOptions_watchFile_dynamicPriorityPolling = "Use a dynamic queue where less-frequently modified files will be checked less often.";
var configuration_tsserver_watchOptions_watchFile_useFsEvents = "Attempt to use the operating system/file system's native events for file changes.";
var configuration_tsserver_watchOptions_watchFile_useFsEventsOnParentDirectory = "Attempt to use the operating system/file system's native events to listen for changes on a file's containing directories. This can use fewer file watchers, but might be less accurate.";
var configuration_tsserver_watchOptions_watchDirectory = "Strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.";
var configuration_tsserver_watchOptions_watchDirectory_fixedChunkSizePolling = "Polls directories in chunks at regular interval.";
var configuration_tsserver_watchOptions_watchDirectory_fixedPollingInterval = "Check every directory for changes several times a second at a fixed interval.";
var configuration_tsserver_watchOptions_watchDirectory_dynamicPriorityPolling = "Use a dynamic queue where less-frequently modified directories will be checked less often.";
var configuration_tsserver_watchOptions_watchDirectory_useFsEvents = "Attempt to use the operating system/file system's native events for directory changes.";
var configuration_tsserver_watchOptions_fallbackPolling = "When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn't support native file watchers.";
var configuration_tsserver_watchOptions_fallbackPolling_fixedPollingInterval = "Check every file for changes several times a second at a fixed interval.";
var configuration_tsserver_watchOptions_fallbackPolling_priorityPollingInterval = "Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.";
var configuration_tsserver_watchOptions_fallbackPolling_dynamicPriorityPolling_ = "Use a dynamic queue where less-frequently modified files will be checked less often.";
var configuration_tsserver_watchOptions_synchronousWatchDirectory = "Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in node_modules from running npm install), but you might want to disable it with this flag for some less-common setups.";
var typescript_preferences_renameShorthandProperties_deprecationMessage = "The setting 'typescript.preferences.renameShorthandProperties' has been deprecated in favor of 'typescript.preferences.useAliasesForRenames'";
var typescript_preferences_useAliasesForRenames = "Enable/disable introducing aliases for object shorthand properties during renames.";
var typescript_preferences_renameMatchingJsxTags = "When on a JSX tag, try to rename the matching tag instead of renaming the symbol. Requires using TypeScript 5.1+ in the workspace.";
var typescript_preferences_organizeImports = "Advanced preferences that control how imports are ordered.";
var javascript_preferences_organizeImports = "Advanced preferences that control how imports are ordered.";
var typescript_preferences_organizeImports_caseSensitivity = "Specifies how imports should be sorted with regards to case-sensitivity. If `auto` or unspecified, we will detect the case-sensitivity per file";
var typescript_preferences_organizeImports_caseSensitivity_auto = "Detect case-sensitivity for import sorting.";
var typescript_preferences_organizeImports_caseSensitivity_insensitive = "Sort imports case-insensitively.";
var typescript_preferences_organizeImports_caseSensitivity_sensitive = "Sort imports case-sensitively.";
var typescript_preferences_organizeImports_typeOrder = "Specify how type-only named imports should be sorted.";
var typescript_preferences_organizeImports_typeOrder_auto = "Detect where type-only named imports should be sorted.";
var typescript_preferences_organizeImports_typeOrder_last = "Type only named imports are sorted to the end of the import list. E.g. `import { B, Z, type A, type Y } from 'module';`";
var typescript_preferences_organizeImports_typeOrder_inline = "Named imports are sorted by name only. E.g. `import { type A, B, type Y, Z } from 'module';`";
var typescript_preferences_organizeImports_typeOrder_first = "Type only named imports are sorted to the beginning of the import list. E.g. `import { type A, type Y, B, Z } from 'module';`";
var typescript_preferences_organizeImports_unicodeCollation = "Specify whether to sort imports using Unicode or Ordinal collation.";
var typescript_preferences_organizeImports_unicodeCollation_ordinal = "Sort imports using the numeric value of each code point.";
var typescript_preferences_organizeImports_unicodeCollation_unicode = "Sort imports using the Unicode code collation.";
var typescript_preferences_organizeImports_locale = "Requires `organizeImports.unicodeCollation: 'unicode'`. Overrides the locale used for collation. Specify `auto` to use the UI locale.";
var typescript_preferences_organizeImports_caseFirst = "Requires `organizeImports.unicodeCollation: 'unicode'`, and `organizeImports.caseSensitivity` is not `caseInsensitive`. Indicates whether upper-case will sort before lower-case.";
var typescript_preferences_organizeImports_caseFirst_default = "Default order given by `locale`.";
var typescript_preferences_organizeImports_caseFirst_lower = "Lower-case comes before upper-case. E.g.` a, A, z, Z`.";
var typescript_preferences_organizeImports_caseFirst_upper = "Upper-case comes before lower-case. E.g. ` A, a, B, b`.";
var typescript_preferences_organizeImports_numericCollation = "Requires `organizeImports.unicodeCollation: 'unicode'`. Sort numeric strings by integer value.";
var typescript_preferences_organizeImports_accentCollation = "Requires `organizeImports.unicodeCollation: 'unicode'`. Compare characters with diacritical marks as unequal to base character.";
var typescript_workspaceSymbols_scope = "Controls which files are searched by [Go to Symbol in Workspace](https://code.visualstudio.com/docs/editor/editingevolved#_open-symbol-by-name).";
var typescript_workspaceSymbols_scope_allOpenProjects = "Search all open JavaScript or TypeScript projects for symbols.";
var typescript_workspaceSymbols_scope_currentProject = "Only search for symbols in the current JavaScript or TypeScript project.";
var typescript_sortImports = "Sort Imports";
var typescript_removeUnusedImports = "Remove Unused Imports";
var typescript_findAllFileReferences = "Find File References";
var typescript_goToSourceDefinition = "Go to Source Definition";
var configuration_suggest_classMemberSnippets_enabled = "Enable/disable snippet completions for class members.";
var configuration_suggest_objectLiteralMethodSnippets_enabled = "Enable/disable snippet completions for methods in object literals.";
var configuration_tsserver_web_projectWideIntellisense_enabled = "Enable/disable project-wide IntelliSense on web. Requires that VS Code is running in a trusted context.";
var configuration_tsserver_web_projectWideIntellisense_suppressSemanticErrors = "Suppresses semantic errors on web even when project wide IntelliSense is enabled. This is always on when project wide IntelliSense is not enabled or available. See `#typescript.tsserver.web.projectWideIntellisense.enabled#`";
var configuration_tsserver_web_typeAcquisition_enabled = "Enable/disable package acquisition on the web. This enables IntelliSense for imported packages. Requires `#typescript.tsserver.web.projectWideIntellisense.enabled#`. Currently not supported for Safari.";
var configuration_tsserver_nodePath = "Run TS Server on a custom Node installation. This can be a path to a Node executable, or 'node' if you want VS Code to detect a Node installation.";
var configuration_updateImportsOnPaste = 'Enable updating imports when pasting code. Requires TypeScript 5.7+.\n\nBy default this shows a option to update imports after pasting. You can use the `#editor.pasteAs.preferences#` setting to update imports automatically when pasting: `"editor.pasteAs.preferences": [ "text.updateImports.jsts" ]`.';
var configuration_expandableHover = "Enable expanding/contracting the hover to reveal more/less information from the TS server.";
var walkthroughs_nodejsWelcome_title = "Get started with JavaScript and Node.js";
var walkthroughs_nodejsWelcome_description = "Make the most of Visual Studio Code's first-class JavaScript experience.";
var walkthroughs_nodejsWelcome_downloadNode_forMacOrWindows_title = "Install Node.js";
var walkthroughs_nodejsWelcome_downloadNode_forMacOrWindows_description = "Node.js is an easy way to run JavaScript code. You can use it to quickly build command-line apps and servers. It also comes with npm, a package manager which makes reusing and sharing JavaScript code easy.\n[Install Node.js](https://nodejs.org/en/download/)";
var walkthroughs_nodejsWelcome_downloadNode_forLinux_title = "Install Node.js";
var walkthroughs_nodejsWelcome_downloadNode_forLinux_description = "Node.js is an easy way to run JavaScript code. You can use it to quickly build command-line apps and servers. It also comes with npm, a package manager which makes reusing and sharing JavaScript code easy.\n[Install Node.js](https://nodejs.org/en/download/package-manager/)";
var walkthroughs_nodejsWelcome_makeJsFile_title = "Create a JavaScript File";
var walkthroughs_nodejsWelcome_makeJsFile_description = "Let's write our first JavaScript file. We'll have to create a new file and save it with the ``.js`` extension at the end of the file name.\n[Create a JavaScript File](command:javascript-walkthrough.commands.createJsFile)";
var walkthroughs_nodejsWelcome_debugJsFile_title = "Run and Debug your JavaScript";
var walkthroughs_nodejsWelcome_debugJsFile_description = "Once you've installed Node.js, you can run JavaScript programs at a terminal by entering ``node your-file-name.js``\nAnother easy way to run Node.js programs is by using VS Code's debugger which lets you run your code, pause at different points, and help you understand what's going on step-by-step.\n[Start Debugging](command:javascript-walkthrough.commands.debugJsFile)";
var walkthroughs_nodejsWelcome_debugJsFile_altText = "Debug and run your JavaScript code in Node.js with Visual Studio Code.";
var walkthroughs_nodejsWelcome_learnMoreAboutJs_title = "Explore More";
var walkthroughs_nodejsWelcome_learnMoreAboutJs_description = "Want to get more comfortable with JavaScript, Node.js, and VS Code? Be sure to check out our docs!\nWe've got lots of resources for learning [JavaScript](https://code.visualstudio.com/docs/nodejs/working-with-javascript) and [Node.js](https://code.visualstudio.com/docs/nodejs/nodejs-tutorial).\n\n[Learn More](https://code.visualstudio.com/docs/nodejs/nodejs-tutorial)";
var walkthroughs_nodejsWelcome_learnMoreAboutJs_altText = "Learn more about JavaScript and Node.js in Visual Studio Code.";
var package_nls_default = {
  displayName,
  description,
  workspaceTrust,
  virtualWorkspaces,
  "reloadProjects.title": reloadProjects_title,
  "configuration.typescript": configuration_typescript,
  "configuration.suggest.completeFunctionCalls": configuration_suggest_completeFunctionCalls,
  "configuration.suggest.includeAutomaticOptionalChainCompletions": configuration_suggest_includeAutomaticOptionalChainCompletions,
  "configuration.suggest.includeCompletionsForImportStatements": configuration_suggest_includeCompletionsForImportStatements,
  "typescript.tsdk.desc": typescript_tsdk_desc,
  "typescript.disableAutomaticTypeAcquisition": typescript_disableAutomaticTypeAcquisition,
  "typescript.enablePromptUseWorkspaceTsdk": typescript_enablePromptUseWorkspaceTsdk,
  "typescript.tsserver.enableTracing": typescript_tsserver_enableTracing,
  "typescript.tsserver.log": typescript_tsserver_log,
  "typescript.tsserver.pluginPaths": typescript_tsserver_pluginPaths,
  "typescript.tsserver.pluginPaths.item": typescript_tsserver_pluginPaths_item,
  "typescript.tsserver.trace": typescript_tsserver_trace,
  "typescript.tsserver.enableRegionDiagnostics": typescript_tsserver_enableRegionDiagnostics,
  "typescript.validate.enable": typescript_validate_enable,
  "typescript.format.enable": typescript_format_enable,
  "javascript.format.enable": javascript_format_enable,
  "format.insertSpaceAfterCommaDelimiter": format_insertSpaceAfterCommaDelimiter,
  "format.insertSpaceAfterConstructor": format_insertSpaceAfterConstructor,
  "format.insertSpaceAfterSemicolonInForStatements": format_insertSpaceAfterSemicolonInForStatements,
  "format.insertSpaceBeforeAndAfterBinaryOperators": format_insertSpaceBeforeAndAfterBinaryOperators,
  "format.insertSpaceAfterKeywordsInControlFlowStatements": format_insertSpaceAfterKeywordsInControlFlowStatements,
  "format.insertSpaceAfterFunctionKeywordForAnonymousFunctions": format_insertSpaceAfterFunctionKeywordForAnonymousFunctions,
  "format.insertSpaceBeforeFunctionParenthesis": format_insertSpaceBeforeFunctionParenthesis,
  "format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis": format_insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis,
  "format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets": format_insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets,
  "format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces": format_insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces,
  "format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": format_insertSpaceAfterOpeningAndBeforeClosingEmptyBraces,
  "format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": format_insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces,
  "format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces": format_insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces,
  "format.insertSpaceAfterTypeAssertion": format_insertSpaceAfterTypeAssertion,
  "format.placeOpenBraceOnNewLineForFunctions": format_placeOpenBraceOnNewLineForFunctions,
  "format.placeOpenBraceOnNewLineForControlBlocks": format_placeOpenBraceOnNewLineForControlBlocks,
  "format.semicolons": format_semicolons,
  "format.semicolons.ignore": format_semicolons_ignore,
  "format.semicolons.insert": format_semicolons_insert,
  "format.semicolons.remove": format_semicolons_remove,
  "format.indentSwitchCase": format_indentSwitchCase,
  "javascript.validate.enable": javascript_validate_enable,
  "javascript.goToProjectConfig.title": javascript_goToProjectConfig_title,
  "typescript.goToProjectConfig.title": typescript_goToProjectConfig_title,
  "javascript.referencesCodeLens.enabled": javascript_referencesCodeLens_enabled,
  "javascript.referencesCodeLens.showOnAllFunctions": javascript_referencesCodeLens_showOnAllFunctions,
  "typescript.referencesCodeLens.enabled": typescript_referencesCodeLens_enabled,
  "typescript.referencesCodeLens.showOnAllFunctions": typescript_referencesCodeLens_showOnAllFunctions,
  "typescript.implementationsCodeLens.enabled": typescript_implementationsCodeLens_enabled,
  "typescript.implementationsCodeLens.showOnInterfaceMethods": typescript_implementationsCodeLens_showOnInterfaceMethods,
  "typescript.openTsServerLog.title": typescript_openTsServerLog_title,
  "typescript.restartTsServer": typescript_restartTsServer,
  "typescript.selectTypeScriptVersion.title": typescript_selectTypeScriptVersion_title,
  "typescript.reportStyleChecksAsWarnings": typescript_reportStyleChecksAsWarnings,
  "typescript.npm": typescript_npm,
  "typescript.check.npmIsInstalled": typescript_check_npmIsInstalled,
  "configuration.suggest.names": configuration_suggest_names,
  "typescript.tsc.autoDetect": typescript_tsc_autoDetect,
  "typescript.tsc.autoDetect.off": typescript_tsc_autoDetect_off,
  "typescript.tsc.autoDetect.on": typescript_tsc_autoDetect_on,
  "typescript.tsc.autoDetect.build": typescript_tsc_autoDetect_build,
  "typescript.tsc.autoDetect.watch": typescript_tsc_autoDetect_watch,
  "typescript.problemMatchers.tsc.label": typescript_problemMatchers_tsc_label,
  "typescript.problemMatchers.tscWatch.label": typescript_problemMatchers_tscWatch_label,
  "configuration.suggest.paths": configuration_suggest_paths,
  "configuration.tsserver.useSeparateSyntaxServer": configuration_tsserver_useSeparateSyntaxServer,
  "configuration.tsserver.useSeparateSyntaxServer.deprecation": configuration_tsserver_useSeparateSyntaxServer_deprecation,
  "configuration.tsserver.useSyntaxServer": configuration_tsserver_useSyntaxServer,
  "configuration.tsserver.useSyntaxServer.always": configuration_tsserver_useSyntaxServer_always,
  "configuration.tsserver.useSyntaxServer.never": configuration_tsserver_useSyntaxServer_never,
  "configuration.tsserver.useSyntaxServer.auto": configuration_tsserver_useSyntaxServer_auto,
  "configuration.tsserver.maxTsServerMemory": configuration_tsserver_maxTsServerMemory,
  "configuration.tsserver.experimental.enableProjectDiagnostics": configuration_tsserver_experimental_enableProjectDiagnostics,
  "typescript.locale": typescript_locale,
  "typescript.locale.auto": typescript_locale_auto,
  "configuration.implicitProjectConfig.module": configuration_implicitProjectConfig_module,
  "configuration.implicitProjectConfig.target": configuration_implicitProjectConfig_target,
  "configuration.implicitProjectConfig.checkJs": configuration_implicitProjectConfig_checkJs,
  "configuration.javascript.checkJs.checkJs.deprecation": configuration_javascript_checkJs_checkJs_deprecation,
  "configuration.implicitProjectConfig.experimentalDecorators": configuration_implicitProjectConfig_experimentalDecorators,
  "configuration.javascript.checkJs.experimentalDecorators.deprecation": configuration_javascript_checkJs_experimentalDecorators_deprecation,
  "configuration.implicitProjectConfig.strictNullChecks": configuration_implicitProjectConfig_strictNullChecks,
  "configuration.implicitProjectConfig.strictFunctionTypes": configuration_implicitProjectConfig_strictFunctionTypes,
  "configuration.suggest.jsdoc.generateReturns": configuration_suggest_jsdoc_generateReturns,
  "configuration.suggest.autoImports": configuration_suggest_autoImports,
  "configuration.preferGoToSourceDefinition": configuration_preferGoToSourceDefinition,
  "inlayHints.parameterNames.none": inlayHints_parameterNames_none,
  "inlayHints.parameterNames.literals": inlayHints_parameterNames_literals,
  "inlayHints.parameterNames.all": inlayHints_parameterNames_all,
  "configuration.inlayHints.parameterNames.enabled": configuration_inlayHints_parameterNames_enabled,
  "configuration.inlayHints.parameterNames.suppressWhenArgumentMatchesName": configuration_inlayHints_parameterNames_suppressWhenArgumentMatchesName,
  "configuration.inlayHints.parameterTypes.enabled": configuration_inlayHints_parameterTypes_enabled,
  "configuration.inlayHints.variableTypes.enabled": configuration_inlayHints_variableTypes_enabled,
  "configuration.inlayHints.variableTypes.suppressWhenTypeMatchesName": configuration_inlayHints_variableTypes_suppressWhenTypeMatchesName,
  "configuration.inlayHints.propertyDeclarationTypes.enabled": configuration_inlayHints_propertyDeclarationTypes_enabled,
  "configuration.inlayHints.functionLikeReturnTypes.enabled": configuration_inlayHints_functionLikeReturnTypes_enabled,
  "configuration.inlayHints.enumMemberValues.enabled": configuration_inlayHints_enumMemberValues_enabled,
  "taskDefinition.tsconfig.description": taskDefinition_tsconfig_description,
  "javascript.suggestionActions.enabled": javascript_suggestionActions_enabled,
  "typescript.suggestionActions.enabled": typescript_suggestionActions_enabled,
  "typescript.preferences.quoteStyle": typescript_preferences_quoteStyle,
  "typescript.preferences.quoteStyle.single": typescript_preferences_quoteStyle_single,
  "typescript.preferences.quoteStyle.double": typescript_preferences_quoteStyle_double,
  "typescript.preferences.quoteStyle.auto": typescript_preferences_quoteStyle_auto,
  "typescript.preferences.importModuleSpecifier": typescript_preferences_importModuleSpecifier,
  "typescript.preferences.importModuleSpecifier.shortest": typescript_preferences_importModuleSpecifier_shortest,
  "typescript.preferences.importModuleSpecifier.relative": typescript_preferences_importModuleSpecifier_relative,
  "typescript.preferences.importModuleSpecifier.nonRelative": typescript_preferences_importModuleSpecifier_nonRelative,
  "typescript.preferences.importModuleSpecifier.projectRelative": typescript_preferences_importModuleSpecifier_projectRelative,
  "typescript.preferences.importModuleSpecifierEnding": typescript_preferences_importModuleSpecifierEnding,
  "typescript.preferences.importModuleSpecifierEnding.label.js": typescript_preferences_importModuleSpecifierEnding_label_js,
  "typescript.preferences.importModuleSpecifierEnding.auto": typescript_preferences_importModuleSpecifierEnding_auto,
  "typescript.preferences.importModuleSpecifierEnding.minimal": typescript_preferences_importModuleSpecifierEnding_minimal,
  "typescript.preferences.importModuleSpecifierEnding.index": typescript_preferences_importModuleSpecifierEnding_index,
  "typescript.preferences.importModuleSpecifierEnding.js": typescript_preferences_importModuleSpecifierEnding_js,
  "typescript.preferences.jsxAttributeCompletionStyle": typescript_preferences_jsxAttributeCompletionStyle,
  "javascript.preferences.jsxAttributeCompletionStyle.auto": javascript_preferences_jsxAttributeCompletionStyle_auto,
  "typescript.preferences.jsxAttributeCompletionStyle.auto": typescript_preferences_jsxAttributeCompletionStyle_auto,
  "typescript.preferences.jsxAttributeCompletionStyle.braces": typescript_preferences_jsxAttributeCompletionStyle_braces,
  "typescript.preferences.jsxAttributeCompletionStyle.none": typescript_preferences_jsxAttributeCompletionStyle_none,
  "typescript.preferences.includePackageJsonAutoImports": typescript_preferences_includePackageJsonAutoImports,
  "typescript.preferences.includePackageJsonAutoImports.auto": typescript_preferences_includePackageJsonAutoImports_auto,
  "typescript.preferences.includePackageJsonAutoImports.on": typescript_preferences_includePackageJsonAutoImports_on,
  "typescript.preferences.includePackageJsonAutoImports.off": typescript_preferences_includePackageJsonAutoImports_off,
  "typescript.preferences.autoImportFileExcludePatterns": typescript_preferences_autoImportFileExcludePatterns,
  "typescript.preferences.autoImportSpecifierExcludeRegexes": typescript_preferences_autoImportSpecifierExcludeRegexes,
  "typescript.preferences.preferTypeOnlyAutoImports": typescript_preferences_preferTypeOnlyAutoImports,
  "typescript.workspaceSymbols.excludeLibrarySymbols": typescript_workspaceSymbols_excludeLibrarySymbols,
  "typescript.updateImportsOnFileMove.enabled": typescript_updateImportsOnFileMove_enabled,
  "typescript.updateImportsOnFileMove.enabled.prompt": typescript_updateImportsOnFileMove_enabled_prompt,
  "typescript.updateImportsOnFileMove.enabled.always": typescript_updateImportsOnFileMove_enabled_always,
  "typescript.updateImportsOnFileMove.enabled.never": typescript_updateImportsOnFileMove_enabled_never,
  "typescript.autoClosingTags": typescript_autoClosingTags,
  "typescript.suggest.enabled": typescript_suggest_enabled,
  "configuration.surveys.enabled": configuration_surveys_enabled,
  "configuration.suggest.completeJSDocs": configuration_suggest_completeJSDocs,
  "configuration.tsserver.useVsCodeWatcher": configuration_tsserver_useVsCodeWatcher,
  "configuration.tsserver.useVsCodeWatcher.deprecation": configuration_tsserver_useVsCodeWatcher_deprecation,
  "configuration.tsserver.watchOptions": configuration_tsserver_watchOptions,
  "configuration.tsserver.watchOptions.vscode": configuration_tsserver_watchOptions_vscode,
  "configuration.tsserver.watchOptions.watchFile": configuration_tsserver_watchOptions_watchFile,
  "configuration.tsserver.watchOptions.watchFile.fixedChunkSizePolling": configuration_tsserver_watchOptions_watchFile_fixedChunkSizePolling,
  "configuration.tsserver.watchOptions.watchFile.fixedPollingInterval": configuration_tsserver_watchOptions_watchFile_fixedPollingInterval,
  "configuration.tsserver.watchOptions.watchFile.priorityPollingInterval": configuration_tsserver_watchOptions_watchFile_priorityPollingInterval,
  "configuration.tsserver.watchOptions.watchFile.dynamicPriorityPolling": configuration_tsserver_watchOptions_watchFile_dynamicPriorityPolling,
  "configuration.tsserver.watchOptions.watchFile.useFsEvents": configuration_tsserver_watchOptions_watchFile_useFsEvents,
  "configuration.tsserver.watchOptions.watchFile.useFsEventsOnParentDirectory": configuration_tsserver_watchOptions_watchFile_useFsEventsOnParentDirectory,
  "configuration.tsserver.watchOptions.watchDirectory": configuration_tsserver_watchOptions_watchDirectory,
  "configuration.tsserver.watchOptions.watchDirectory.fixedChunkSizePolling": configuration_tsserver_watchOptions_watchDirectory_fixedChunkSizePolling,
  "configuration.tsserver.watchOptions.watchDirectory.fixedPollingInterval": configuration_tsserver_watchOptions_watchDirectory_fixedPollingInterval,
  "configuration.tsserver.watchOptions.watchDirectory.dynamicPriorityPolling": configuration_tsserver_watchOptions_watchDirectory_dynamicPriorityPolling,
  "configuration.tsserver.watchOptions.watchDirectory.useFsEvents": configuration_tsserver_watchOptions_watchDirectory_useFsEvents,
  "configuration.tsserver.watchOptions.fallbackPolling": configuration_tsserver_watchOptions_fallbackPolling,
  "configuration.tsserver.watchOptions.fallbackPolling.fixedPollingInterval": configuration_tsserver_watchOptions_fallbackPolling_fixedPollingInterval,
  "configuration.tsserver.watchOptions.fallbackPolling.priorityPollingInterval": configuration_tsserver_watchOptions_fallbackPolling_priorityPollingInterval,
  "configuration.tsserver.watchOptions.fallbackPolling.dynamicPriorityPolling ": configuration_tsserver_watchOptions_fallbackPolling_dynamicPriorityPolling_,
  "configuration.tsserver.watchOptions.synchronousWatchDirectory": configuration_tsserver_watchOptions_synchronousWatchDirectory,
  "typescript.preferences.renameShorthandProperties.deprecationMessage": typescript_preferences_renameShorthandProperties_deprecationMessage,
  "typescript.preferences.useAliasesForRenames": typescript_preferences_useAliasesForRenames,
  "typescript.preferences.renameMatchingJsxTags": typescript_preferences_renameMatchingJsxTags,
  "typescript.preferences.organizeImports": typescript_preferences_organizeImports,
  "javascript.preferences.organizeImports": javascript_preferences_organizeImports,
  "typescript.preferences.organizeImports.caseSensitivity": typescript_preferences_organizeImports_caseSensitivity,
  "typescript.preferences.organizeImports.caseSensitivity.auto": typescript_preferences_organizeImports_caseSensitivity_auto,
  "typescript.preferences.organizeImports.caseSensitivity.insensitive": typescript_preferences_organizeImports_caseSensitivity_insensitive,
  "typescript.preferences.organizeImports.caseSensitivity.sensitive": typescript_preferences_organizeImports_caseSensitivity_sensitive,
  "typescript.preferences.organizeImports.typeOrder": typescript_preferences_organizeImports_typeOrder,
  "typescript.preferences.organizeImports.typeOrder.auto": typescript_preferences_organizeImports_typeOrder_auto,
  "typescript.preferences.organizeImports.typeOrder.last": typescript_preferences_organizeImports_typeOrder_last,
  "typescript.preferences.organizeImports.typeOrder.inline": typescript_preferences_organizeImports_typeOrder_inline,
  "typescript.preferences.organizeImports.typeOrder.first": typescript_preferences_organizeImports_typeOrder_first,
  "typescript.preferences.organizeImports.unicodeCollation": typescript_preferences_organizeImports_unicodeCollation,
  "typescript.preferences.organizeImports.unicodeCollation.ordinal": typescript_preferences_organizeImports_unicodeCollation_ordinal,
  "typescript.preferences.organizeImports.unicodeCollation.unicode": typescript_preferences_organizeImports_unicodeCollation_unicode,
  "typescript.preferences.organizeImports.locale": typescript_preferences_organizeImports_locale,
  "typescript.preferences.organizeImports.caseFirst": typescript_preferences_organizeImports_caseFirst,
  "typescript.preferences.organizeImports.caseFirst.default": typescript_preferences_organizeImports_caseFirst_default,
  "typescript.preferences.organizeImports.caseFirst.lower": typescript_preferences_organizeImports_caseFirst_lower,
  "typescript.preferences.organizeImports.caseFirst.upper": typescript_preferences_organizeImports_caseFirst_upper,
  "typescript.preferences.organizeImports.numericCollation": typescript_preferences_organizeImports_numericCollation,
  "typescript.preferences.organizeImports.accentCollation": typescript_preferences_organizeImports_accentCollation,
  "typescript.workspaceSymbols.scope": typescript_workspaceSymbols_scope,
  "typescript.workspaceSymbols.scope.allOpenProjects": typescript_workspaceSymbols_scope_allOpenProjects,
  "typescript.workspaceSymbols.scope.currentProject": typescript_workspaceSymbols_scope_currentProject,
  "typescript.sortImports": typescript_sortImports,
  "typescript.removeUnusedImports": typescript_removeUnusedImports,
  "typescript.findAllFileReferences": typescript_findAllFileReferences,
  "typescript.goToSourceDefinition": typescript_goToSourceDefinition,
  "configuration.suggest.classMemberSnippets.enabled": configuration_suggest_classMemberSnippets_enabled,
  "configuration.suggest.objectLiteralMethodSnippets.enabled": configuration_suggest_objectLiteralMethodSnippets_enabled,
  "configuration.tsserver.web.projectWideIntellisense.enabled": configuration_tsserver_web_projectWideIntellisense_enabled,
  "configuration.tsserver.web.projectWideIntellisense.suppressSemanticErrors": configuration_tsserver_web_projectWideIntellisense_suppressSemanticErrors,
  "configuration.tsserver.web.typeAcquisition.enabled": configuration_tsserver_web_typeAcquisition_enabled,
  "configuration.tsserver.nodePath": configuration_tsserver_nodePath,
  "configuration.updateImportsOnPaste": configuration_updateImportsOnPaste,
  "configuration.expandableHover": configuration_expandableHover,
  "walkthroughs.nodejsWelcome.title": walkthroughs_nodejsWelcome_title,
  "walkthroughs.nodejsWelcome.description": walkthroughs_nodejsWelcome_description,
  "walkthroughs.nodejsWelcome.downloadNode.forMacOrWindows.title": walkthroughs_nodejsWelcome_downloadNode_forMacOrWindows_title,
  "walkthroughs.nodejsWelcome.downloadNode.forMacOrWindows.description": walkthroughs_nodejsWelcome_downloadNode_forMacOrWindows_description,
  "walkthroughs.nodejsWelcome.downloadNode.forLinux.title": walkthroughs_nodejsWelcome_downloadNode_forLinux_title,
  "walkthroughs.nodejsWelcome.downloadNode.forLinux.description": walkthroughs_nodejsWelcome_downloadNode_forLinux_description,
  "walkthroughs.nodejsWelcome.makeJsFile.title": walkthroughs_nodejsWelcome_makeJsFile_title,
  "walkthroughs.nodejsWelcome.makeJsFile.description": walkthroughs_nodejsWelcome_makeJsFile_description,
  "walkthroughs.nodejsWelcome.debugJsFile.title": walkthroughs_nodejsWelcome_debugJsFile_title,
  "walkthroughs.nodejsWelcome.debugJsFile.description": walkthroughs_nodejsWelcome_debugJsFile_description,
  "walkthroughs.nodejsWelcome.debugJsFile.altText": walkthroughs_nodejsWelcome_debugJsFile_altText,
  "walkthroughs.nodejsWelcome.learnMoreAboutJs.title": walkthroughs_nodejsWelcome_learnMoreAboutJs_title,
  "walkthroughs.nodejsWelcome.learnMoreAboutJs.description": walkthroughs_nodejsWelcome_learnMoreAboutJs_description,
  "walkthroughs.nodejsWelcome.learnMoreAboutJs.altText": walkthroughs_nodejsWelcome_learnMoreAboutJs_altText
};

// src/service/pkgJson.ts
function getDefaultConfig() {
  const contributed = contributes.configuration.properties;
  const excludedDefaults = {
    "vtsls.experimental.completion.enableServerSideFuzzyMatch": false,
    "vtsls.experimental.completion.entriesLimit": null,
    "vtsls.experimental.maxInlayHintLength": null,
    "vtsls.enableMoveToFileCodeAction": false,
    "vtsls.autoUseWorkspaceTsdk": false,
    "vtsls.tsserver.globalPlugins": []
  };
  const overrideDefaults = {
    "typescript.tsserver.enableRegionDiagnostics": false,
    "typescript.tsserver.experimental.useVsCodeWatcher": false,
    "typescript.tsserver.watchOptions": {},
    "javascript.updateImportsOnPaste.enabled": false,
    "typescript.updateImportsOnPaste.enabled": false
  };
  const res = {};
  function updateDottedKey(key, val) {
    const parts = key.split(".");
    let node = res;
    for (let i = 0; node && i < parts.length - 1; i++) {
      if (!node[parts[i]]) {
        node[parts[i]] = {};
      }
      node = node[parts[i]];
    }
    if (node && parts.length) {
      node[parts[parts.length - 1]] = val;
    }
  }
  for (const [key, val] of Object.entries(contributed)) {
    let defaultVal = "default" in val ? val.default : void 0;
    if (!defaultVal && "type" in val) {
      if (val.type === "string") {
        defaultVal = "";
      } else if (val.type === "array") {
        defaultVal = [];
      }
    }
    updateDottedKey(key, defaultVal);
  }
  for (const [key, val] of Object.entries(excludedDefaults)) {
    updateDottedKey(key, val);
  }
  for (const [key, val] of Object.entries(overrideDefaults)) {
    updateDottedKey(key, val);
  }
  return res;
}
var tsDefaultConfig = getDefaultConfig();
function collectCommands() {
  const commandSet = /* @__PURE__ */ new Set();
  for (const event of activationEvents) {
    const commandName = event.split("onCommand:")[1];
    if (commandName) {
      commandSet.add(commandName);
    }
  }
  for (const { command } of contributes.commands) {
    commandSet.add(command);
  }
  const extraPrivateCommands = [
    "_typescript.applyCodeActionCommand",
    "_typescript.applyFixAllCodeAction",
    "_typescript.selectRefactoring",
    "_typescript.moveToFileRefactoring",
    "_typescript.didApplyRefactoring"
  ];
  for (const c of extraPrivateCommands) {
    commandSet.add(c);
  }
  return [...commandSet.values()];
}
var tsCommands = collectCommands();

// src/service/protocol.ts
import { CodeActionKind as CodeActionKind2 } from "vscode-languageserver-protocol";
init_languageFeatures();
init_workspace();
var completionTriggerCharacters = [".", '"', "'", "`", "/", "@", "<", "#", " ", "*"];
var signatureHelpTriggerCharacters = ["(", ",", "<"];
var signatureHelpReTriggerCharacters = [")"];
var codeActionKinds = [
  CodeActionKind2.Source,
  CodeActionKind2.SourceFixAll,
  CodeActionKind2.SourceOrganizeImports,
  CodeActionKind2.QuickFix,
  CodeActionKind2.Refactor,
  CodeActionKind2.RefactorExtract,
  CodeActionKind2.RefactorRewrite,
  CodeActionKind2.RefactorExtract
];
var semanticTokenTypes = [
  "class",
  "enum",
  "interface",
  "namespace",
  "typeParameter",
  "type",
  "parameter",
  "variable",
  "enumMember",
  "property",
  "function",
  "method"
];
var semanticTokenModifiers = [
  "declaration",
  "static",
  "async",
  "readonly",
  "defaultLibrary",
  "local"
];
var commands2 = [...tsCommands, CompletionCache.id];
var onTypeFormatFirstTriggerCharacter = ";";
var onTypeFormatMoreTriggerCharacter = ["}", "\n"];

// src/service/main.ts
async function startVsTsExtension(context) {
  const tsExtension = await Promise.resolve().then(() => (init_extension(), extension_exports));
  return {
    extensionApi: tsExtension.activate(context),
    dispose() {
      tsExtension.deactivate();
    }
  };
}
var serviceInstance = null;
function createTSLanguageService(initOptions) {
  if (serviceInstance) {
    throw new Error(
      "Cannot create multiple ts language services at the same time, or dispose the previous created one"
    );
  }
  const converter = new TSLspConverter(initOptions.clientCapabilities);
  const { delegate, events } = createTSLanguageServiceDelegate(converter);
  const toDispose = new DisposableStore2();
  const shims = toDispose.add(
    initializeShimServices(initOptions, delegate, tsDefaultConfig, package_nls_exports)
  );
  const serviceState = {
    state: "uninitialized",
    initialized: new Barrier(),
    disposed: false
  };
  const providers = shims.languageFeaturesService.$providers;
  const completionFeature = toDispose.add(
    new TSCompletionFeature(
      providers.$withRegistry(providers.completionItem),
      shims.configurationService,
      shims.commandsService,
      converter
    )
  );
  const codeActionFeature = toDispose.add(
    new TSCodeActionFeature(
      providers.$withRegistry(providers.codeActions),
      shims.configurationService,
      converter,
      initOptions.clientCapabilities
    )
  );
  const inlayHintFeature = new TSInlayHintFeature(
    providers.$withRegistry(providers.inlayHints),
    shims.configurationService,
    converter
  );
  const { commandsConverter: commandsConverter2 } = initializeShareMod(converter, shims.workspaceService);
  function wrapRequestHandler(handler) {
    return async (params, token = lsp12.CancellationToken.None) => {
      await serviceState.initialized.wait();
      await shims.languageFeaturesService.$staticFeaturesRegistered.wait();
      return await handler(params, token);
    };
  }
  function getOpenedDoc(uri) {
    return shims.workspaceService.$getOpenedDocThrow(uri);
  }
  const tsLanguageService = {
    ...events,
    // wait initial config
    async initialize(config3) {
      switch (serviceState.state) {
        case "uninitialized":
          try {
            serviceState.state = "initializing";
            shims.configurationService.$changeConfiguration(config3);
            toDispose.add(await startVsTsExtension(shims.context));
            serviceState.state = "initialized";
            serviceState.initialized.open();
          } catch (e) {
            tsLanguageService.dispose();
            throw e;
          }
          break;
        case "initializing":
          shims.configurationService.$changeConfiguration(config3);
          await serviceState.initialized.wait();
          break;
        default:
          break;
      }
    },
    dispose() {
      if (!serviceState.disposed) {
        toDispose.dispose();
        serviceState.disposed = true;
        serviceInstance = null;
      }
    },
    get initialized() {
      return serviceState.state === "initialized";
    },
    get disposed() {
      return serviceState.disposed;
    },
    changeConfiguration(params) {
      if (serviceState.state === "uninitialized") {
        void tsLanguageService.initialize(params.settings);
      } else {
        shims.configurationService.$changeConfiguration(params.settings);
      }
    },
    openTextDocument(params) {
      shims.workspaceService.$openTextDocument(params);
    },
    changeTextDocument(params) {
      shims.workspaceService.$changeTextDocument(params);
    },
    closeTextDocument(params) {
      shims.workspaceService.$closeTextDocument(params);
    },
    renameFiles(params) {
      shims.workspaceService.$renameFiles(params);
    },
    changeWorkspaceFolders(params) {
      shims.workspaceService.$changeWorkspaceFolders(params);
    },
    completion: wrapRequestHandler((params, token) => {
      const { textDocument, ...rest } = params;
      const doc = getOpenedDoc(textDocument.uri);
      return completionFeature.completion(doc, rest, token);
    }),
    completionItemResolve: wrapRequestHandler(
      (item, token) => completionFeature.completionItemResolve(item, token)
    ),
    documentHighlight: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.documentHighlight);
      const result = await provider.provideDocumentHighlights(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      if (!Array.isArray(result)) {
        return;
      }
      return result.map((r) => ({
        range: converter.convertRangeToLsp(r.range),
        kind: r.kind
      }));
    }),
    signatureHelp: wrapRequestHandler(async (params, token) => {
      var _a;
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.signatureHelp);
      const ctx = deepClone(params.context ?? {});
      ctx.triggerCharacter = ctx.triggerCharacter ?? "";
      if ((_a = ctx.activeSignatureHelp) == null ? void 0 : _a.signatures) {
        ctx.activeSignatureHelp.signatures = ctx.activeSignatureHelp.signatures.map(
          converter.convertSignatureInfoFromLsp
        );
      }
      const result = await provider.provideSignatureHelp(
        doc,
        converter.convertPositionFromLsp(params.position),
        token,
        ctx
      );
      if (result) {
        const transformed = {
          signatures: result.signatures.map(converter.convertSignatureInfoToLsp),
          activeParameter: result.activeParameter,
          activeSignature: result.activeSignature
        };
        return transformed;
      }
    }),
    documentLinks: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const entries = providers.$getProviders(doc, providers.documentLink);
      let results = [];
      for (const { provider } of entries) {
        const links = await provider.provideDocumentLinks(doc, token);
        if (links && links.length > 0) {
          results = results.concat(links.map(converter.convertDocumentLink));
        }
      }
      return results.length > 0 ? results : null;
    }),
    definition: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.definition);
      const result = await provider.provideDefinition(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      if (result) {
        return converter.convertDefinition(result);
      }
    }),
    references: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.reference);
      const result = await provider.provideReferences(
        doc,
        converter.convertPositionFromLsp(params.position),
        params.context,
        token
      );
      if (result) {
        return result.map(converter.convertLocation);
      }
    }),
    hover: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.hover);
      const result = await provider.provideHover(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      if (result) {
        return converter.convertHover(result);
      }
    }),
    documentSymbol: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.documentSymbol);
      const result = await provider.provideDocumentSymbols(doc, token);
      if (result) {
        return result.map(converter.convertSymbol);
      }
    }),
    workspaceSymbol: wrapRequestHandler(async (params, token) => {
      const { provider } = providers.$getProviderWithoutSelector(providers.workspaceSymbol);
      const result = await provider.provideWorkspaceSymbols(params.query, token);
      if (result) {
        return result.map(converter.convertSymbol);
      }
    }),
    codeAction: wrapRequestHandler((params, token) => {
      const { textDocument, ...rest } = params;
      const doc = getOpenedDoc(textDocument.uri);
      return codeActionFeature.codeAction(doc, rest, token);
    }),
    codeActionResolve: wrapRequestHandler(
      (item, token) => codeActionFeature.codeActionResolve(item, token)
    ),
    executeCommand: wrapRequestHandler(async (params) => {
      let args = params.arguments ?? [];
      const commandId = params.command;
      const cvt = commandsConverter2[commandId];
      if (cvt == null ? void 0 : cvt.fromArgs) {
        args = cvt.fromArgs(...args);
      }
      const result = await shims.commandsService.executeCommand(params.command, ...args);
      return (cvt == null ? void 0 : cvt.toRes) ? cvt == null ? void 0 : cvt.toRes(result) : result;
    }),
    implementation: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.implementation);
      const result = await provider.provideImplementation(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      if (result) {
        return converter.convertImplementation(result);
      }
    }),
    typeDefinition: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.typeDefinition);
      const result = await provider.provideTypeDefinition(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      if (result) {
        return converter.convertTypeDefinition(result);
      }
    }),
    documentFormatting: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(
        doc,
        providers.documentRangeFormattingEdit
      );
      const result = await provider.provideDocumentRangeFormattingEdits(
        doc,
        new Range(0, 0, doc.lineCount, 0),
        params.options,
        token
      );
      if (result) {
        return result.map(converter.convertTextEdit);
      }
    }),
    documentRangeFormatting: wrapRequestHandler(
      async (params, token) => {
        const doc = getOpenedDoc(params.textDocument.uri);
        const { provider } = providers.$getHighestProvider(
          doc,
          providers.documentRangeFormattingEdit
        );
        const result = await provider.provideDocumentRangeFormattingEdits(
          doc,
          converter.convertRangeFromLsp(params.range),
          params.options,
          token
        );
        if (result) {
          return result.map(converter.convertTextEdit);
        }
      }
    ),
    documentOnTypeFormatting: wrapRequestHandler(
      async (params, token) => {
        const doc = getOpenedDoc(params.textDocument.uri);
        const { provider } = providers.$getHighestProvider(doc, providers.onTypeFormatting);
        const result = await provider.provideOnTypeFormattingEdits(
          doc,
          converter.convertPositionFromLsp(params.position),
          params.ch,
          params.options,
          token
        );
        if (result) {
          return result.map(converter.convertTextEdit);
        }
      }
    ),
    prepareRename: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.rename);
      if (!provider.prepareRename) {
        throw new ProviderNotFoundError("prepareRename");
      }
      const result = await provider.prepareRename(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      if (result) {
        if (Range.isRange(result)) {
          return converter.convertRangeToLsp(result);
        } else {
          return {
            range: converter.convertRangeToLsp(result.range),
            placeholder: result.placeholder
          };
        }
      }
    }),
    rename: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.rename);
      const result = await provider.provideRenameEdits(
        doc,
        converter.convertPositionFromLsp(params.position),
        params.newName,
        token
      );
      if (result) {
        return converter.convertWorkspaceEdit(result);
      }
    }),
    foldingRanges: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.foldingRange);
      const result = await provider.provideFoldingRanges(doc, {}, token);
      if (result) {
        return result.map(converter.convertFoldingRange);
      }
    }),
    selectionRanges: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.selectionRange);
      const result = await provider.provideSelectionRanges(
        doc,
        params.positions.map((p) => converter.convertPositionFromLsp(p)),
        token
      );
      if (result) {
        return result.map(converter.convertSelectionRange);
      }
    }),
    prepareCallHierarchy: wrapRequestHandler(
      async (params, token) => {
        const doc = getOpenedDoc(params.textDocument.uri);
        const { id, provider } = providers.$getHighestProvider(doc, providers.callHierarchy);
        const result = await provider.prepareCallHierarchy(
          doc,
          converter.convertPositionFromLsp(params.position),
          token
        );
        if (Array.isArray(result)) {
          return result.map((item) => converter.convertCallHierarcgyItemToLsp(item, { id }));
        } else {
          return result ? [converter.convertCallHierarcgyItemToLsp(result, { id })] : null;
        }
      }
    ),
    incomingCalls: wrapRequestHandler(
      async (params, token) => {
        const { item } = params;
        const providerId = item.data.id;
        if (!providerId) {
          return null;
        }
        const { provider } = providers.$getProviderById(providerId, providers.callHierarchy);
        if (!provider.provideCallHierarchyIncomingCalls) {
          return null;
        }
        const result = await provider.provideCallHierarchyIncomingCalls(
          converter.convertCallHierarcgyItemFromLsp(item),
          token
        );
        if (result) {
          return result.map(converter.convertIncomingCall);
        }
        return null;
      }
    ),
    outgoingCalls: wrapRequestHandler(
      async (params, token) => {
        const { item } = params;
        const providerId = item.data.id;
        if (!providerId) {
          return null;
        }
        const { provider } = providers.$getProviderById(providerId, providers.callHierarchy);
        if (!provider.provideCallHierarchyOutgoingCalls) {
          return null;
        }
        const result = await provider.provideCallHierarchyOutgoingCalls(
          converter.convertCallHierarcgyItemFromLsp(item),
          token
        );
        if (result) {
          return result.map(converter.convertOutgoingCall);
        }
        return null;
      }
    ),
    inlayHint: wrapRequestHandler(async (params, token) => {
      const { textDocument, ...rest } = params;
      const doc = getOpenedDoc(textDocument.uri);
      return inlayHintFeature.inlayHint(doc, rest, token);
    }),
    codeLens: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const entries = providers.$getProviders(doc, providers.codeLens);
      const results = await Promise.all(
        entries.map(async ({ provider, id }) => {
          const items = await provider.provideCodeLenses(doc, token);
          if (items) {
            return items.map(
              (item) => converter.convertCodeLens(item, {
                document: item.document.toString(),
                file: item.file,
                isResolved: false,
                id
              })
            );
          }
        })
      );
      let merged = [];
      for (const r of results) {
        if (!r) {
          continue;
        }
        merged = merged.concat(r);
      }
      if (merged.length > 0) {
        return merged;
      }
    }),
    codeLensResolve: wrapRequestHandler(async (item, token) => {
      var _a;
      const providerId = item.data.id;
      if (!providerId || item.data.isResolved) {
        return item;
      }
      const { provider } = providers.$getProviderById(providerId, providers.codeLens);
      if (!provider.resolveCodeLens) {
        return item;
      }
      const { ReferencesCodeLens: ReferencesCodeLens4 } = await Promise.resolve().then(() => (init_baseCodeLensProvider(), baseCodeLensProvider_exports));
      const refLens = new ReferencesCodeLens4(
        URI9.parse(item.data.document),
        item.data.file,
        converter.convertRangeFromLsp(item.range)
      );
      const result = await provider.resolveCodeLens(refLens, token);
      if (((_a = result == null ? void 0 : result.command) == null ? void 0 : _a.command) === "editor.action.showReferences") {
        result.command.arguments = commandsConverter2[result.command.command].toArgs(
          ...result.command.arguments
        );
        const converted = converter.convertCodeLens(result, { isResolved: true });
        return converted;
      } else {
        return item;
      }
    }),
    semanticTokensFull: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.documentSemanticTokens);
      const result = await provider.provideDocumentSemanticTokens(doc, token);
      if (result) {
        return converter.convertSemanticTokens(result);
      }
      return { data: [] };
    }),
    semanticTokensRange: wrapRequestHandler(
      async (params, token) => {
        const doc = getOpenedDoc(params.textDocument.uri);
        const { provider } = providers.$getHighestProvider(
          doc,
          providers.documentRangeSemanticTokens
        );
        const result = await provider.provideDocumentRangeSemanticTokens(
          doc,
          converter.convertRangeFromLsp(params.range),
          token
        );
        if (result) {
          return converter.convertSemanticTokens(result);
        }
        return { data: [] };
      }
    ),
    linkedEditingRange: wrapRequestHandler(async (params, token) => {
      const doc = getOpenedDoc(params.textDocument.uri);
      const { provider } = providers.$getHighestProvider(doc, providers.linkedEditingRange);
      const result = await provider.provideLinkedEditingRanges(
        doc,
        converter.convertPositionFromLsp(params.position),
        token
      );
      return result && converter.convertLinkedEditingRanges(result);
    })
  };
  serviceInstance = tsLanguageService;
  return tsLanguageService;
}
export {
  DocumentNotOpenedError,
  ProviderNotFoundError,
  codeActionKinds,
  commands2 as commands,
  completionTriggerCharacters,
  createTSLanguageService,
  onTypeFormatFirstTriggerCharacter,
  onTypeFormatMoreTriggerCharacter,
  semanticTokenModifiers,
  semanticTokenTypes,
  signatureHelpReTriggerCharacters,
  signatureHelpTriggerCharacters
};
