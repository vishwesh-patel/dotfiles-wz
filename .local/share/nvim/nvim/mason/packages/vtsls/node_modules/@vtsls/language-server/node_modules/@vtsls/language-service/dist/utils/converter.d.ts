import type * as vscode from "vscode";
import * as lsp from "vscode-languageserver-protocol";
import * as types from "../shims/types";
declare class LspInvariantConverter {
    convertTextEdit: (edit: vscode.TextEdit) => lsp.TextEdit;
    convertPositionToLsp: (pos: vscode.Position) => lsp.Position;
    convertRangeToLsp: (range: vscode.Range) => lsp.Range;
    convertPositionFromLsp: (position: lsp.Position) => vscode.Position;
    convertRangeFromLsp: (range: lsp.Range) => vscode.Range;
}
export declare class TSLspConverter extends LspInvariantConverter {
    private readonly clientCapabilities;
    constructor(clientCapabilities: lsp.ClientCapabilities);
    convertWorkspaceEdit: (edit: vscode.WorkspaceEdit) => lsp.WorkspaceEdit;
    convertCompletionItem: (item: vscode.CompletionItem, data?: any) => lsp.CompletionItem;
    convertLocationLink: (location: vscode.LocationLink) => lsp.LocationLink;
    convertLocationLinkToLocation: (location: vscode.LocationLink) => lsp.Location;
    convertLocation: (location: vscode.Location) => lsp.Location;
    private convertLocations;
    convertDefinition: (location: vscode.Definition | vscode.LocationLink[]) => lsp.Location | lsp.Location[] | lsp.LocationLink[];
    convertImplementation: (location: vscode.Definition | vscode.LocationLink[]) => lsp.Location | lsp.Location[] | lsp.LocationLink[];
    convertTypeDefinition: (location: vscode.Definition | vscode.LocationLink[]) => lsp.Location | lsp.Location[] | lsp.LocationLink[];
    convertDocumentLink: (link: vscode.DocumentLink, data?: any) => lsp.DocumentLink;
    convertDiagnosticFromLsp: (diagnostic: lsp.Diagnostic) => vscode.Diagnostic;
    convertDiagnosticToLsp: (diagnostic: vscode.Diagnostic) => lsp.Diagnostic;
    convertCodeAction(action: vscode.CodeAction, data?: any): lsp.CodeAction;
    convertCodeAction(action: vscode.Command, data?: any): lsp.Command;
    convertCodeAction<T extends vscode.CodeAction | vscode.Command>(action: T, data?: any): T extends vscode.CodeAction ? lsp.CodeAction : lsp.Command;
    convertHover: (hover: vscode.Hover) => lsp.Hover;
    convertSymbol: (symbol: vscode.SymbolInformation | vscode.DocumentSymbol) => lsp.SymbolInformation | lsp.DocumentSymbol;
    convertMarkupfromLsp: (doc: string | lsp.MarkupContent) => string | vscode.MarkdownString;
    convertMarkupToLsp: (doc: string | vscode.MarkdownString) => string | lsp.MarkupContent | undefined;
    convertSignatureInfoFromLsp: (info: lsp.SignatureInformation) => vscode.SignatureInformation;
    convertSignatureInfoToLsp: (info: vscode.SignatureInformation) => lsp.SignatureInformation;
    convertCallHierarcgyItemToLsp: (item: vscode.CallHierarchyItem, data?: any) => lsp.CallHierarchyItem;
    convertCallHierarcgyItemFromLsp: (item: lsp.CallHierarchyItem) => types.CallHierarchyItem;
    convertInlayHint: (hint: vscode.InlayHint) => lsp.InlayHint;
    convertIncomingCall: (item: vscode.CallHierarchyIncomingCall) => lsp.CallHierarchyIncomingCall;
    convertOutgoingCall: (item: vscode.CallHierarchyOutgoingCall) => lsp.CallHierarchyOutgoingCall;
    convertFoldingRange: (range: vscode.FoldingRange) => lsp.FoldingRange;
    convertSelectionRange: (range: vscode.SelectionRange) => lsp.SelectionRange;
    convertCodeLens: (lens: vscode.CodeLens, data?: any) => lsp.CodeLens;
    convertSemanticTokens: (tokens: vscode.SemanticTokens) => lsp.SemanticTokens;
    convertLinkedEditingRanges: (data: vscode.LinkedEditingRanges) => lsp.LinkedEditingRanges;
}
export {};
//# sourceMappingURL=converter.d.ts.map