import * as vscode from 'vscode';
import { ServiceConfigurationProvider, TypeScriptServiceConfiguration } from './configuration/configuration';
import { IExperimentationTelemetryReporter } from './experimentTelemetryReporter';
import { DiagnosticKind, DiagnosticsManager } from './languageFeatures/diagnostics';
import { Logger } from './logging/logger';
import { TelemetryReporter } from './logging/telemetry';
import { API } from './tsServer/api';
import BufferSyncSupport from './tsServer/bufferSyncSupport';
import { OngoingRequestCancellerFactory } from './tsServer/cancellation';
import { ILogDirectoryProvider } from './tsServer/logDirectoryProvider';
import { PluginManager } from './tsServer/plugins';
import * as Proto from './tsServer/protocol/protocol';
import { TsServerProcessFactory } from './tsServer/server';
import { ITypeScriptVersionProvider, TypeScriptVersion } from './tsServer/versionProvider';
import { ClientCapabilities, ClientCapability, ExecConfig, ITypeScriptServiceClient, ServerResponse, TypeScriptRequests } from './typescriptService';
import { Disposable } from './utils/dispose';
export interface TsDiagnostics {
    readonly kind: DiagnosticKind;
    readonly resource: vscode.Uri;
    readonly diagnostics: Proto.Diagnostic[];
    readonly spans?: Proto.TextSpan[];
}
export declare const emptyAuthority = "ts-nul-authority";
export declare const inMemoryResourcePrefix = "^";
export default class TypeScriptServiceClient extends Disposable implements ITypeScriptServiceClient {
    private readonly context;
    private readonly _onReady?;
    private _configuration;
    private readonly pluginPathsProvider;
    private readonly _versionManager;
    private readonly _nodeVersionManager;
    private readonly logger;
    private readonly tracer;
    private readonly typescriptServerSpawner;
    private serverState;
    private lastStart;
    private numberRestarts;
    private _isPromptingAfterCrash;
    private isRestarting;
    private hasServerFatallyCrashedTooManyTimes;
    private readonly loadingIndicator;
    readonly telemetryReporter: TelemetryReporter;
    readonly bufferSyncSupport: BufferSyncSupport;
    readonly diagnosticsManager: DiagnosticsManager;
    readonly pluginManager: PluginManager;
    private readonly logDirectoryProvider;
    private readonly cancellerFactory;
    private readonly versionProvider;
    private readonly processFactory;
    private readonly watches;
    private readonly watchEvents;
    private watchChangeTimeout;
    constructor(context: vscode.ExtensionContext, onCaseInsensitiveFileSystem: boolean, services: {
        pluginManager: PluginManager;
        logDirectoryProvider: ILogDirectoryProvider;
        cancellerFactory: OngoingRequestCancellerFactory;
        versionProvider: ITypeScriptVersionProvider;
        processFactory: TsServerProcessFactory;
        serviceConfigurationProvider: ServiceConfigurationProvider;
        experimentTelemetryReporter: IExperimentationTelemetryReporter | undefined;
        logger: Logger;
    }, allModeIds: readonly string[]);
    get capabilities(): ClientCapabilities;
    private readonly _onDidChangeCapabilities;
    readonly onDidChangeCapabilities: vscode.Event<void>;
    private isProjectWideIntellisenseOnWebEnabled;
    private cancelInflightRequestsForResource;
    get configuration(): TypeScriptServiceConfiguration;
    dispose(): void;
    restartTsServer(fromUserAction?: boolean): void;
    private readonly _onTsServerStarted;
    readonly onTsServerStarted: vscode.Event<{
        version: TypeScriptVersion;
        usedApiVersion: API;
    }>;
    private readonly _onDiagnosticsReceived;
    readonly onDiagnosticsReceived: vscode.Event<TsDiagnostics>;
    private readonly _onConfigDiagnosticsReceived;
    readonly onConfigDiagnosticsReceived: vscode.Event<Proto.ConfigFileDiagnosticEvent>;
    private readonly _onResendModelsRequested;
    readonly onResendModelsRequested: vscode.Event<void>;
    private readonly _onProjectLanguageServiceStateChanged;
    readonly onProjectLanguageServiceStateChanged: vscode.Event<Proto.ProjectLanguageServiceStateEventBody>;
    private readonly _onDidBeginInstallTypings;
    readonly onDidBeginInstallTypings: vscode.Event<Proto.BeginInstallTypesEventBody>;
    private readonly _onDidEndInstallTypings;
    readonly onDidEndInstallTypings: vscode.Event<Proto.EndInstallTypesEventBody>;
    private readonly _onTypesInstallerInitializationFailed;
    readonly onTypesInstallerInitializationFailed: vscode.Event<Proto.TypesInstallerInitializationFailedEventBody>;
    private readonly _onSurveyReady;
    readonly onSurveyReady: vscode.Event<Proto.SurveyReadyEventBody>;
    get apiVersion(): API;
    onReady(f: () => void): Promise<void>;
    ensureServiceStarted(): void;
    private token;
    private startService;
    private resetWatchers;
    showVersionPicker(): Promise<void>;
    openTsServerLogFile(): Promise<boolean>;
    private serviceStarted;
    private setCompilerOptionsForInferredProjects;
    private getCompilerOptionsForInferredProjects;
    private serviceExited;
    toTsFilePath(resource: vscode.Uri): string | undefined;
    toOpenTsFilePath(document: vscode.TextDocument | vscode.Uri, options?: {
        suppressAlertOnFailure?: boolean;
    }): string | undefined;
    hasCapabilityForResource(resource: vscode.Uri, capability: ClientCapability): boolean;
    toResource(filepath: string): vscode.Uri;
    getWorkspaceRootForResource(resource: vscode.Uri): vscode.Uri | undefined;
    execute(command: keyof TypeScriptRequests, args: any, token: vscode.CancellationToken, config?: ExecConfig): Promise<ServerResponse.Response<Proto.Response>>;
    executeWithoutWaitingForResponse(command: keyof TypeScriptRequests, args: any): void;
    executeAsync(command: keyof TypeScriptRequests, args: Proto.GeterrRequestArgs, token: vscode.CancellationToken): Promise<ServerResponse.Response<Proto.Response>>;
    private executeImpl;
    interruptGetErr<R>(f: () => R): R;
    private fatalError;
    private dispatchEvent;
    private scheduleExecuteWatchChangeRequest;
    private addWatchEvent;
    private createFileSystemWatcher;
    private closeFileSystemWatcher;
    private dispatchTelemetryEvent;
    private configurePlugin;
}
//# sourceMappingURL=typescriptServiceClient.d.ts.map